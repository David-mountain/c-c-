# 数据结构学习经验
## 如何把数据存入计算机并进行处理
## 存数值，存关系
    ### 顺序存储不用存关系？链表呢？
        看似没有，实则存储了。它的物理存储特点满足了逻辑结构的需求。然后链表因为是离散的，无法满足逻辑结构的需求，需要额外的指针域来存储数据之间的关系。

# 数组顺序表
typedef int ElemType;
#define LIST_SIZE 1024 
#define TRUE 1
#define FALSE 0
typedef struct 
{
    ElemType data[LIST_SIZE];
    int last;
}SequenList;
SequenList* IPtr;
## 1.初始化 
SequenList* InitSeq ()
{
    SequenList* pList;
    pList = (SequenList*)malloc(sizeof(SequenList));

    if ( pList != NULL )
    {
        pList->last = 0;
    }
    return pList;
}
## 2.求长度 
int GetSizeSeq (SequenList* pList)
{
    return pList->last;
}
## 3.取-给定位置的元素值
int GetElemSqList (SequenList* pList, int pos, ElemType *e)
{
    if ( pos<0 || pos>pList->last )
    {
        return FALSE;
    }
    if ( pList->last <= 0 )
    {
        return FALSE;
    }

    *e = pList->data[pos];
    return TRUE;
}
## 4.查-给给定元素的位置
int LocateElemSqList (SequenList* pList, ElemType key)
{
    int i = 0;
    for ( i=0; i<pList-last; i++ )
    {
        if ( pList->data[i] == key )
        {
            return i;
        }
    }
    return -1;
}
## 5.插-给定位置插入元素
int InsertElemSqList (SequenList* pList, ElemType x, int pos)
{
    int j = 0;
    if ( pList->last >= LIST_SIZE-1 )
    {
        return FALSE;
    }
    if ( pos<0 || pos>(pList->last+1) )
    {
        return FALSE;
    }
    
    for ( j=pList->last; j>=k; j-- )
    {
        pList->data[j+1] = pList->data[j];
    }
    pList->data[pos] = x;
    pList->last = pList->last + 1;
    return TRUE;
}
## 6.删-指定位置的值
int DelElemSqList (SequenList* pList, int pos)
{
    if ( (pos>=0 && pos<=pList->last) && (pList->last != 0) )
    {
        for ( int j=pos; j<pList->last; j++ )
        {
            pList->data[j] = pList->data[j+1];
        }
        pList->last--;
        return TRUE;
    }
    return FALSE;
}
## 7.遍历
void showSeqList (SequenList* pList)
{
    int i = 0;
    for ( i=0; i<pList->last; i++ )
    {
        printf("%d ", pList->data[i]);
    }
}


