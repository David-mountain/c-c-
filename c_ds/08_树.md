# 树

## 🧔🧔🧔强调

1. 数据结构是程序的灵魂，效果是API程序员的基本门槛，但是程序的核心，恐怕不是API程序员所能完成的
2. 数据结构不是做几道题，而是实实在在的可以在工程问题中解决问题的
3. 伪代码仅仅是告诉你思想，一定要上机练习

## (一) 树的认识和导学

```
树：一种逻辑关系分层次的非线性结构
在计算机中，无论是数组还是链表都是线性的，我们就是需要利用这两种物理结构，来表达树形的逻辑结构
学习树的程序设计知识主要要掌握：
	了解数据的逻辑结构从线性结构到非线性结构的过渡
	了解包含子结构的线性结构
	理解链式存储结构在表达非线性数据结构的作用
	掌握树的概念、存储方法、基本运算

引例：图书馆的书，计算机的目录结构，网站的标签结构
	总结树的逻辑特征：树中的任何一个结点都可以有0个或者多个直接后继，但至多只有一个直接前驱结点(双亲)，只有根节点没有前驱，因为它是开始结点；叶子结点没有后继，它们是终端结点。
祖先结点和子孙结点是父子关系的拓展，它定义了树中结点之间的纵向次序。
有序树中，同一组兄弟结点从左到右有长幼之分。如果对这个关系扩展，那么我们可以认为兄弟关系定义了树的横向秩序。
存储树形关系的核心：♥♥♥能够得到一个结点的双亲和孩子，就是好的存储。

有横向关系，有纵向关系
数据结构无外乎，就是怎么存，怎么联系，怎么去增删改查
第一步存：存数值 ♥♥♥存关系

🧔🧔🧔树的存储结构 
♥♥♥对于设计好的存储结构，检验的标准则是只要在存储结构中能找到一个结点的这两种关系，那么这样的存储结构设计就是可行的，我们称之为"双亲孩子检验原则"。

🧔🧔🧔树连续存储1-双亲孩子表示法
typedef struct
{
  datatype data;
  int parent;
  int child[D]; // D-树的度 即分支
} PCtree;
PCree T[N]; // T-树结点数 即多少个
分析：
这里使用数组来实现树的逻辑结构，定义一个结构体，多定义几个变量来存储关系，这里的关系就是存储双亲的下标和孩子的下标，因为可能多个孩子，使用了一个数组存储。这就是一个合理的存储结构。
缺点：不是每个结点都有孩子的，所以极端情况下，可能多数结点的指针域是空的，这就冗余了，浪费了存储空间。  所以优化--。

🧔🧔🧔树的连续存储2-双亲表示法
typedef struct
{
  datatype data;
  int parent; // 双亲下标
} Ptree;
Ptree T[N]; // N是树结点数
分析：
缺点：不好找孩子结点，找双亲好找。  所以优化--

🧔🧔🧔树连续存储3--孩子表示法
typedef struct
{
  datatype data;
  int child[D]; // 孩子下标 D是几个孩子
} Ctree;
Ctree T[N];
分析：
缺点：不好找双亲结点，找孩子好找。  所以优化--

🧔🧔🧔树的链式存储--多叉树的多指针域
当存多叉树的时候，定义每个结点的时候，指针域都不同，十分麻烦。这我们就要考虑结点指针域是同构的还是异构的！
	同构：每个指针都是相同的指针域
	异构：每个指针域不同
为了避免结点的异构性，我们最好统一树的度，从而可以同构结点类型，所以就有了同构的设计思路。
同构的优点：消除了异构型的缺陷，结构的统一化管理变的容易了。
还有一个问题，如果多数结点的度小于树的度，则部分指针域为空，造成存储空间浪费。
	♥引发思考：什么样的树既可在使用同构型结构的时候，空的指针域最少？

🧔🧔🧔树的结构讨论：数学建模 抽象
设有n个结点，度为d的树，用同构性结点存储
	则整个链表共有指针域 n*d个
	有用的指针域数 n-1个  (根节点不占指针域，它没有内容？？)
	空的指针域数  n(d-1)+1个 [nd-(n-1)]
列出式子：计算空域占比
R = lim(n->无穷)[n(d-1)+1]/nd=1-1/d
我们希望R越小，则要1-1/d越大，则1/d越大，d越小越好，这里取到1，即一个度，没有孩子了，没实际意义了，所以取到2. 证明二叉是最合适的树结构，既方便定义树结点，又节省内存。
但是这是二叉的阿，现实数据中肯定不止二叉的，那咋办呢？
	只要我们找到二叉树和树相互转换的办法，即可。
	我们先讨论二叉树的存储，再讨论转换树的问题

🧔🧔🧔树链式存储--孩子兄弟表示法(二叉树表示法)
结构描述：firstChild data nextsibling 
缺点：这种方法，找结点的双亲不容易，找孩子容易。

🧔🧔🧔孩子链表表示法
结构描述：数组+链表组合
启发：计算机中存储数据，一般是数组和链表，多了一种数组+链表的组合，组合性，不是学死了知识！
缺点：找孩子方便，找双亲不方便。

🧔🧔🧔二叉树与树的转换
--普通树转二叉树
1. 加线：兄弟加线 
2. 去线：只保留第一个孩子的连线，与其他孩子连线删除
3. 向上一提 搞定
即可转到二叉树

--二叉树转普通树
1. 加线：如果某结点x是其双亲y的左孩子，那么，就把就把x的所有右孩子都与y相连 (恢复结点与孩子的关系)
2. 去线：删除原二叉树的所有双亲结点与右孩子的连线 (去掉兄弟之间的关系)
即可恢复到普通树

🧔🧔🧔树与二叉树的存储关系
实际上，对于树的二叉链表存储方式，就是前文的孩子兄弟存储法，只是指针域的含义不同。
只要我们能够以二叉链表方式存储，那么相关的ADT都可以很方便的处理树的孩子兄弟算法。

🧔🧔🧔二叉树概念
二叉树是是每个结点最多有两个子树的有序树
左右子树的顺序不能互换 

二叉树与树的区别是什么？
两个主要差别：
  1. 树中结点的最大度数没有限制，而二叉树结点的最大度是2
  2. 树的结点无左、右之分，而二叉树的结点有左、右之分
  
🧔🧔🧔二叉树的特殊形态--完全二叉树
可以说满二叉树是完全二叉树的特例情形 

判断一颗二叉树是否是完全二叉树的算法：
先以k层满二叉树进行连续编号，在去掉若干结点之后，树的编号仍连续，那么就是完全二叉树

🧔🧔🧔二叉树的基本性质
性质1：在二叉树的第i层上至多有2^(i-1)个结点(i>=1)
性质2：深度为h的二叉树至多有2^h - 1个结点(h>=1)
性质3：对任何一棵树，若它含有n0个叶子结点，n2个度为2的结点，则必然存在关系式：n0=n2+1

🧔🧔🧔二叉树的操作定义
构造
查找
插入
遍历
求深度

🧔🧔🧔二叉树顺序存储--结点间关系分析
根据二叉树的性质分析，一个深度为h的二叉树，我们最多可以预先分配2^h - 1个空间，这就为顺序存储奠定了计算基础

🧔🧔🧔二叉树顺序存储--结点位置分析
将根结点从下标1开始，对应编号，数组的下标直接反应了位置关系
设某个结点的单元序号为i:
双亲 i/2 
左孩子2*i  右孩子2*i+1
左兄弟i-1  右兄弟i+1 ？

退化的二叉树的存储
在一般二叉树中，可能存在退化情况，会造成大量冗余空间的浪费，就是形成了单链表的形式

🧔🧔🧔二叉树的链式存储结构
结构设计：Lchild data Rchild 
二叉树的每个结点含有两个指针域来分别指向相应的分支，类似孩子双亲表示法，又叫二叉链表结构
二叉查找树，又叫二叉搜索树，binary search tree 
	若一棵树的左子树所有的之都比根结点小，右子树的值都比根大
	
🧔🧔🧔层次输入法创建二叉链表方法(较为复杂的一种)




```

## (二) 顺序数组-建立-二叉搜索树

```c
算法思路：
// 遍历传入的数据数组，数组是从第二个开始存储元素的，这样是为了匹配完全二叉树的编号
// 然后取出每一个遍历元素，判断是否为0，如果不是0，从根元素所在作为第一层，根据结点位置关系
// 2i 2i+1左右孩子位置，进行循环判断，每次level*2或者level*2+1之后，都会重新判断所在元素是否为0
// 不为0说明已经有元素了，是0说明则是没有结点的位置，最后赋值即可
// 关键点：每次都是从第一层开始找位置 
void create_btree (int b_tree, int nodelist[], int len)
{
  int i;
  int level = 0;
  b_tree[1] = nodelist[1]; // 为了和完全二叉树编号对应 不用下标0位置的存储单元
  				// 我自己写代码：b_tree[0] = nodelist[0]; 整个就完全不一样了
  
  for ( i=2; i<len; i++ ) // 第二个才是真正的开始元素
  {
    level = 1; // 每次都是从第level=1开始，也就是2个元素的那层
    
    // 找位置 向下方的孩子进行拓展判断 其实就是找到叶子结点了 
    while ( b_tree[level] != 0 )
    {
      if ( nodelist[i] < b_tree[level] )
        level = level * 2;
      else 
        level = level * 2 + 1;
    }
    // 找到位置 即赋值
    b_tree[level] = nodelist[i];
  }
}

int main ()
{
  int b_tree[16] = { 0 };
  int nodelist[16] = {
        0,6,3,8,
        5,2,9,4,7,
        0,0,0,0,
        0,0,0
  }; // 0不用做编号
  
  create_btree(b_tree, nodelist, 16);
  for ( int i=1; i<16; i++ )
    printf("%d,[%d] \n", i, b_tree[i]);
}
// 1,[6] 2,[3] 3,[8] 4,[2] 5,[5] 6,[7] 7,[9] 8,[0] 9,[0] 10,[4] 11,[0] 12,[0] 13,[0] 14,[0] 15,[10]
// 6 3 8 2 5 7 9 0 0 4 0 0 0 0 10
```

## (三) 层次法-二叉链表-建立-二叉搜索树

```c
typedef int dataType;
typedef struct node
{
  dataType data;
  struct node *left, *right;
} BitTree;

BitTree* CreateBinTree (int arr[])
{
  int i = 1;
  int front = 1, rear = 0; // 难点：为什么设置成rear0？front是1？
  BitTree *root = NULL;
  BitTree *s = NULL;
  
  while ( arr[i] != -9999 )
  {
    s = NULL; // 写代码时候，这个忘记了，我写代码时候没有理解到这句代码意思，
    		 // s没有置空写就是上次循环的结点，我第一次的时候总是遍历出来数据不对，debugger发现的
    
    if ( arr[i] != 0 )
    {
      // 不等于0，则不是空结点，申请空间
      s = (BitTree*)malloc(sizeof(BitTree));
      if (s)
      {
        s->data = arr[i];
        s->left = NULL;
        s->right = NULL;      
      }
    }
    Q[++rear] = s;
    
    if ( rear == 1 )
      root = s;
    else 
    {
      if ( s != NULL && Q[front] )
      {
        if ( rear%2 == 0 )
          Q[front]->left = s;
        else 
          Q[front]->right = s;
      }
      
      if ( rear%2 == 1 )
        ++front;
    }
    
    ++i;
  }
  
  return root;
}

//树遍历问题：非线性结构的输出问题：前序，中序，后序
void inorder(BitTree *t) {
	if (t) {
		inorder(t->left);
		printf("%d ", t->data);
		inorder(t->right);
	}
}

void preorder(BitTree* t) {
	if (t) {
		//根左右
		printf("%d ", t->data);
		preorder(t->left);
		preorder(t->right);
	}
}

void postorder(BitTree* t) {
	if (t) {
		//左右根
		postorder(t->left);
		postorder(t->right);
		printf("%d ", t->data);
	}
}

int main ()
{
  int arr[17] = {0,6,3,8,
                 2,5,7,9,
                 0,0,4,0,
                 0,0,0,10,
                 -999
  };
  注意：一定要单步调试
  BitTree *root = CreateBinTree(arr);
  inorder(root);
}
```

## (四) 树的遍历

```
非线性结构地输出
如何才能显示出一个观念中的树？
观念中的树一直存在的，但是观念中的树我们有不同的呈现方式
我们通过构造树的形态，并赋予其关键的特征，使得这个结构帮助我们完成某些功能
前序中序后序的遍历和使用计算机输出我们观念中的树 没有必然和直接的关系
它们的出现是为了解决树形结构的遍历问题
遍历的本质就是对目标结构(树)的所有结点不重复，不遗漏的周游一遍，使得所有元素有且一次访问

递归遍历
无论是前根中根后根遍历都是递归定义的树形结构
可以使用使用递归访问，而层次法没有递归形式，因此不能用递归，必须依靠其他工具满足遍历的需求
树是的递归定义的，因此天然地使用递归是最自然的，如果不使用递归形式，则需要其他工具，这就是层次访问需要使用队列的一个原因

对于初学者
构建观念中的二叉树十分重要，因为实际开发中，往往通过抽象来表达
只有头脑中有图，能构建出二叉树的模型，才能有效的编写出相应的算法
```

#### 递归遍历

```c
// 前序
void preorder (BitTree *t)
{
  if ( t )
  {
    printf("%d ", t->data);
    preorder(t->left);
    preorder(t->right);
  }
}

// 中序
void postorder (BitTree *t)
{
  if ( t )
  {
    postorder(t->left);
    portorder(t->right);
    printf("%d ", t->data);
  }
}
```

#### 非递归遍历

```c
// 需要辅助栈 作用：主要用来保存树的结点，存树结点的栈
// 对栈，有所修改，因为这里是树了，有些形参需要变动

#include <stdio.h>
#include <stdlib.h>
typedef int datatype;
typedef struct node
{
	datatype data;
  	struct node *left, *right;
} BitTreeNode;

// 辅助栈 ********
typedef struct linknode
{
	BitTreeNode *_NodeAddCopy;
  	strcut linknode *pNext;
} LinkStack;

LinkStack* InitLkStack (void)
{
	LinkStack *p = NULL;
  	p = (LinkStack *)malloc(sizeof(LinkStack));
  	if ( p != NULL )
      	p->pNext = NULL;
  	return p;
}
BOOL IsEmptyLkMazeStack (LinkStack *top)
{
	return (top->pNext == NULL);
}
LinkStack* PushLkStack (LinkStack *top, BitTreeNode *elem)
{
  LinkStack* p = NULL;
  if (elem != NULL)
  {
    p = (LinkStack*)malloc(sizeof(LinkStack));
    p->_NodeAddrCopy = elem;
    p->pNext = top;
    top = p;
  }
  
  return top;
}
LinkStack* PopLkStack(LinkStack* top, BitTreeNode *pData) 
{
  LinkStack* p;
  if (top != NULL) 
  {
    pData = top->_NodeAddrCopy;
    p = top;
    top = p->pNext;
    free(p);
  }
  
  return top;
}
// *********

// 辅助队列 用来存关系的
BitTree* Q[16];

BitTree* CreateBinTree (int arr[])
{
  int i = 1;
  int front = 1, rear = 0;
  BitTree *root = NULL;
  BitTree *s;
  
  while ( arr[i] != -9999 )
  {
    s = NULL;
    
    if ( arr[i] != 0 )
    {
      // 不等于0，则不是空结点，申请空间
      s = (BitTree*)malloc(sizeof(BitTree));
      s->data = arr[i];
      s->left = NULL;
      s->right = NULL;
    }
    Q[++rear] = s;
    
    if ( rear == 1 )
      root = s;
    else 
    {
      if ( s != NULL && Q[front] )
      {
        if ( rear%2 == 0 )
          Q[front]->left = s;
        else 
          Q[front]->right = s;
      }
      
      if ( rear%2 == 1 )
        front++;
    }
    
    ++i;
  }
  
  return root;
}

// 非递归先序遍历
void NonRecrvPreOrder(BitTree* root) {
	LinkStack* pTop = NULL;
	//BitTreeNode TempNode;//用来接栈中对应的二叉树节点的
	//-----change by dingst
	BitTreeNode* pNode; //我要让pNode推进树遍历，而且pNode就是
	//真实地址的副本
	pTop = InitLkStack();
	
	//pTop = PushLkStack(pTop, root);
	//---change by dingst
	pNode = root;
	pTop = PushLkStack(pTop, pNode);
	while (!IsEmptyLkMazeStack(pTop)) {
		pNode = pTop->_NodeAddrCopy;//178行的这个赋值操作，就将真实的节点地址赋给了pNode这个函数的局部变量
		pTop = PopLkStack(pTop, pNode);
		if (pNode != NULL) {
			printf("%d ",pNode->data);
			//对右子树压栈
			pTop = PushLkStack(pTop, pNode->right);
			pTop = PushLkStack(pTop, pNode->left);
		}
	}

}

// 非递归中序遍历
void NonRecvInorder(BitTree *root) {
	LinkStack* pTop = NULL;
	BitTreeNode TempNode;//用来接收栈中的对应的二叉树的节点

	pTop = InitLkStack();
	BitTree *p = root;
	while (p != NULL || !IsEmptyLkMazeStack(pTop)) {
		while (p != NULL) {
			pTop = PushLkStack(pTop, p);
			p = p->left;
		}
		if (!IsEmptyLkMazeStack(pTop)) {
			//因为此时我们在输出的节点信息，就一定要从栈中
			//取出元素
			//这个是取出的元素的_NodeAddrCopy分量就是树中节点的地址
			//因此对这个节点使用->就可以获得真实的数据
			printf("%d ", pTop->_NodeAddrCopy->data);
			p = pTop->_NodeAddrCopy; //因为我们设计的p就是要走完root全部节点，因此
									//p必须获得的是树节点的真实地址
			pTop = PopLkStack(pTop, &TempNode);//当我们把左子树的左叶子节点走完以后，
											   //此时栈顶一定是这个左孩子的根，所以根据左根右，这个根要出栈
			//----change by dingst
											   //p = &TempNode; 因为tmpenode是bitnode的对象，
			//所以tmpenode的地址值可以赋值给p这个指针变量，但是这个tempnode的这个地址值
			//是肯定不等于真实树节点的地址值的
			p = p->right;//走向根的右孩子 
		}
	}
}

// 非递归后序遍历
void NonRecvPostorder(BitTree* root) {
	BitTree* cur;//当前节点==>cur 保存的就是树节点的地址
	BitTree* pre = NULL;//前一次访问的节点

	LinkStack* pTop = NULL;
	BitTreeNode TempNode;//注意我们就是用tempnode来接里面的内容，他是不能参与地址比较的，他的地址一定和我们栈中的地址不一样
	pTop = InitLkStack();
	pTop = PushLkStack(pTop, root);

	while (!IsEmptyLkMazeStack(pTop)) {
		cur = pTop->_NodeAddrCopy;//拿到栈中深拷贝获得的节点
						  //在访问中，由于我们是深拷贝树的节点，因此，pre和cur的地址不一样，我们只能比较器元素内容
						  //小技巧：利用短路，确保程序的可靠性
		if ((cur->left == NULL && cur->right == NULL) ||
			(pre != NULL && (pre == cur->left|| pre == cur->right))
			) {
			printf("%d ", cur->data);
			pTop = PopLkStack(pTop, &TempNode);
			pre = cur;
		}
		else {
			if (cur->right != NULL)
				pTop = PushLkStack(pTop, cur->right);
			if (cur->left != NULL)
				pTop = PushLkStack(pTop, cur->left);
		}
	}
}


```

```c
// 非递归遍历 中序 无注释版
// 算法思路：
void NonRecvInorder (BitTree *root)
{
  LinkStack *pTop = NULL;
  BitTreeNode TempNode;
  
  pTop = InitLkStack();
  BitTree *p = root;
  
  while ( p!=NULL || !IsEmptyLkMazeStack(pTop) )
  {
    while (p)
    {
      pTop = PushLkStack(pTop, p);
      p = p->left;
    }
    if ( !IsEmptyLkMazeStack(pTop) )
    {
      printf("%d ", p->data.data);
      pTop = PopLkStack(pTop, &TempNode);
      p = &TempNode;
      p = p->right;
    }
  }
}

// 非递归遍历 先序 无注释版

```



#### 重构非递归遍历

```c
// 缺乏复用性
```

#### 求树的深度

```c
// 
int height = 0;
int TreeDepth_DLR (BitTree *pNode, int level)
{
  if (pNode)
  {
    ++level;
    if (level > height)
      height = level;
    printf("%d ", pNode->data);
    
    height = TreeDepth_DLR(pNode->left, level);
    height = TreeDepth_DLR(pNode->right, level);
  }
  return height;
}
```

## (五) 前序+中序 构建一颗二叉树

```c
BitTree* reConstructBinTree {
  int pre[], int startPre, int endPre,
  int in[], int startIn, int endIn
}
{
	if (startPre > endPre || startIn > endIn)
      return NULL;
  
    // 前序找到根结点
    BitTree *pNode = (BitTree*)malloc(sizeof(BitTree));
  	pNode->left = NULL;
    pNode->right = NULL;
    pNode->data = pre[startPre]; // 前根中的首元素一定是当前子树的根结点
  
    for (int i = startIn, i<=endIn; ++i)
    {
      if (in[i] == pre[startPre])
      {
        pNode->left = reConstructBinTree(
        	pre, startPre+1, startPre+i-startIn,
            in, startIn, i-1
        );
        pNode->right = reConstructBinTree(
        	pre, i-startIn+startPre+1, endPre,
          	in, i+1, endIn
        )
      }
    }
  
  return pNode;
}

// test 
int pre[] = { 1,2,4,7,3,5,6,9 };
int in[] = { 4,7,2,1,5,3,8,6 };
BitTree *rootNew;
rootNew = reConstructBinTree(pre, 0, 7, in, 0, 7);
```

## (六) 求一棵二叉树根到所有叶子结点的路径

```c
// 6 3 2
// 6 3 5 4 
// ...... 
BitTree * Paths[10] = { 0 };
void OutPath ()
{
  
}

// 求路径的函数
void LeavesPath (BitTree *tree, int level)
{
  if (tree == NULL)
    return;
  
  Paths[level] = tree;
  if ((tree->left == NULL) && (tree->right == NULL))
  {
    
  }
}
```

## (七) 判断两个二叉树是否相等

```c
// 前序遍历不行 必须 前序=前序 中序=中序
// 根据传入的数组数据,进行二叉链表的建立,然后再判断
```

## (八) 二叉树镜像

```c

```

## (九) AVL树(二叉搜索树)

```c
// 如果一颗搜索二叉树分布比较均衡，那么它的搜索次数，应该是logN
// 分布不均衡，最糟糕情况是退化成右孩子链的单链表
// 平衡二叉树的构建核心: 旋转算法
// 单向右旋：
// 单向左旋：
// 双向旋转：
// 双向旋转：
```

## (十) 234树

```c
是一种多路查找树
是一棵自下而上产生的树，和之前的树是刚好相反的
234是自平衡？
规则：
	1. 所有叶子节点拥有相同的深度
    2. 节点只能是 2 3 4个节点
    3. 所有节点至少包含一个元素

只有叶子节点放不下了，才会裂变到父亲节点，父亲节点放不下了，裂变到爷爷节点
234树 <-> 红黑树

其实，当你统计一个节点到不同叶子节点的黑节点数量的时候，本质上就是统计234树中的层数
换言之，红黑树，用黑来标记曾在234树中的层级
因此红黑树所谓的平衡，指的是黑节点的平衡

234 -> rbt
2子节点型(也就是1个元素节点的情况) -> 1个黑节点
3子节点型 -> 左倾或者右倾 其中子节点是变成红色
4子节点型 -> 中间的元素变成父节点，左右的变成子节点，并且都变成红色节点

```

## (十一) 红黑树

```c
规则：
	1. 根节点是黑色
	2. 节点只能是红色或黑色
	3. 每个叶子节点都是黑色的空节点
	4. 每个红必有2个子节点 都是红色的 (不能是2个相连的红色节点)
  	5. 从任一个节点到叶子节点的路径，黑色节点的数目都是相同的
  	
规则1，由上面的转换可知，转换后的子树的根节点都是 黑色的
规则4，由上面的转换可知，因为子树根节点是黑色的，子节点是红色的，所以最多是几个黑色相连，红色不可能相连
规则5，你知道为什么相同吗？因为234中转换时，一起的几个节点转换到rbt时，3中情况每种都只能有一个是黑节点，所以统计黑节点，其实就是层数，因此，rbt的平衡就是黑节点的平衡，本质就是234的层数一样

写红黑树的代码：234的逻辑，走红黑树的代码
```

## (十二) 哈夫曼树

```c

```

