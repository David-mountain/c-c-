# 学前提醒
## 关键点-存联系-也就是对于指针的处理
## 每个结点只有一个链域的链表称为单链表 
## 链表结构是由程序员管理的，它的建立有一定的运算方法
   ### 人为建立？尾插法 头插法

# 单链表 
#include <stdio.h>
#define TRUE 1
#define FALSE 0 
typedef struct node 
{
    int data;
    struct node *pNext;
}LinkListNode;
## 1.创建单链表(带头节点)
LinkListNode* InitLinkList (void)
{
    LinkListNode* pHead = NULL;
    pHead = (LinkListNode*)malloc(sizeof(LinkListNode));
    if ( pHead )
    {
        pHead->pNext = NULL;
    }
    return pHead;
}
## 2.求长度
int GetSizeLinkList (LinkListNode* pHead)
{
    int n = 0;
    while ( pHead->pNext )
    {
        n++;
        pHead = pHead->next;
    }
    return n;
}
## 3.取-给定位置的元素
LinkListNode* GetLinkListNode (LinkListNode* pHead, int pos)
{
    int j = 0;
    LinkListNode* p = pHead;
    if ( pos <= 0 )
    {
        return NULL;
    }

    while ( j<pos && p->pNext != NULL )
    {
        p = p->pNext;
        j++;
    }
    if ( pos == j )
    {
        return p;
    }
    else 
    {
        return NULL;
    }
}
## 4.查-给定元素的位置 
LinkListNode* LocateLinkList (LinkListNode* pHead, int objData)
{
    LinkListNode* p = pHead->pNext;

    while ( p != NULL && p->data != objData )
    {
        p = p->pNext;
    }
    return p;
}
## 5.建立-尾插法
LinkListNode* Create_Rear_LkList (ElemType arr[], int length)
{
    <!-- q指向最后一个元素的指针 -->
    LinkListNode* pHead, *p, *q;
    pHead = (LinkListNode*)malloc(sizeof(LinkListNode));
    q = pHead;
    int i = 0;

    for ( i=0; i<length; i++ )
    {
        p = (LinkListNode*)malloc(sizeof(LinkListNode));
        p->data = arr[i];
        q->pNext = p;
        q = p;
    }
    p->pNext = NULL;
    return pHead;
}
## 6.1建立-头插法1
LinkListNode* Create_Front1_LkList (ElemType arr[], int length)
{
    <!-- q指向第一个元素的指针 -->
    LinkListNode* pHead, *p, *q;
    pHead = (LinkListNode*)malloc(sizeof(LinkListNode));
    pHead->pNext = NULL;
    q = pHead->pNext;

    for ( i=length-1; i>=0; i-- )
    {
        p = (LinkListNode*)malloc(sizeof(LinkListNode));
        p->data = arr[i];
        p->pNext = q;
        pHead->pNext = p;
        q = pHead->pNext;
    }
    return pHead;
}
## 6.2建立-头插法2
LinkListNode* Create_Front2_LkList (ElemType arr[], int length)
{
    <!-- q指向第一个元素的指针  -->
    LinkListNode *pHead, *p, *q;
    q = NULL;
    int i = 0;

    for ( i=length-1; i>=0; i-- )
    {
        p = (LinkListNode*)malloc(sizeof(LinkListNode));
        p->data = arr[i];
        p->pNext = q;
        q = p;
    }
    pHead = (LinkListNode*)malloc(sizeof(LinkListNode));
    pHead->pNext = q;
}
## 6.3建立-头插法3
LinkListNode* Create_Front3_LkList (ElemType arr[], int length)
{
    LinkListNode *pHead, *p;
    pHead = (LinkListNode*)malloc(sizeof(LinkListNode));
    pHead->pNext = NULL;
    int i;

    for ( i=length-1; i>=0; i-- )
    {
        p = (LinkListNode*)malloc(sizeof(LinkListNode));
        p->data = arr[i];
        p->pNext = pHead->pNext;
        pHead->pNext = p;
    } 
}
## 7.插-指定位置之后(后插法)
void Insert_After_LkList (LinkListNode* ptr, ElemType x)
{
    LinkListNode* s = (LinkListNode*)malloc(sizeof(LinkListNode));
    s->data = x;
    s->pNext = ptr->pNext;
    ptr->pNext = s;
}
## 7.插-指定位置之前(前插法)
void Insert_Before_LkList (LinkListNode* pHead, LinkListNode* ptr, ElemType x)
{
    <!-- qPtr指向前一个元素的指针 -->
    LinkListNode *s, *qPtr;
    s = (LinkListNode*)malloc(sizeof(LinkListNode));
    s->data = x;
    qPtr = pHead;

    while ( qPtr->pNext != ptr )
    {
        qPtr = qPtr->pNext;
    }
    s->pNext = ptr;
    qPtr->pNext = s;
}
## 8.1 删-给定结点的后继结点
LinkListNode* Delete_After_LkList (LinkListNode* ptr)
{
    <!-- fptr指向被删除结点 -->
    LinkListNode* fptr = ptr->pNext;
    ptr->pNext = fptr->pNext;
    return fptr;
}
## 8.2 删-第i个结点 
LinkListNode* Delete_i_LkList (LinkListNode* pHead, int i)
{
    LinkListNode *ptr, *qPtr = NULL;
    ptr = GetLinkListNode(pHead, i-1);
    if ( ptr != NULL && ptr->pNext != NULL )
    {
        qPtr = Delete_After_LkList(ptr);
    }
    return qPtr;
}
## 9.遍历
void ShowLkList (LinkListNode* pHead)
{
    LinkListNode* p = pHead->pNext;
    <!-- 一定对比p->pNext p两个分别作为判断条件的区别 回顾之前js整理的 我记得一个是用，一个是不用-->
    while ( p != NULL )
    {
        printf(" %d", p->data);
        p = p->pNext;
    }
}


