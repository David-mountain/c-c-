# c语言知识

## (零) 此总结后面会有大型练手项目

## (一) 数据类型

### 1. 数据类型介绍

#### 1.1 内置类型

char short int long float double 

整型家族：

​	char(存的ascii值，也归类整型)

​		unsigned char  0~255

​		signed char      -128~127

​	short 

​		unsigned short [int]     // []表示可写可不写

​		signed short [int]

​	int 

​		unsigned int

​		signed int 

​	long 

​		unsigned long [int]

​		signed int [int]

浮点型家族：

​	float 

​	double 

#### 1.2 自定义类型(构造类型)

数组类型    int arr[length]

结构体类型 struct

枚举类型     enum

联合类型     union

指针类型

​	int* pi;

​	char* pc;

​	float* pf;

​	void* pv;

#### 1.3 c没有字符串类型

#### 1.4 类型的意义

i. 使用这个类型开辟内存空间的大小(大小决定了使用范围)

ii. 如何看待内存空间的视角

#### 1.5 空类型void

void 表示空类型(无类型)

通常应用于函数的返回类型，函数的参数，指针类型

​	void* pv;

​	void test () {}

​	void test (void) {} 或者不写void

### 2. 整型在内存中的存储

#### 2.1 原码、反码、补码

一个变量的创建要在内存中开辟空间的，空间的大小是根据不同的类型决定的。

int a = 20;  14 00 00 00 

int b = -10; f6  ff  ff  ff ？

你会好奇这些是如何得出来的？

因为计算机中不同的数据类型采用了不同的存储方式，有符号数有三种表示方法，即原码、反码、补码，注意整型和浮点数不是这样的存储方式。 

三种表示方法都是有 符号位和数值位两部分，符号位0正1负，而数值位三种方法则各不相同。

原码：直接将二进制按照正负数的形式翻译成二进制即可

反码：将原码的符号位不变，其他位依次取反即可

补码：反码+1即可？

注意：

无符号数：原码 反码 补码 一样

有符号数：原码 反码 补码 都不一样

```
int a = 20; // 4个字节 32bit 对整型而言，三者都是一样的
00000000 00000000 00000000 00010100 原码  16进制-0x00 00 00 14
00000000 00000000 00000000 00010100 反码
00000000 00000000 00000000 00010100 补码

int b = -10;
10000000 00000000 00000000 00001010 原码
11111111 11111111 11111111 11110101 反码 
11111111 11111111 11111111 11110110 补码  16进制-0xff ff ff f6 (快捷1111->15)

```

####  2.1为什么会有反码 补码这些个万一呢？

反码忘记了，只记得补码了

i). 对于整型而言，数据存放在内存中，是以补码的形式的 ？

因为在计算机系统中，数值一律用补码来表示和存储。原因是使用补码，可以将符号位和数值域统一处理，

同时，加法和减法也可以统一处理(cpu只有加法器)，此外，补码和原码相互转换，其运算过程是相同的，

不需要额外的硬件电路。

ii). 只有加法，那 + - * / 呢？ 

```
没有补码错误案例：
1-1 -> 1+(-1)
1的原码：  00000000 00000000 00000000 00000001
-1的原码： 10000000 00000000 00000000 00000001
相加：     10000000 00000000 00000000 00000010
结果：    -2 (不对)

科学家想出来了补码来解决。
1的补码：  00000000 00000000 00000000 00000001
-1的补码： 11111111 11111111 11111111 11111111 
相加：     10000000 00000000 00000000 00000000 0
结果：     0 (正确)
因为我是int型，32位，最高位1被干掉了，剩下全是0了。

这是减法的过程，也是补码的过程。
```

### 3. 大小端字节序列介绍及判断

#### 3.1 引出大小端

我们发现之前int a = 20;的16进制数，应该是0x00 00 00 14，但是在vscode内存显示中是反过来的，是14 00 00 00 这是为什么呢？而且也不是完全的数字相反？这就涉及到大小端了。

首先我们要明确的是不要以为vs这里是16进制的数，就以为内存中存储的是16进制的数，内存中始终都是存放的0、1数字，这里转成16进制只是为了方便程序员看。

另外一个需要明确的点是，数据在内存中的存储顺序，是以字节的顺序，不是二进制的顺序。比如0x 11 22 33 44，这里11是一个字节，是以字节为基本存储单位的。

还有一个点，内存空间是有编号的，编号有大有小的，地址线，编号小的叫低地址，大的叫高地址。

大端(存储)模式：指数据的低位保存在地址的高地址中，而数据的高位，保存在内存的低地址中。(低高大)

小端(存储)模式：指数据的低位保存在地址的低地址中，而数据的高位，保存在内存的高地址中。(低低小)

```
0x11(高位) 22 33 44(低位)   16进制
 11(低地址)22 33 44(高地址)  内存中的显示(转成16进制是为了方便看) 大端存储模式 
 44(低地址)33 22 11(高地址)  小端存储模式 
 
 vs内存显示：左(低)->右(高)
 16进制数字：左(高)->右(低)
```

#### 3.2 思考为什么有大端小端呢？

因为在计算机系统的，我们是以字节为单位的，每个地址单元都对应一个字节。

一个字节为8bit,C语言中还有16bit的short，32bit的long(看具体的编译器)

对于位数大于8位的处理器，例如16位或32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个或者多个字节的安排问题，因此就出现了大端存储模式和小端存储模式。

```
例：一个16bit的short型x,在内存中的地址为0x0010，x的值为0x1122
0x 11(高位) 22(低位)
 00(低地址，高位)10(高地址，低位) 若按此地址存，大端模式
 00(低地址，低位)10(高地址，高位) 若按此地址存，小端模式
 
 采用小端模式： 常用的x86结构、ARM DSP
 采用大端模式： KELL CS1
 有些ARM处理器可以自己选择大端或小端模式。
```

#### 3.3 百度笔试题 大小端判断

请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。10分

```
算法思路1：
int a = 20;
0x 00 00 00 14(低位)
 14(高位地址) 00 00 00  -小端
 00(低位地址) 00 00 00  -大端 
注意：内存中是以字节为单位的。
所以，我们想到了一个思路，只需要找出第一个字节，看是否是00即可，然后我们思考如何访问一个字节呢？想到了char*，访问一个整型数据的第一个字节即可。

答案：最好封装成函数
#include <stdio.h>
int check_sys1 ()
{
  int a = 1; // 设置1方便
  char* p = (char*)&a;
  if ( *p == 1 )
  	return 1;
  else 
  	return 0;
}
// 简化版
int check_sys2 ()
{
  int a = 1;
  return (*char( *)&a);
}
// 测试
int main ()
{
  int ret = check_sys();
  if ( ret == 1 )
  	printf("小端\n");
  else 
  	printf("大端\n");
}
```

拓展指针类型的意义：

1. 指针类型决定了指针解引用操作符能访问几个字节  

   char* p ,* p可以访问1个字节，int* *p, *p可以访问4个字节

2. 指针类型决定了指针+1 -1时候的步长，可以加减几个字节。

   char* p; p+1跳过1个字节， int *p; p+1跳过4个字节

   ​

### 4. 浮点数在内存中的存储解析

#### 4.1 浮点数介绍

```c
float 
double 
long double 
float f1 = 3.1415f;
double d1 = 1E10;  // 1*10的10次方
printf("%f \n", f1);
printf("%lf \n", d1); 

浮点数取值范围：float.h中有定义
数据类型的取值范围：limits.h中有定义
```

#### 4.2 练习题

```c
int main ()
{
  int n = 9;
  float* pFloat = (float*)&n;
  printf("n的值为：%d \n", n);             // 9
  printf("*pFloat的值为：%f \n", *pFloat); // 0.000000
  
  *pFloat = 9.0;
  printf("num的值为：%d \n", n);           // 1094567616
  printf("*pFloat的值为：%f \n", *pFloat); // 9.000000
}
得出结论：整型和浮点型在内存中的存储方式不一样的。

解释浮点数在计算机内部的表示方法：
根据国际标配IEEE(电气和电子工程协会)754，任意一个二进制浮点数V可以表示成下面的形式： (-1)^S * M * 2^E 。
	(-1)^s表示符号位，当s=0，V为正数，当s=1，V为负数
	M表示有效数字，大于等于1，小于2  
	2^E表示指数位
举例1：
十进制   5.0
二进制 101.0
(-1)^0 * 1.01 * 2^2
(-1)^S *  M   * 2^E 
S = 0，M = 1.01，E = 2
举例2：
十进制   -5.0
二进制 -101.0
(-1)^1 * 1.01 * 2^2
(-1)^S *  M   * 2^E 
S = 1，M = 1.01，E = 2
  
IEEE规定：对于32位的浮点数，最高的1位是符号位S,接着的8位是指数E，剩下的23位有效数字M。1+8+23
注意：E是一个无符号整数，但是E是有可能是负数的。8位，0-255。
解决负数的方案是：存入内存时E的真实值必须再加上一个中间值，对于8位的E，这个中间数是127。如果E = -1；存入内存的时候 +127 = 126(这是存入内存的最终值)。
```

```c
int main ()
{
  float f = 5.5; // 内存中存的值是什么？
}
分析：
(-1)^0 * 1.011 * 2^2 
S = 0
M = 1.011 
E = 2
32bit: 0 10000001 01100000000000000000000
16进制：0x40 b0 00 00 
10000001? 
  0000 0010  +2
  0111 1111  127(规则要求+127)
  1000 0001  129(最终结果)
二进制快速转16进制？
	0100 0000 1011 0000...0000
  0100->2^2=4(16)
  1011->2^3+2^1+2^0=11->b(16)
  得：40 b0 00 00 
  
因为我们是小端模式，所以最后内存显示是：00 00 0b 40
```

```c
int main () 待整理！
{
  int n = 9;
    // 0000000...1001 9的补码 
    这里强制转成浮点数 上面的补码就需要重新划分哈
    0(1位) 0000000(8位) 0000...1001(23位)
    如何还原呢？ E这里8位全是0 取出的第二个规则 
    (-1)^0 * 0.000.。。1001 * 2^-126 ???看看规则 
    这就是正0 无限接近0的意思 
    float* pFloat = (float *)&n;
    printf("n的值为：%d\n", n);
    printf("*pFloat的值为：%f\n", *pFloat);

    *pFloat = 9.0;
    1001.0 
    1.001 * 2^3 
    (-1)^0 * 1.001 * 2^3 
    0 10000010 00100..0   9.0存在内存的形式 
    这里打印n 需要从整型的角度看待这个存在内存中的值了
    0 10000010 00100..0 转成十进制 1091567616 
    printf("num的值为：%d\n", n);
    printf("*pFloat的值为：%f\n", *pFloat);
    return 0;
}
```

#### 4.3 取浮点数

上面都是存入浮点数类型，取出浮点数还有一些特殊情况。

指数E从内存中取出还可以再分成三种情况：

1. E不全为0或不全为1
2. E全为0
3. E全为1

### 5. 代码题

```c
int main ()
{
  char a = -1;
  signed char b = -1;
  unsigned char c = -1;
  printf("a=%d,b=%d,c=%d", a, b, c);
}
-1 -1 255 
分析：
char a = -1;
	10000000 00000000 00000000 00000001 原码
	11111111 11111111 11111111 11111110 反码
	11111111 11111111 11111111 11111111 补码
	11111111 char型 1个字节只能保存8位 截取8位
printf("a=%d,b=%d,c=%d", a, b, c);
	a 打印整型%d,然而这里是字符型，所以需要类型提升。
	11111111最高位的1当成是符号位，前面补1，至共32位，这是补码的。
	然后拿着补码倒回去算原码，-1。口诀：-1的补码才全是1！！
	b 同上，不要被signed吓到，可以省略的。
	c 无符号数，高位直接补0，0000...11111111 ->255 口诀：8个1是255
```

```c
 int main ()
{
  char a = -128;
  printf("%u\n", a);
}
分析：
首先强调自己明白了一个点，和上面的无符号，unsigned char和这里(signed) char，这个的不同直接决定了后面是直接补充0还是看最高位的数来决定。
10000000 00000000 00000000 10000000 原码
11111111 11111111 11111111 01111111 反码 
11111111 11111111 11111111 10000000 补码 
10000000 char型 发生截断 
这里打印%u无符号整数，需要类型提升，注意这里是char a，不是unsgined char a，所以这里需要看最高位的，来决定补充0还是1，这里是1，前面补充1，1111111...10000000，这里补码整型提升后还是补码，又因为这里是打印无符号数的，原反补码都是一样的。所以直接将这个二进制转成十进制即可。

int main ()
{
  char a = 128;
  printf("%u\n", a);	
}
```

```
char类型能表示的数值范围：
1个字节，8个bit位。

--------------unsigned char:
当成补码看  数值
0000 0000  0
0000 0001  1
...
1000 0000  128 *
1000 0001  129
...
111111111  255

--------------signed char:
当成补码看  数值
0000 0000  0
0000 0001  1
...
0111 1111  127 
1000 0000  -128 *
1000 0001  -127
...
111111111  -1 (反码1111 1110 -> 原码1000 0001)

--------------分析-128来源？
对于有符号位整数，二进制的最高位表示正负，不表示数值，最高位是0时表示正数，为1时表示负数，这样一来，能表示数值的就剩下(n-1)位了。
比如：char a = -1; 二进制表示就是1000 0001，1表示0000 0001.
所以，signed char 型出去符号位剩下的7位最大是 1111 111 = 127；加上符号位是：0 1111111 = 127; 那范围也应该是-127~127阿，哪里来的-128？

这里补充一个知识，反码的由来，从减法中来的：？
1-1=？计算机只会做加法，会转换成1+(-1)
0000 0001  1  (原码)
1000 0001  -1 (原码)
0000 0010  -2(相加结果不对)
为了避免减法运算错误，发明了反码。
规定：正数的反码原码相同，负数的反码是原码除了符号位，其余都取反。
0000 0001  1  (反码)
1111 1110  -1 (反码)
1111 1111  反码 -> 原码 1000 0000 = -0 (正确) 

补码的由来，解决重复的0：？
虽然反码解决了相减的问题，却又带来了另外一个问题，-0，既然0000 0000表示0，那么就没有-0的必要了，出现了+0=-0=0，其实一个0就够了，为了避免两个0的问题，科学家又发明了补码。
规定：整数的补码是其本身，负数的补码为其反码+1。
0000 0001  1的补码
1111 1111  -1的补码
1 0000 0000 结果是9位，由于是char型，8个bit，保留8位，最高位1被丢弃，结果是0.
-0 原码：1000 0000 
   补码：1000 0000 0 由于char是八位，取低八位
   补码：0000 0000
+0 原码：0000 0000
   补码：0000 0000 
虽然补码都是相同的，但是有两个0，既然有两个0，况且0既不是整正数，又不是负数，用原码 0000 0000 表示就行了，这样一来，有符号的char，原码都用来表示-127~127之间的数。唯独原码1000 000没有用。
其实你自己用排列组合也可以算出来，0??? ????，也能表示128个数，0~127刚刚好。
1??? ????，也能表示128个数。总共signed char 有256个数。最后谈论剩下的那个1000 0000.为什么-0可以表示-128？

如果不限制为char型，(即不要限定为8位)，再来看，-128的原码：1 1000 0000，9位。
最高符号位，再算它的反码：1 0111 1111，进而，补码为：1 1000 0000，这是-128的补码。
128的原码和-0(1000 0000)的原码是不相同的，但是在char中，是可以用1000 000表示-128的，关键在于char是8位，它把-128的最高位符号位1丢弃了，截断后-128的原码为 1000 000 和-0的原码相同，也就是说 1000 0000 和-128丢弃最高位之后余下的8位相同，所以才可以用-0表示-128，这样，当初剩余的-0(10000 0000)，被拿来表示截断后的-128，因为即使截断后的-128和char型范围的其他数(-127~127)运算也不会影响结果，所以才敢这样表示-128.比如：
-128+(-1) = ?
1000 0000    丢弃最高位的-128
 111 1111    -1
10111 1111   char取八位，结果不正确，没关系，结果-129本来就超出char型了，当然不能表示

-128+127 = ？
1000 0000   -128
0111 1111
1111 1111   -1(正确)

char a = -128;
printf("%d", a); -128 记死把这个！最高位丢弃了，输出时应该是1000 000的原码的十进制数-0，但为什么能输出-128呢？以后自己研究。
char a = -129;
printf("%d", a); -129在补码为10 0111 1111 只取后八位存储，即0111 1111，这个值刚好是127。

unsigned char a = 1;
if ( 1 > a )
	printf("大于");
else 
	printf("小于");
结果：小于。
a是unsigned无符号，它的八位都用来存储数值，没有符号位，编译器把-1转换成补码为1111 1111，(1000 00001 -> 1111 1110 -> 1111 1111)，但是由于是无符号位，计算机会把 1111 1111，当作是无符号来对待，自然就是 2^8-1=255了，所以原代码是 if( 1 > 255 ) 肯定就是小于。
```

这里要插入一幅图，数值范围的圆图！

```c
int main ()
{
	int i = -20;
  	unsigned int j = 10;
  	printf("%d\n", i+j);
}
-10 
 10000000 00000000 00000000 00010100  -20原码 
 11111111 11111111 11111111 11101011     反码
 11111111 11111111 11111111 11101100     补码
 00000000 00000000 00000000 00001010   10原码反码补码
 11111111 11111111 11111111 11110110   两者补码相加，得结果
 
 11111111 11111111 11111111 11110101   得结果的反码
 10000000 00000000 00000000 00001010   得结果得原码 -10
```

```c
int main ()
{
	unsigned int i;
  	for ( i=9; i>=0; i-- )
    {
      printf("%u\n", i);
    }
}
死循环
我自己还傻傻去算原码反码补码，没有认真读完整个程序就下手了。
因为i是一个无符号整数，不可能是负数阿，取值范围是0~255，就一直满足for循环的判断了，形成了死循环了。
```

```c
int main ()
{
  char a[10000];
  int i;
  for ( i=0; i<10000; i++ )
  {
    a[i] = -1 - i;
  }
  printf("%d", strlen(a));
}
答案未知
和我分析的差不多，但是我还差一步。
知识补充：strlen结束标志：\0
当你以为是随机值的时候，发现本题的重点不是在最后查，而是在赋值阶段。
char型，取值范围-128~127，这里的-1~-10000不可能完全存入的，超出的都会转成这个取值范围的值，比如：
-1-128 = -129 ->
1000 0000 1000 0001  -129原码
1111 1111 0111 1110      反码
1111 1111 0111 1111      补码 
因为char型，保留8位，0111 1111(作为补码)。
最高位是0，计算机认为是正数，是127.
圈圈图(-128 逆时针+1就是 127)
所以，数组里面存放的都是这些值。代码非法访问内存了，这只能作为练习题看看。
```

```c
unsigned char i = 0;
int main ()
{
  for ( i=0; i<255; i++ )
  {
    printf("hello world \n");
  }
}
死循环 
因为是无符号数，取值范围是0~255，这里判断条件是i<255，只有大于255才能终止循环。
```

总结：这几个练习题，其中关于死循环的几个题目，我们可以得出：unsigned 和 char 之类，这几个数据类型导致了不满足for终止循环的条件，从而产生bug。

### 6. 常见进制数

```c
1111(2) -> 15(10) -> f(16)
  
```

## (二) 分支和循环

## (三) 操作符

### 1. 算术操作符

```c
int a = 5 / 2;
printf("%d \n", a);  // 2 不是2.5 思考是二进制位丢弃？
除法，如果两边的都是整数，得整数
     如果两边的都是小数，或被除数除数一定要有一个小数，才能得小数(涉及数据类型的隐式转换规则)

int a = 5 % 2; // 1
%：两边的操作数必须是整数
```

### 2. 移位操作符(移动的是二进制位)

```c
！警告：对于移位运算符，不要移动负数位，这是未标准化的。
例：int num = 10;
    num >> -1;  // error

<< 左移操作符:
   左边抛弃、右边补0
   int a = 5;
   int b = a << 1;  // ?
   00000000 00000000 00000000 00000101 5的原码
   00000000 00000000 00000000 00000101(0) 8+2=10的原码
   简记：左移一位，相当于*2.
   
>> 右移操作符
	int a = 16;
	int b = a >> 1;  // ?
	0000 0000 0000 0000 0000 0000 0001 0000  16的原码
	0000 0000 0000 0000 0000 0000 0000 1000 8的原码
	右移一位，相当于/2
     
    负数测试：
    1. 算术右移
    	整数最高位是0，0正1负
    	向右移动，右边的丢弃，然后左边最高位保留符号位
    2. 逻辑右移
    	右边丢弃，左边补0
    int a = -1;
	int b = a >> 1;  // -1 我们见到的通常是算术右移

如果要移位，首先要找到它的补码。
正数- 原反补一样
负数- 原码符号位不变，其他取反(得补码)，再+1
```

### 3. 位操作符(二进制基础上)

```c
& | ^
注：操作数必须是整数。
& 按位与
	有1个是0就是0，两个都是1才是1
| 按位或
	有1个是1就是1，两个都是0才是0
^ 按位异或
	相同为0，相异为1(同0异1)
	
例1：&
int a = 3;
int b = 5;
int c = a&b;
解析：
00000000 00000000 00000000 0000 0011 3
00000000 00000000 00000000 0000 0101 5
00000000 00000000 00000000 0000 0001 1 结果

例2：|
int a = 3;
int b = 5;
int c = a^b;
解析：
00000000 00000000 00000000 0000 0011 3
00000000 00000000 00000000 0000 0101 5
00000000 00000000 00000000 0000 0110 6 结果

面试题：
不能创建临时变量，实现两个数的交换
方法一：加减法
int a = 5;
int b = 3;
a = a + b;  // a存放两个数的和 b存放b
b = a - b;  // b存放a (两个数的和a)-b
a = a - b;  // a存放b (两个数的和a)-a的值(b中)
注：相加不能超过int型，所表示的范围，有缺陷，可能会溢出，这种方法就不好了。

方法二：异或的方法 ^
int a = 5;
int b = 3;
a = a^b;
b = a^b;
a = a^b;
printf(""a= %d b= %d\n", a, b"); // a=3 b=5

后面再来研究这个，半加法！！！及其相关性质
```

面试题1: 求一个整数存储在内存中的二进制，其中1的个数

```c
算法思路：十进制转成二进制，过程中判断是否有1.
补充：想得到123每个位置的数字？
	十进制是，不断%10,然后/10
  	二进制是，不断%2，然后/2
  
方法一： (有缺陷)
int main ()
{
  int num = 10;
  int count = 0;
  scanf("%d", &num);
  
  while ( num )
  {
    if ( num%2 == 1 )
      count++;
    num /= 2;
  }
  printf("二进制中1的个数= %d \n", count);
}
缺陷：负数有问题
  
方法二：右移操作符
int main ()
{
  int num = 0;
  int count = 0;
  scanf("%d", &num);
  
  int i = 0;
  for ( i=0; i<32; i++ ) ？能直接遍历32？先转二进制？
  {
    if ( 1 == (num >> i) & 1 )
      count++;
  }
}
不太对，后期再看看？？

方法三：后期添加
```

###  4. 赋值操作符

= += -= /= *= >>= &= |=

### 5. 单目操作符

```c
a+b + 双目操作符
!     逻辑反操作
-     负值
+     正值
&     取地址
sizeof 操作数的类型长度(字节为单位)
~	  对一个数的二进制按位取反
--
++    前置++ 后置++
*     间接访问操作符
(类型)强制类型转换

注：sizeof(类型) 后面是类型的话，不能省略括号。

例1：
short s = 0;
int a = 10;
printf("%d\n", sizeof(s = a + 5)); // 2
printf("%d\n", s); // 0 上面a+5不参与运算，不会改变s值
编译器报错的，理论分析。

~ 按2进制位取反
例2：
int a = 0;
printf("%d \n", ~a); // -1
分析：
00000000 00000000 00000000 00000000 0补码

11111111 11111111 11111111 11111111 ~0补码
11111111 11111111 11111111 11111110 反码
10000000 00000000 00000000 00000001 原码 ->-1
  
例3：
int a = 11;
a = a | (1 << 2);
printf("%d \n", a);
分析：
1011 a补码
0001 -> 100 即1*2*2=4
0100 4补码
1111 逻辑或得 15
  
例4：
int a = 10;
printf("%d \n", ++a); // 11
printf("%d \n", a++); // 11

例5：
int a = 3.14; // 这种情况编译器会报警告，3.14这里默认是double类型，赋值给int型，可能会丢失精度
int a = (int)3.14;


```

### 6. 关系操作符

### 7. 逻辑操作符(位操作符是二进制)

```c
&& || !
&&、|| 和 ！的优先级: ! > && > ||
  
例1：
int a = 3;
int b = 5;
int c = a && b;
printf("%d \n", c); // 1 编译器报了个瞎波浪线

例2：
int a = 0;
int b = 5;
int c = a && b;
printf("%d \n", c); // 0

例3：
int a = 0;
int b = 5;
int c = a || b;
printf("%d \n", c); // 1

例4：
int a = 0;
int b = 0;
int c = a || b;
printf("%d\n", c); // 0

例5：
int i = 0,
    a = 0,
    b = 2,
    c = 3,
    d = 4;
i = a++ && ++b && d++;
printf("%d %d %d %d", a, b, c, d);
// 1 3 3 5 我得答案。错误
// 1 2 3 4 问题在于a++，&&遇到是假，后面都不会执行了，这是第一个就是假。

例6：
int i = 0,
    a = 1, // 改成1了
    b = 2,
    c = 3,
    d = 4;
i = a++ && ++b && d++;
printf("%d %d %d %d", a, b, c, d); 
// 2 3 3 5

例7：
int i = 0,
    a = 0,
    b = 2,
    c = 3,
    d = 4;
i = a++ || ++b || d++;
printf("%d %d %d %d", a, b, c, d);
// 1 3 3 4 ||遇到是真，后面都不会执行了，这是第一个就是真。

例8：
int i = 0,
    a = 1,
    b = 2,
    c = 3,
    d = 4;
i = a++ || ++b || d++;
printf("%d %d %d %d", a, b, c, d);
// 2 2 3 4 依然要记住：||遇到真后面就不执行了
```

### 8. 条件操作符

```c
exp1 ? exp2 : exp3;

if ( a>5 )
  b = 3;
else 
  b = -3;

->
b = (a>5 ? 3 : -3);  
```

### 9. 逗号操作符

```c
// 用逗号隔开得多个表达式
// 自左向右一次执行
// 整个表示得结果是 最后一个表示式的结果

例1：
int a = 1;
int b = 2;
int c = ( a>b, a=b+10, a, b=a+1 ); 
printf("%d \n", c); // 13 

例2：
if ( a=b+1, c=a/2, d>0 )
{
  
}

例3：
a = get_val();
count_val(a);
while ( a>0 )
{
  a = get_val();
  count_val(a);
}
改写：不推荐这样写
whie ( 
  a=get_val(),
  count_val(a),
  a>0
)
{
  
}
```



### 10. 下标引用、函数调用和结构成员

```c
1. []下标引用操作符
	操作数：数组名 + 索引值
	int arr[10];
	arr[9] = 10; // []的两个操作数是arr和9 

2. ()函数调用操作符
	get_max(a, b);

3. . 访问一个结构的成员
	.结构体.成员名
	->结构体指针->成员名
	struct Stu 
    {
      char name[20];
      int age;
      char id[20];
    };
	int main ()
    {
      struct Stu s1 = {"张三", 20, "2341"};
      printf("%s \n", s1.name);
      
      struct Stu *ps = &s1;
      printf("%s \n", (*ps).name);
      printf("%s \n", ps->name);
    }
```

### 11. 表达式求值

``` c
表达式求值的顺序一部分是由操作符的优先级和结合性决定。
同样，有些表达式的操作数在求值的过程中可能需要转换为其他数据类型。

为了获得精度，表达式中的字符和短整型操作数在使用之前 被转换为普通整型，这种转换称为整型提升。

例1：！！！
char a, b, c;
a = b + c;
// 说明：b和c值被提升为普通类型，然后执行加法运算，加法完成后，结果将被阶段，再存于a中

// 如何进行整型(整体)提升呢？
// 按照变量的数据类型的符号位来提升
char c = -1;
1111 1111 c补码
// 因为char是有符号的char，所以整型提升的时候，高位补充符号位，即1
11111111 11111111 11111111 11111111 提升后的补码

char a = 3;
char b = 127;
char c = a + b;
printf("%d \n", c);
分析：
0000 0011 a补码
0111 1111 b补码 
00000000 00000000 00000000 00000011 a补码
00000000 00000000 00000000 01111111 b补码
00000000 00000000 00000000 10000010 相加
因为c是char型，只要八位 10000010
又因为这里打印十进制%d，需要前面补充数？
前面补充1或者0 根据符号位来补
11111111 11111111 11111111 10000010 补后补码
11111111 11111111 11111111 10000001 反码
10000000 00000000 00000000 01111110 原码
-126 (64+32+16+8+4+2)
  
如果是无符号数，直接前面补充0，这里是说的打印时候吗？？？

整型提升的意义：
表达式得整型运算在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度。一般就是int的字节长度，同时也是CPU的通用寄存器的长度。因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。
通用CPU是难以直接实现两个8比特字节直接相加运算，(虽然机器指令中可能有这种字节相加指令)。所以，表达式各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int,然后才能送入CPU去执行运算。

例2：
char a = 0xb6;
short b = 0xb600;
int c = 0xb6000000;

if ( a == 0xb6 ) // 前面会补0 不相等
  printf("a1 \n");
if ( a == 0xb600 ) // 不相等
  printf("a2 \n");
if ( a == 0xb6000000 ) // 相等 但是编译器？？
  printf("a3 \n");

例3：
char c = 1;
printf("%u \n", sizeof(c)); // 1
printf("%u \n", sizeof(+c)); // 4 char型c只要参与表达式运算，就会发生整型提升，所以sizeof是4个字节 -+c
printf("%u \n", sizeof(!c)); // 1


算术转换
也是一种隐式转换。
隐式转换：整型提升 算术转换
描述：如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数转换为另一个操作数。否则操作是无法进行的。
long double 
double 
float 
unsigned long int 
long int 
unsigned int 
int 
(下 转 上)
注：如果某个操作数的类型再上面这个列表中排名较低，首先要转换为另外一个操作数的类型后再运算。但是算术转换要合理，不然会有潜在风险。

小结：复杂表达式的求值又三个影响的因素：
	1. 操作符的优先级
	2. 操作符的结合性(NA(无结合性) LR RL)
	3. 是否控制求值顺序
   
问题表达式：
例1：
a*b + c*d + e*f
分析：
表达式的求值部分由操作符的优先级决定。
在计算的时候，由于比+的优先级高，只能保证*的计算比+早，但是优先级并不能决定第三个*比第一个+早执行。
我们无法让它有一个唯一的计算路径，不同的编译器可能不同的。
表达式的计算机顺序可能是：
a*b 
c*d 
a*b + c*d 
e*f 
a*b + c*d + e*f 
或者：
a*b 
c*d 
e*f 

例2：
c + --c;
分析：
操作符的优先级只能决定自减--的运算在+的运算的前面。
但是我们并没有办法得知，+操作符的左操作数的获取在右操作数之前还是之后求值，所以结果是不可预测的，是有歧义的。
如果c是1，先左边c赋值成c,然后再执行--c 得0 1+0=1 。
如果先计算--c 0 然后0赋值给左边的c 得0+0=0 。
在于+操作符的左操作数的获取在右操作数之前还是之后求值，所以结果是不可预测的。

例3：
非法表达式：
int main ()
{
    int i = 10;
    i = i-- - --i * ( i = -3 ) * i++ + ++i;
    printf("i= %d\n", i);
    return 0;
}
值      编译器
-128  Tandy 6000...
-95   Think..
-86   IBM...
-63   gcc 
...
21    Turbo C/C++..
...
不同编译器都不一样。
因为计算的顺序不一致。导致的。

例4：
int fun ()
{
    static int count = 1;
    return ++count;
}
int main ()
{
    int answer;
    answer = fun() = fun() * fun();
    printf("%d\n", answer); ?
    return 0;
}
让你先算乘法还是减法是可以的，但是3个fun()谁先执行？
2-3*4 
4-2*3 
计算顺序不是唯一的。
函数的调用先后顺序无法通过操作符的优先级确定。

例5：
int main ()
{
    int i = 1;
    int ret = (++i) + (++i) + (++i);
    printf("%d\n", ret);
    printf("%d\n", i);
    return 0;
}
尝试在linux 环境gcc编译器，vs2013环境下都执行，看结果 
视频编译器 12 
linxu     10 
同样的代码产生了不同的结果，这是为什么？
简单看一下汇编代码，就可以分析清楚。
这段代码中的第一个+在执行的时候，第三个++是否执行，这是不确定的，因为依靠操作符的优先级和结合性是无法决定第一个+和第三个前置++的先后顺序。

总结：我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那么这个表达式就是有问题的。
```

## (四) 指针

### 1. 初级指针

#### 1.1 指针是什么

在计算机科学中，指针是编程语言中的一个对象，它的值直接指向存在电脑寄存器中的一个地方的值。

由于通过地址能找到所需要的变量单元，可以说，地址指向该变量单元。

因此，将地址形象化的称为指针，意思是通过它能找到这个地址所在的内存单元。

说指针，先说内存，思考是如何找到地址的，地址具体又是什么呢？

为了合理利用内存，把内存划分成一个一个小的单元，然后逐一编号，这个编号就被称为地址。

那编号是如何产生的呢？

电脑有地址线(多少位机决定的)，通电能产生电信号，电信号转换成数字信号。电信号产生的二进制序列，这个二进制序列就作为一个内存单元的编号。

那一个内存单元多大最好呢？

最好是一个字节，比较合适的。比特视频详细计算过的。

```c
// 如何编址?
// 对于32位的机器，假设有32根地址线，假设每根地址线在寻址时产生的一个电信号-正电/负电 1/0
// 那么32根地址线产生的地址就会是下面这些：
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000001
  ...
11111111 11111111 11111111 11111111
// 总共是：2^32次方个地址
// 每个地址表示一个字节，那么我们可以给
// (
//  2^32Byte == 2^32/1024kb == 2^32/1024/1024mb == 2^32/1024/1024/1024gb == 4G
// ) 的空闲地址编址。
// 64位机同理。
  
// 从这里可以得出：
// 1. 32位的机器上，地址是32个0或1组成的二进制序列，地址，我们用4个字节即可存储。也就是一个指针变量的大小就是4个字节。64位机则是8个字节。
// 2. 指针是用来存放地址的，地址是唯一标识一块地址空间的。指针的大小在32位机是4个字节，64位机是8个字节。
// 测试
printf("%d\n", sizeof(char *));
printf("%d\n", sizeof(short *));
printf("%d\n", sizeof(int *));
printf("%d\n", sizeof(double *));
// 都是4，因为视频中是32位机，这和数据类型无关的。提出一个问题，指针既然都是4个字节，为什么还要区分类型呢？int* char*呢？
```

#### 1.2 指针和指针类型

```c
int a = 0x11223344; // 不会溢出哈
int *pa = &a;
char *pc = &a;
printf("%p\n", pa); 一样
printf("%p\n", pc); 一样
你就会思考地址打印都一样，那类型有什么用呢？

int a = 0x11223344;
int *pa = &a;
*pa = 0; 把地址赋值成0 请去vs查看内存变化
0x00EFF880 44 33 22 11 
0x00EFF880 00 00 00 00

int a = 0x11223344;
char *pa = &a;
*pc = 0; 把地址赋值成0 请去vs查看内存变化
0x00EFF880 44 33 22 11 
0x00EFF880 00 33 22 11
  
对比上面两处赋值0后的内存数据，发现问题了吗？
int型指针，解引用赋值为0，4个字节全部变成了0，
char型指针，解引用赋值为0，1个字节变成了0.
这便是不同的类型的指针，可以访问的内存不同。
char型指针可以访问1个字节，int型指针可以访问4个字节，double型指针可以访问8个字节。
即：指针的类型决定了，对指针解引用的时候有多大的权限，能操作几个字节。
```

指针类型的另外一个意义：指针+整数

```c
int a = 0x11223344;
int *pa = &a;
char *pc = &a;
printf("%p\n", pa);   0095FB58
printf("%p\n", pa+1); 0095FB5C  +4

printf("%p\n", pc);   0095FB58
printf("%p\n", pc+1); 0095FB59  +1

即：指针类型决定了，指针走一步多远，指针的步长。

案例：
int arr[10] = { 0 };
int *p = arr; // arr首元素的地址
int i = 0;
for ( i=0; i<10; i++ )
{
  *(p + i) = 1;
}
结果全部赋值成了1.
若 char *p = arr; 则是修改了10个字节成1.看内存。这里总共是40个字节。
```

#### 1.3 野指针

```c
指针指向的位置是不可知的，随机的，不正确的，没有明确限制的。

野指针原因：
1. 指针未初始化
int main ()
{
	int a; // 局部变量不初始化，默认随机值
  	int *p;// 布局指针不初始化，默认随机值
  	*p = 20;
}
2. 指针越界访问
int main ()
{
  int arr[10] = { 0 };
  int *p = arr;
  int i = 0;
  for ( i=0; i<=11; i++ )
  {
    // 当指针指向的范围超出了数组arr下标范围，即野指针
    *(p++) = i;
  }
}
3. 弹出局部地址
int* test ()
{
  int a = 10;
  return &a;
}
int main ()
{
  int *p = test(); // 地址虽然返回给我了，但是test函数执行完毕后，这个地址已经还给OS了，此时再去访问就是非法访问了，即野指针
  *p = 20;
}

如何规避野指针？
1. 指针一定初始化
2. 小心指针越界
3. 指针指向空间释放即置 NULL
4. 指针使用之前检查有效性 
```

临时补充一个点： * ++(前后)优先级

```c
// 前缀++和*优先级相同
// 后缀++比前缀++优先级低

int arr[5] = { 1,3,5,7,9 };
int *p = arr;
printf("%d ", *++p); // 3
printf("%d ", *p++); // 1 第一次，我就是傻B了，把后++搞错了，打印肯定先输出值的，然后再+1.
printf("%d ", (*p)++); // 1
printf("%d ", *(p++); // 1 我做错了，我做成了3，应该是本次表达式p++之后并没有更新 等同于*p++
printf("%d ", ++*p); // 2 
```

#### 1.4 指针运算

1. 指针+-整数

```c
案例1：打印数组
int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
int sz = sizeof(arr) / sizeof(arr[0]);
int *p = arr;
int i = 0;
for ( i=0; i<sz; i++ )
{
  printf("%d ", *p);
  p += 1; // 指针运算，等价于p++；
}
打印：1 2 3 ... 10 
  
案例2: 打印奇数
for ( i=0; i<5; i++ )
{
  printf("%d ", *p);
  p += 2;
}
打印：1 3 5 7 9 
  
案例3：倒序打印偶数
int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
int sz = sizeof(arr) / sizeof(arr[0]);
int *p = &arr[9];
int i = 0;
for ( i=0; i<5; i++ )
{
  printf("%d ", *p);
  p -= 2;
}
打印：10 8 6 4 2
  
案例4：赋初值
#define N_VALUES 5
float values[N_VALUES];
float *vp;

for ( vp=&values[0]; vp<&values[N-VALUES]; )
{
	*vp++ = 0; // * == 前置++ > 后置++
  	// 等价于(*vp)++ 指针不断叠加
}
```

2. 指针-指针

```c
// 得到中间的元素个数
int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
printf("%d \n", &arr[9] - &arr[0]); 9 类似10-1
printf("%d \n", &arr[0] - &arr[9]); -9 
// 大地址 - 小地址 = 中间元素个数
  
案例：求字符串长度
my_strlen (char *str)
{
  char *start = str;
  char *end = str;
  
  while ( *end != '\0' )
  {
  	end++;  
  }
  return end - start;
}
// 测试
char arr[] = "bit";
int len = my_strlen(arr);
printf("%d \n", len); 3 
```

3. 指针的关系运算

```c
代码1：
#define N_VALUES 5
float values[N_VALUES];
float *vp;
for ( vp = &values[N_VALUES]; vp > &values[0]; )
{
    *--vp = 0;  // 先-- 再解引用 
}

代码1改造2：
#define N_VALUES 5
float values[N_VALUES];
float *vp;
for ( vp = &values[N_VALUES]; vp>=&values[0]; vp-- )
{
    *vp = 0;  
}

// 实际上在绝大部分的编译器上是可以顺利完成任务的，然后我们应该避免这样写 改造代码2不建议，因为标准并不保证它可行。
// 标准规定：允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较，非法访问内存。
```

#### 1.5 指针和数组

```c
int arr[10] = { 1, 2 };
printf("第一个元素地址：%p \n", &arr[0]);
printf("第二个元素地址：%p \n", &arr[1]);

printf("%p \n", arr);     // 首元素地址
printf("%p \n", &arr[0]); // 首元素地址
printf("%p \n", &arr);    // 数组地址
printf("%p \n", &arr+1);  // 数组地址 (指针类型即是数组类型) 加了一个数组的字节，即40个字节
printf("%p \n", &arr[0]+1); // 第二个元素地址
printf("%p \n", arr+1);     // 第二个元素地址

// 数组名大部分是首元素地址，2个例外：
1. &数组名 
2. sizeof(数组名)
  
// 数组也可以用指针来访问，也可以下标访问
int arr[10] = { 0 };
int *p = arr;
int i = 0;
for ( i=0; i<10; i++ )
{
  *(p + i) = i;
  // 等价于 p[i] = i;
}
for ( i=0; i<10; i++ )
{
  printf("%d ", *(p + i));
}
```

#### 1.6 二级指针

```c
// 一级指针
int a = 10;
int *pa = &a; // pa就是一级指针变量 int*就是一级指针变量类型

// 二级指针
int a = 10;
int *pa = &a;
int **ppa = &pa; // ppa就是二级指针
int ***pppa = &ppa; // pppa就是三级指针

// 认识二级指针
// 指针变量也是变量，是变量就有地址，那指针变量的地址存放的变量叫什么？二级指针变量。
int **ppa = &pa;
第一个*表示：pa指向的那个对象类型是int* 
第二个*表示：ppa是一个指针
即：int* (*ppa) = &pa;
第一步：(*ppa)表示这是一个指针
第二步：int*表示这个指针存放的是一个int型指针

printf("%d \n", **ppa); // 10
**ppa = 20;
printf("%d \n", **ppa); // 20
printf("%d \n", a);     // 20

// 辅助内存地址图理解二级指针
代码               存值            地址
int a = 10;       a 10          0x0018ff44
int* pa = &a;    pa 0x0018ff44  0x0018ff40
int** ppa = &pa; ppa 0x0018ff40 0x0018ff3c
```

#### 1.7 指针数组

```c
// 好孩子   - 是孩子 
// 指针数组 - 是数组
// 数组指针 - 是指针

// 整型数组 - 存放整型 
// 字符数组 - 存放字符
// 指针数组 - 存放指针

int main ()
{
  int a = 10;
  int b = 20;
  int c = 30;
  int *pa = &a;
  int *pb = &b;
  int *pc = &c;
  
  int* arr[3] = 
  {
    &a,
    &b,
    &c
  };
  
  int i = 0;
  for ( i=0; i<3; i++ )
  {
	printf("%d ", *(arr[i])); // 10 20 30
  }
}
```

### 2. 进阶指针

#### 2.0 回顾初级指针

```c
1. 指针就是个变量，用来存放地址，地址是唯一表示一块内存
2. 指针的大小是固定的，多少位机决定了几个字节
3. 指针有类型，决定了指针的加减整数的步长，指针解引用操作的访问权限
4. 指针的运算
```

#### 2.1 字符指针

```c
int main ()
{
  char arr[] = "abcef";
  char *pc = arr; // 数组名-首元素地址
  printf("%s \n", arr); // "abcef" 字符指针无需解引用
  printf("%s \n", pc);  // "abcef" 字符指针无需解引用
  
  printf("%s \n", *pc); // 报错？char*只有一个字节的访问权限，非法访问
  printf("%c \n", *pc); // "a"
}

int main ()
{
  char *p = "abcdef"; // 报错 +const
  // ? 报错 右边7个常量字符串，左边指针变量肯定放不下的。而是把'a'首字符的地址赋值给p。
  printf("%c \n", *p); ?
  printf("%s \n", p);  ?
}

int main ()
{
  char *p = "abcdef"; // 报错 +const
  *p = 'W';
  // 这样应该是语法错误的，vs似乎没底线了，linux反正是报错了
  // 报错信息：segmentation fault 段错误 也就是非法内存相关会导致的错误
  // 因为这个 "abcdef"是常量字符串，不能修改的
  
  // 更加规范准确的写法：指向可以变值不能变
  const char *p = "abcdef"; 
}

// 练习题
int main ()
{
    char arr1[] = "abcdef";
    char arr2[] = "abcdef";
    char* p1 = "abcdef"; // 报错？+const
    char *p2 = "abcdef"; // 报错？+const
  
    if ( arr1 == arr2 )
      printf("hehe \n");
    else 
      printf("haha \n");
   // haha 两个不同的数组，不同的空间，不过是存储了相同的内容而已
  
  	if ( p1 == p2 )
      printf("hehe \n");
    else 
      printf("haha \n");
   // hehe "abcdef"常量字符串，不能更改，两份一样的常量字符串，为了节省空间，内存只存了一份，所以相同
}
```

#### 2.2 数组指针 ？一维二维？

```c
// 是指针
int *pint; 指向整型数据的指针，可存放整型的地址
float *pf; 指向浮点型的指针，可存放浮点型的地址
int *arr[10]; 指向数组的指针，可以存放数组的地址

类比1：
int arr[10] = { 0 };
arr后面紧跟[]，表明是一个数组.
10表示是数组有10个元素
int表示这10个元素都是int型 
类比2：[] > *
int (*p)[10] = &arr;
*p先结合表示是一个指针
[10]表示指向一个10个元素的数组
int 数组元素类型是int型

一维数组指针：int *p = &arr;      ?
二维数组指针：int (*p)[3] = &arr; ?不熟悉

案例1：
char* arr[5];
? pa = &arr; // ?是什么类型
char (*pa)[5] = &arr; 错误，我的答案
char *pa = &arr; 似乎也错误
char* (*pa)[5] = &arr; 答案，上面是char*
案例2：
int arr[10] = { 0 };
? pa = &arr;
int (*pa)[10] = &arr; 答案

如何使用呢？
数组指针指向的是数组，存放的是数组的地址。
int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
int (*pa)[10] = &arr;
int i = 0;
for ( i=0; i<10; i++ )
{
  printf("%d ", *(pa + i));
  // 错误 二维数组？ 首元素地址a[0] 第一行的首元素地址 a[1] 第二行的首元素地址 pa+1即第二行钚元素地址 具体拿第二行第几个，即+j列  不对！
  
  printf("%d ", (*pa)[i]); // 1 2 3... 10 这里和上面解释冲突了 ？？
  printf("%d ", *(*pa + i)); // 1 2 3... 10
}
int main ()
{
  int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
  int* p = arr;
  int i = 0;
  for ( i=0; i<10; i++ )
  {
    printf("%d ", *(p + i)); //  1 2 3... 10
  }
}

一个数组指针的使用：至少二维数组以上方便些
void print1 (int arr[3][5], int x, int y)
{
  int i = 0;
  int j = 0;
  for ( i=0; i<x; i++ )
  {
    for ( j=0; j<y; j++ )
    {
      printf("%d ", arr[i][j]);
    }
    printf("\n");
  }
}
void print (int (*p)[5], int x, int y)
{
  int i = 0;
  for ( i=0; i<x; i++ )
  {
    int j = 0;
    for ( j=0; j<y; j++ )
    {
      printf("%d ", *(*(p + i) + j));
      printf("%d ", (*(p + i))[j]);
      // *(p[i] + j)
      // p[i][j]
    }
  }
}
int main ()
{
  int arr[3][5] = {
          { 1,2,3,4,5 },
          { 2,3,4,5,6 },
          { 3,4,5,6,7 } 
  }
  print(arr, 3, 5);
  print(arr, 3, 5);
}

补充一个：
int arr[4] = { 1,2,3,4 };
int *p = arr;
int i = 0;
for ( i=0; i<10; i++ )
{
  // arr == p
  printf("%d ", *(p + i));
  printf("%d ", *(arr + i));
  printf("%d ", arr[i]);
  printf("%d ", p[i]);
  // arr[i] == *(arr+i) == *(p+i) == p[i]
}

练习：
[] > *
int arr[5];
// 一个数组，5个元素，int型。arr是一个5个元素的整型数组。
int* parr[10];
// []>* 一个数组，10个元素，int*型。指针数组。
int (*parr)[10];
// 一个指针，[]指向一个数组，10个元素，int型，数组指针。
int (*parr[10])[5];
// 一个数组，10个元素，int * [5]型，即5个整型数组指针。指针数组。10个元素，每个元素是一个数组指针，指针指向一个5个元素的数组，每个元素是int型。  不熟悉！
// parr[10]表明是一个数组，指向int(*)[5]，*表示存放的是指针，指向int[5]，一个有5个整型元素的数组。
```



#### 2.3 指针数组

```c
// 是数组，用来存放指针的
int arr[10] = { 0 }; 整型数组
char ch[5] = { 0 };  字符数组
int* parr[4];        整型数组
char* pch[5];	 字符指针数组
char** arr[5]; 二级字符指针数组

案例1：
int main ()
{
    int a = 10;
    int b = 20;
    int c = 30;
    int d = 40;
    int* arr[4] = {
        &a,
        &b,
        &c,
        &d
    };
    int i = 0;
    for ( i=0; i<4; i++ )
    {
        printf("%d ", *(arr[i])); // 10 20 30 40
    }
}

例子2：指针实际用法
int arr1[] = { 1,2,3,4,5 };
int arr2[] = { 2,3,4,5,6 };
int arr3[] = { 3,4,5,6,7 };
int* parr[] = { arr1, arr2, arr3 };

int i= 0;
for ( i=0; i<3; i++ )
{
  int j = 0;
  for ( j=0; j<5; j++ )
    printf("%d ", *(parr[i]+j));
}
```



#### 2.4 数组传参和指针传参

#### 2.5 函数指针

#### 2.6 函数指针数组

#### 2.7 指向函数指针数组的指针

#### 2.8 回调函数

#### 2.9 指针和数组面试题的解析



## (五) 函数

## (六) 数组

## (七) 文件操作

## (八) 动态分配内存

## (九) 练手项目

