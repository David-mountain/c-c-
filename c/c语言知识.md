# c语言知识

## (零) 此总结后面会有练手项目

## (一) 数据类型

### 1. 数据类型介绍

#### 1.1 内置类型

char short int long float double 

整型家族：

​	char(存的ascii值，也归类整型)

​		unsigned char  0~255

​		signed char      -128~127

​	short 

​		unsigned short [int]     // []表示可写可不写

​		signed short [int]

​	int 

​		unsigned int

​		signed int 

​	long 

​		unsigned long [int]

​		signed int [int]

浮点型家族：

​	float 

​	double 

#### 1.2 自定义类型(构造类型)

数组类型    int arr[length]

结构体类型 struct

枚举类型     enum

联合类型     union

指针类型

​	int* pi;

​	char* pc;

​	float* pf;

​	void* pv;

#### 1.3 c没有字符串类型

#### 1.4 类型的意义

i. 使用这个类型开辟内存空间的大小(大小决定了使用范围)

ii. 如何看待内存空间的视角

#### 1.5 空类型void

void 表示空类型(无类型)

通常应用于函数的返回类型，函数的参数，指针类型

​	void* pv;

​	void test () {}

​	void test (void) {} 或者不写void

### 2. 整型在内存中的存储

#### 2.1 原码、反码、补码

一个变量的创建要在内存中开辟空间的，空间的大小是根据不同的类型决定的。

int a = 20;  14 00 00 00 

int b = -10; f6  ff  ff  ff ？

​	原码：10000000 00000000 00000000 00001010

​	反码：11111111 11111111 11111111 11110101

​	补码：11111111 11111111 11111111 11111110

​			ff			ff		ff		f6

​	从左到右，低地址到高地址，这里低位放到低地址处，这是小端模式

你会好奇这些是如何得出来的？

因为计算机中不同的数据类型采用了不同的存储方式，有符号数有三种表示方法，即原码、反码、补码，注意整型和浮点数不是这样的存储方式。 

三种表示方法都是有 符号位和数值位 两部分，符号位0正1负，而数值位三种方法则各不相同。

原码：直接将二进制按照正负数的形式翻译成二进制即可

反码：将原码的符号位不变，其他位依次取反即可

补码：反码+1即可？

注意：

无符号数：原码 反码 补码 一样

有符号数：原码 反码 补码 都不一样

```
int a = 20; // 4个字节 32bit 对整型而言，三者都是一样的
00000000 00000000 00000000 00010100 原码  16进制-0x00 00 00 14
00000000 00000000 00000000 00010100 反码
00000000 00000000 00000000 00010100 补码

int b = -10;
10000000 00000000 00000000 00001010 原码
11111111 11111111 11111111 11110101 反码 
11111111 11111111 11111111 11110110 补码  16进制-0xff ff ff f6 (快捷1111->15->f)

我理解成无符号数是正数？有符号数是负数？对吗？
```

####  2.1为什么会有反码 补码呢？

反码忘记了，只记得补码了

i). 对于整型而言，数据存放在内存中，是以补码的形式的 ？

因为在计算机系统中，数值一律用补码来表示和存储。原因是使用补码，可以将符号位和数值域统一处理，

同时，加法和减法也可以统一处理(cpu只有加法器)，此外，补码和原码相互转换，其运算过程是相同的，

不需要额外的硬件电路。

ii). 只有加法，那 + - * / 呢？ 

```
没有补码错误案例：
1-1 -> 1+(-1)
1的原码：  00000000 00000000 00000000 00000001
-1的原码： 10000000 00000000 00000000 00000001
相加：     10000000 00000000 00000000 00000010
结果：    -2 (不对)

科学家想出来了补码来解决。
1的补码：  00000000 00000000 00000000 00000001
-1的补码： 11111111 11111111 11111111 11111111  🏋️‍🏋️‍
相加：     10000000 00000000 00000000 00000000 0
结果：     0 (正确)
因为我是int型，32位，最高位1被干掉了，剩下全是0了。

这是减法的过程，也是补码的过程。
```

### 3. 大小端字节序列介绍及判断

#### 3.1 引出大小端

我们发现之前int a = 20;的16进制数，应该是0x00 00 00 14，但是在vscode内存显示中是反过来的，是14 00 00 00 这是为什么呢？而且也不是完全的数字相反？这就涉及到大小端了。

首先我们要明确的是不要以为vs这里是16进制的数，就以为内存中存储的是16进制的数，内存中始终都是存放的0、1数字，这里转成16进制只是为了方便程序员看。

另外一个需要明确的点是，数据在内存中的存储顺序，是以字节的顺序，不是二进制的顺序。比如0x 11 22 33 44，这里11是一个字节，是以字节为基本存储单位的。

还有一个点，内存空间是有编号的，编号有大有小的，地址线，编号小的叫低地址，大的叫高地址。

大端(存储)模式：指数据的低位保存在地址的高地址中，而数据的高位，保存在内存的低地址中。(低高大)

小端(存储)模式：指数据的低位保存在地址的低地址中，而数据的高位，保存在内存的高地址中。(低低小)

```
0x11(高位) 22 33 44(低位)   16进制
 11(低地址)22 33 44(高地址)  内存中的显示(转成16进制是为了方便看) 大端存储模式 
 44(低地址)33 22 11(高地址)  小端存储模式 
 
 vs内存显示：左(低)->右(高)
 16进制数字：左(高)->右(低)
```

#### 3.2 思考为什么有大端小端呢？

因为在计算机系统的，我们是以字节为单位的，每个地址单元都对应一个字节。

一个字节为8bit,C语言中还有16bit的short，32bit的long(看具体的编译器)

对于位数大于8位的处理器，例如16位或32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个或者多个字节的安排问题，因此就出现了大端存储模式和小端存储模式。

```
例：一个16bit的short型x,在内存中的地址为0x0010，x的值为0x1122
0x 11(高位) 22(低位)
 00(低地址，高位)10(高地址，低位) 若按此地址存，大端模式
 00(低地址，低位)10(高地址，高位) 若按此地址存，小端模式
 
 采用小端模式： 常用的x86结构、ARM DSP
 采用大端模式： KELL CS1
 有些ARM处理器可以自己选择大端或小端模式。
```

#### 3.3 百度笔试题 大小端判断

请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。10分

```
算法思路1：
int a = 20;
0x 00 00 00 14(低位)
 14(低位地址) 00 00 00  -小端
 00(高位地址) 00 00 00  -大端 
注意：内存中是以字节为单位的。
所以，我们想到了一个思路，只需要找出第一个字节，看是否是00即可，然后我们思考如何访问一个字节呢？想到了char*，访问一个整型数据的第一个字节即可。

答案：最好封装成函数
#include <stdio.h>
int check_sys1 ()
{
  int a = 1; // 设置1方便
  char* p = (char*)&a; // 从低地址开始拿到char*  🤸‍♂️🤸‍♂️🤸‍
  			// 若小端模式，低地址存了1
  			// 若大端模式，低地址存的是0
  if ( *p == 1 )
  	return 1;
  else 
  	return 0;
}
// 简化版
int check_sys2 ()
{
  int a = 1;
  return (*char( *)&a);
}
// 测试
int main ()
{
  int ret = check_sys();
  if ( ret == 1 )
  	printf("小端\n");
  else 
  	printf("大端\n");
}
```

```
复习时候想到的两个：
int a = 0x11223344;
char *p = (char*)&a;
	printf("1: %x \n", *p++);
	printf("2: %x \n", *p++);
	printf("3: %x \n", *p++);
	printf("4: %x \n", *p);
	我第一次想反了，0x11223344，谁是低位？44，类比10进制的1234，个位4是低位
	
char *p = (char*)&a;  😈😈😈
	&a-大的数据类型，本质是一块可用内存
	(char*)&a 这块可用内存，被强制重新划分使用
```

拓展指针类型的意义：

1. 指针类型决定了指针解引用操作符能访问几个字节  (解引用 访问)

   char* p ,* p可以访问1个字节，int* *p, *p可以访问4个字节

2. 指针类型决定了指针+1 -1时候的步长，可以加减几个字节。(加减 步长)

   char* p; p+1跳过1个字节， int *p; p+1跳过4个字节

   ​

### 4. 浮点数在内存中的存储解析

#### 4.1 浮点数介绍

```c
float 
double 
long double 
float f1 = 3.1415f;
double d1 = 1E10;  // 1*10的10次方
printf("%f \n", f1);
printf("%lf \n", d1); 

浮点数取值范围：float.h中有定义
数据类型的取值范围：limits.h中有定义
```

#### 4.2 练习题

```c
int main ()
{
  int n = 9;
  float* pFloat = (float*)&n;  😈😈😈
  printf("n的值为：%d \n", n);             // 9
  printf("*pFloat的值为：%f \n", *pFloat); // 0.000000
  
  *pFloat = 9.0;
  printf("num的值为：%d \n", n);           // 1094567616
  printf("*pFloat的值为：%f \n", *pFloat); // 9.000000
}
得出结论：整型和浮点型在内存中的存储方式不一样的。

解释浮点数在计算机内部的表示方法：
根据国际标配IEEE(电气和电子工程协会)754，任意一个二进制浮点数V可以表示成下面的形式： (-1)^S * M * 2^E 。
	(-1)^s表示符号位，当s=0，V为正数，当s=1，V为负数
	M表示有效数字，大于等于1，小于2  
	2^E表示指数位
举例1：
十进制   5.0
二进制 101.0
(-1)^0 * 1.01 * 2^2
(-1)^S *  M   * 2^E 
S = 0，M = 1.01，E = 2
举例2：
十进制   -5.0
二进制 -101.0
(-1)^1 * 1.01 * 2^2
(-1)^S *  M   * 2^E 
S = 1，M = 1.01，E = 2
  
IEEE规定：对于32位的浮点数，最高的1位是符号位S,接着的8位是指数E，剩下的23位有效数字M。1+8+23
  1(符号位S)+8(指数E)+23(有效数字M)
注意：E是一个无符号整数，但是E是有可能是负数的。8位，0-255。
解决负数的方案是：存入内存时E的真实值必须再加上一个中间值，对于8位的E，这个中间数是127。如果E = -1；存入内存的时候 +127 = 126(这是存入内存的最终值)。??
```

```c
int main ()
{
  float f = 5.5; // 内存中存的值是什么？
}
分析：
(-1)^0 * 1.011 * 2^2 
S = 0
M = 1.011 
E = 2
32bit: 0 10000001 01100000000000000000000
16进制：0x40 b0 00 00 
10000001? 
  0000 0010  +2
  0111 1111  127(规则要求+127)
  1000 0001  129(最终结果)
二进制快速转16进制？
	0100 0000 1011 0000...0000
  0100->2^2=4(16)
  1011->2^3+2^1+2^0=11->b(16)
  得：40 b0 00 00 
  
因为我们是小端模式，所以最后内存显示是：00 00 0b 40
```

```c
int main () 待整理！
{
  int n = 9;
    // 0000000...1001 9的补码 
    这里强制转成浮点数 上面的补码就需要重新划分哈
    0(1位) 0000000(8位) 0000...1001(23位)
    如何还原呢？ E这里8位全是0 取出的第二个规则 
    (-1)^0 * 0.000.。。1001 * 2^-126 ???看看规则 
    这就是正0 无限接近0的意思 
    float* pFloat = (float *)&n;
    printf("n的值为：%d\n", n);
    printf("*pFloat的值为：%f\n", *pFloat);

    *pFloat = 9.0;
    1001.0 
    1.001 * 2^3 
    (-1)^0 * 1.001 * 2^3 
    0 10000010 00100..0   9.0存在内存的形式 
    这里打印n 需要从整型的角度看待这个存在内存中的值了
    0 10000010 00100..0 转成十进制 1091567616 
    printf("num的值为：%d\n", n);
    printf("*pFloat的值为：%f\n", *pFloat);
    return 0;
}
```

#### 4.3 取浮点数

上面都是存入浮点数类型，取出浮点数还有一些特殊情况。

指数E从内存中取出还可以再分成三种情况：

1. E不全为0或不全为1
2. E全为0
3. E全为1

### 5. 代码题

```c
int main ()
{
  char a = -1;
  signed char b = -1;
  unsigned char c = -1;
  printf("a=%d,b=%d,c=%d", a, b, c);
}
-1 -1 255 
分析：
char a = -1; ？？有问题这 我改错了 下面应该都是3位的
	 00000001 原码
	 11111110 反码
	 11111111 补码
	11111111 11111111 11111111 11111111 char型 补码
	11111111 11111111 11111111 11111110 反码
	10000000 00000000 00000000 00000001 原码 -1
printf("a=%d,b=%d,c=%d", a, b, c);
	a 打印整型%d,然而这里是字符型，所以需要类型提升。
	11111111最高位的1当成是符号位，前面补1，至共32位，这是补码的。
	然后拿着补码倒回去算原码，-1。口诀：-1的补码才全是1！！
	b 同上，不要被signed吓到，可以省略的。
	c 无符号数，高位直接补0，0000...11111111 ->255 口诀：8个1是255
```

```c
 int main ()
{
  char a = -128;
  printf("%u\n", a);
}
分析：
首先强调自己明白了一个点，和上面的无符号，unsigned char和这里(signed) char，这个的不同直接决定了后面是直接补充0还是看最高位的数来决定。
10000000 00000000 00000000 10000000 原码
11111111 11111111 11111111 01111111 反码 
11111111 11111111 11111111 10000000 补码 
10000000 char型 发生截断 
这里打印%u无符号整数，需要类型提升，注意这里是char a，不是unsgined char a，所以这里需要看最高位的，来决定补充0还是1，这里是1，前面补充1，1111111...10000000，这里补码整型提升后还是补码，又因为这里是打印无符号数的，原反补码都是一样的。所以直接将这个二进制转成十进制即可。

int main ()
{
  char a = 128;
  printf("%u\n", a);	
}
```

```
char类型能表示的数值范围：
1个字节，8个bit位。

--------------unsigned char:
当成补码看  数值
0000 0000  0
0000 0001  1
...
1000 0000  128 *
1000 0001  129
...
111111111  255

--------------signed char:
当成补码看  数值
0000 0000  0
0000 0001  1
...
0111 1111  127 
1000 0000  -128 *
1000 0001  -127
...
111111111  -1 (反码1111 1110 -> 原码1000 0001)

--------------分析-128来源？
对于有符号位整数，二进制的最高位表示正负，不表示数值，最高位是0时表示正数，为1时表示负数，这样一来，能表示数值的就剩下(n-1)位了。
比如：char a = -1; 二进制表示就是1000 0001，1表示0000 0001.
所以，signed char 型出去符号位剩下的7位最大是 1111 111 = 127；加上符号位是：0 1111111 = 127; 那范围也应该是-127~127阿，哪里来的-128？

这里补充一个知识，反码的由来，从减法中来的：？
1-1=？计算机只会做加法，会转换成1+(-1)
0000 0001  1  (原码)
1000 0001  -1 (原码)
0000 0010  -2(相加结果不对)
为了避免减法运算错误，发明了反码。
规定：正数的反码原码相同，负数的反码是原码除了符号位，其余都取反。
0000 0001  1  (反码)
1111 1110  -1 (反码)
1111 1111  反码 -> 原码 1000 0000 = -0 (正确) 

补码的由来，解决重复的0：？
虽然反码解决了相减的问题，却又带来了另外一个问题，-0，既然0000 0000表示0，那么就没有-0的必要了，出现了+0=-0=0，其实一个0就够了，为了避免两个0的问题，科学家又发明了补码。
规定：整数的补码是其本身，负数的补码为其反码+1。
0000 0001  1的补码
1111 1111  -1的补码
1 0000 0000 结果是9位，由于是char型，8个bit，保留8位，最高位1被丢弃，结果是0.
-0 原码：1000 0000 
   补码：1000 0000 0 由于char是八位，取低八位
   补码：0000 0000
+0 原码：0000 0000
   补码：0000 0000 
虽然补码都是相同的，但是有两个0，既然有两个0，况且0既不是整正数，又不是负数，用原码 0000 0000 表示就行了，这样一来，有符号的char，原码都用来表示-127~127之间的数。唯独原码1000 000没有用。
其实你自己用排列组合也可以算出来，0??? ????，也能表示128个数，0~127刚刚好。
1??? ????，也能表示128个数。总共signed char 有256个数。最后谈论剩下的那个1000 0000.为什么-0可以表示-128？

如果不限制为char型，(即不要限定为8位)，再来看，-128的原码：1 1000 0000，9位。
最高符号位，再算它的反码：1 0111 1111，进而，补码为：1 1000 0000，这是-128的补码。
128的原码和-0(1000 0000)的原码是不相同的，但是在char中，是可以用1000 000表示-128的，关键在于char是8位，它把-128的最高位符号位1丢弃了，截断后-128的原码为 1000 000 和-0的原码相同，也就是说 1000 0000 和-128丢弃最高位之后余下的8位相同，所以才可以用-0表示-128，这样，当初剩余的-0(10000 0000)，被拿来表示截断后的-128，因为即使截断后的-128和char型范围的其他数(-127~127)运算也不会影响结果，所以才敢这样表示-128.比如：
-128+(-1) = ?
1000 0000    丢弃最高位的-128
 111 1111    -1
10111 1111   char取八位，结果不正确，没关系，结果-129本来就超出char型了，当然不能表示

-128+127 = ？
1000 0000   -128
0111 1111
1111 1111   -1(正确)

char a = -128;
printf("%d", a); -128 记死把这个！最高位丢弃了，输出时应该是1000 000的原码的十进制数-0，但为什么能输出-128呢？以后自己研究。
char a = -129;
printf("%d", a); -129在补码为10 0111 1111 只取后八位存储，即0111 1111，这个值刚好是127。

unsigned char a = 1;
if ( 1 > a )
	printf("大于");
else 
	printf("小于");
结果：小于。
a是unsigned无符号，它的八位都用来存储数值，没有符号位，编译器把-1转换成补码为1111 1111，(1000 00001 -> 1111 1110 -> 1111 1111)，但是由于是无符号位，计算机会把 1111 1111，当作是无符号来对待，自然就是 2^8-1=255了，所以原代码是 if( 1 > 255 ) 肯定就是小于。
```

这里要插入一幅图，数值范围的圆图！

```c
int main ()
{
	int i = -20;
  	unsigned int j = 10;
  	printf("%d\n", i+j);
}
-10 
 10000000 00000000 00000000 00010100  -20原码 
 11111111 11111111 11111111 11101011     反码
 11111111 11111111 11111111 11101100     补码
 00000000 00000000 00000000 00001010   10原码反码补码
 11111111 11111111 11111111 11110110   两者补码相加，得结果
 
 11111111 11111111 11111111 11110101   得结果的反码
 10000000 00000000 00000000 00001010   得结果的原码 -10
```

```c
int main ()
{
	unsigned int i;
  	for ( i=9; i>=0; i-- )
    {
      printf("%u\n", i);
    }
}
死循环
我自己还傻傻去算原码反码补码，没有认真读完整个程序就下手了。
因为i是一个无符号整数，不可能是负数阿，取值范围是0~255，就一直满足for循环的判断了，形成了死循环了。
```

```c
int main ()
{
  char a[10000];
  int i;
  for ( i=0; i<10000; i++ )
  {
    a[i] = -1 - i;
  }
  printf("%d", strlen(a));
}
答案未知
和我分析的差不多，但是我还差一步。
知识补充：strlen结束标志：\0
当你以为是随机值的时候，发现本题的重点不是在最后查，而是在赋值阶段。
char型，取值范围-128~127，这里的-1~-10000不可能完全存入的，超出的都会转成这个取值范围的值，比如：
-1-128 = -129 ->
1000 0000 1000 0001  -129原码
1111 1111 0111 1110      反码
1111 1111 0111 1111      补码 
因为char型，保留8位，0111 1111(作为补码)。
最高位是0，计算机认为是正数，是127.
圈圈图(-128 逆时针+1就是 127)
所以，数组里面存放的都是这些值。代码非法访问内存了，这只能作为练习题看看。
```

```c
unsigned char i = 0;
int main ()
{
  for ( i=0; i<255; i++ )
  {
    printf("hello world \n");
  }
}
死循环 
因为是无符号数，取值范围是0~255，这里判断条件是i<255，只有大于255才能终止循环。
```

总结：这几个练习题，其中关于死循环的几个题目，我们可以得出：unsigned 和 char 之类，这几个数据类型导致了不满足for终止循环的条件，从而产生bug。

### 6. 常见进制数

```c
1111(2) -> 15(10) -> f(16)

```

#### 7. 常见ascii码值

```c
'a'-97 'z'-122
'A'-65 'Z'-90
32-空格
'0'-'9'  48-57
```



## (二) 分支和循环

### 1. 选择结构

```c
c语言是一门结构化的程序设计语言
顺序结构
选择结构
循环结构

选择结构：---------------------------
if ( 表达式 )
  语句1；
else 
  语句2；
表达式真假：C中0是假，非0就是真

例1：
int a = 0;
int b = 2;
if ( a == 1 )
  if ( b == 2 )
    printf("hehe \n");
else
  printf("haha \n");
答案：什么也不打印，提醒我们要注意代码规范。
else寻找距离自己最近的if，代码规范

例2：
if ( condition )
{
	return x;
}
return y;
对比：
if ( condition )
{
	return x;
}
else 
{
	return y;
}

例3：
int num = 1;
if ( num = 5 )
{
  printf("hehe \n");
}
打印hehe

例4：判断一个数是否是奇数，打印
int main ()
{
	int i = 1;
  	while ( i <= 100 )
    {
      if ( i%2 == 1 ) // !=0也可以
        printf("%d ", i);
      i++;
    }
}
写法2：避开了判断，这种是利用了计算机的特性
int main () 
{
  int i = 1;
  while ( i <= 100 )
  {
      printf("%d ", i);
      i+=2;
  }
}

switch
  switch (整型表达式)
  {
	语句项；
     case 整型常量表达式：
       	语句；
  }
例1：
switch (day)
{
  case 1:
    printf("工作日 \n");
    break;
  case 2:
    printf("工作日 \n");
    break;
  case 3:
    printf("工作日 \n");
    break;
  case 4:
    printf("工作日 \n");
    break;
  case 5:
    printf("工作日 \n");
    break;
  case 6:
    printf("休息日 \n");
    break;
  case 7:
    printf("休息日 \n");
    break;
}
优化：
switch (day)
{
  case 1:
  case 2:
  case 3:
  case 4:
  case 5:
    printf("工作日 \n");
    break;
  case 6:
  case 7:
    printf("休息日 \n");
    break;
}

注：
  1. 整型表达式 整型常量表达式
  2. break跳出switch，若不写，一定注意代码逻辑
  3. 代码简化，充分利用不写break，顺序执行类似逻辑
  4. default后面也加上break，给后人方便，无强制顺序要求，一般最后
  
例2：
int n = 1;
int m = 2;
switch (n)
{
    case 1: m++; 3
    case 2: n++; 2
    case 3: 
        switch (n)
         {
            case 1: n++; 
            case 2: m++; n++; break; 4 3
         }
    case 4:
        m++; 5
        break;
    default: 
        break;
}
printf("m = %d, n = %d\n", m, n); // 5 3
```

###  2. 循环结构

```c
循环语句：
while for do...while 

while ( 表达式 )
  循环语句；
直到表达式为假了，然后循环就不执行了
break: 用于终止本层循环，注：多层嵌套循环要多个break
continue: 用于跳过本次循环

例:
int n = 5;
while ( n-- )
{
  printf("%d", n);
}
// 5 4 3 2 1 0 错误
// 4 3 2 1
int n = 5;
while ( --n )
{
  printf("%d", n);
}
// 4 3 2 1 

例1：
基础版本：
int i = 1;
while ( i <= 10 )
{
	printf("%d ", i);
  	i++;
}
变式1：
int i = 1;
while ( i <= 10 )
{
  if ( i == 5 )
    break;
  printf("%d ", i);
  i++;
}
// 1 2 3 4
// break直接终止结束循环了，不会跳判断处
变式2：
int i = 1;
while ( i <= 10 )
{
  if ( i == 5 )
    continue;
  printf("%d ", i);
  i++;
}
// 1 2 3 4 死循环
// continue，然后跳到判断处，由于一直是5，一直continue，死循环，因为i++在continue的后面！！！遇到continue，跳过后面所有代码，开始下一轮
变式3：
int i = 1;
while ( i <= 10 )
{
  i++;
  if ( i == 5 )
    continue;
  printf("%d ", i);
}
// 1 2 3 4 6 7 8 9 10

例2：
int main ()
{
  int ch = 0;
  while ( (ch = getchar()) != EOF )
    putchar(ch);
}
// getchar接收键盘一个字符，直到获取到EOF才会停止(ctrl + z，本质是一个-1)
// 这些输入函数，计算机中有个输入缓冲区，输入函数接收数据时候，会把数据放入。当输出的时候，就去输入缓冲区拿
// \n ascii -10

例3：
0-9输出，其他不会输出
int main ()
{
  while ( (ch=getchar()) != EOF )
  {
    if ( ch < "0" || ch > "9" )
      continue;
    putchar(ch);
  }
}

for循环----------
while代码变量与循环体相对比较分散 
for ( 表达式1；表达式2；表达式3 ) 
{
    循环语句 
}
建议：
1.不可在for循环体内修改循环变量，防止for循环失去控制
2. 建议for语句的循环控制百度的取值采用"前闭后开区间"写法 for(i=0; i<10; i++)10似乎代表了10次

例1：
for (;;)
{
	printf("hehe \n");
}
// 死循环
1. for循环的初始化、调整、判断都可以判断
2. for循环的判断部分，如果被省略，那判断条件就恒为正  ！！！ 

例2：
int i = 0;
int j = 0;
for ( ; i<10; i++ )
{
  for ( ; j<10; j++ )
  {
    printf("hehe \n");
  }
}
// 10个hehe
随便省略的后果
因为i=0时候，然后j=0 1 2 3  4 5 6 7 8 9 10
进入i的第二轮的时候，j因为没有初始化，依然是10，初始化代码被放在了最外面全局，所以后续内循环都不执行了
总之：i第二轮开始，j都没有初始化了
解决：for ( j=0; j<10; j++ ) {} 加上j=0即可

例3：
int x, y;
for ( x=0,y=0; x<2 && y<5; ++x,y++ )
{
    printf("hehe\n");
}
// 2个hehe 
这里是2个循环变量

例4：要循环多少次
int main ()
{
    int i = 0;
    int k = 0;
    for (int i = 0,k = 0; k = 0; i++,k++)
    {
        k++;
    }
}
// 0次
第一次k=0，判断条件就是0，是假，不会进入循环
这里不是k==0，是k=0
若是k=1，就是非0了，是真，死循环

do...while  --------------
例1：
int i = 1;
do
{
    printf("%d ", i);
    i++;
}
while (i <= 10);
变式1：
int i = 1;
do
{
    if ( i == 5 )
        break;
    printf("%d ", i);
    i++;
}
while (i <= 10);
// 1 2 3 4
变式2：
int i = 1;
do
{
    if ( i == 5 )
        continue;
    printf("%d ", i);
    i++;
}
while (i <= 10);
// 1 2 3 4 死循环
```

### 练习题-1 前n个的的n的阶乘的和

```c
解1：
int main ()
{
  int i = 0;
  int n = 0;
  int sum = 0;
  for ( n=1; n<=10; n++ )
  {
    for ( i=1; i<=n; i++ )
    {
      ret *= i;
    }
    sum += ret;
  }
}
找出问题？
ret第二次后没有初始化，上一次的就被乘在里面了
而且，这个代码效率不高，重复上次阶乘的计算了
类似递归

优化1：
int main ()
{
  int i = 0;
  int n = 0;
  int sum = 0;
  for ( n=1; n<=10; n++ )
  {
    ret *= n;
    sum += ret;
  }
}
上一次的阶乘被保存在ret中，后面继续使用
```

### 练习题2-有序数组中找一个数字

```c
解1：
int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
int k = 7;
int sz = sizeof(arr) / sizeof(arr[0]);
int i = 0;

for ( i=0; i<sz; i++ )
{
  if ( k == arr[i] )
  {
    printf("ok %d \n", i);
    break;
  }
}
if ( i == sz )
{
  printf("找不到 \n");
}

解2：
int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
int k = 7;
int sz = sizeof(arr) / sizeof(arr[0]);
int left = 0;
int right = sz - 1;

while ( left <= right )
{
  int mid = (left + right) / 2;
  
  if ( arr[mid] > k )
  {
    right = mid -1;
  }
  else if ( arr[mid] < k )
  {
    left = mid + 1;
  }
  else 
  {
    printf("找到了 %d \n". mid);
    break;
  }
}
if ( left > right )
{
  printf("找不到 \n");
}
```

### 练习题3-中间向两边

```c
效果：  中间向两边 
welcome to bit!!! 
w###############！
we#############!!
wel###########!!!
  
int main ()
{
  char arr1[] = "welcome to bit!!! !!!";
  char arr2[] = "#####################";
  int left = 0;
  // int right = sizeof(arr1) / sizeof(arr[0]) - 2;
  int right = strlen(arr1) - 1;
  
  while ( left <= right )
  {
    arr2[left] = arr1[left];
    arr2[right] = arr1[right];
    printf("%s \n", arr2);
    Sleep(1000); // // 方便看 延迟一秒  #include <windows.h>
    system("cls"); // 执行系统命令的一个函数 cls 清空屏幕 这样看着效果明显
    
    left++;
    right--;
  }
}
```

### 练习题4-密码输入

```c
int i = 0;
char password[20] = { 0 };
for ( i=0; i<3; i++ )
{
  printf("%请输入密码：>");
  scanf("%s", password);
  
  if ( password == "123456" )
  {
    printf("登录成功 \n");
    break;
  }
  else 
  {
    printf("密码错误 \n");
  }
}
if ( i == 3 )
  printf("三次密码均错误，退出程序 \n");

// 无论输入对错，都会打印三次密码均错误，退出程序 
分析：
1. ==不能用来比较两个字符串是否相等 strcmp(password, "123456") == 0 
```

### 练习题5-棱形13*13

```c
// 解法一
	for (int a = 6,i=-1; a<7; a+=i)
	{
		int b = 0;
		for (; b < 14-a; ++b)
			a<b ? putchar('*') : putchar(' ');
		puts("");

		if (a == 0)
			i = 1;
	}

// 解法2
	for (int row=0; row++<13;)
	{
		for (int col=0; col++<13-abs(7-row);)
			col>abs(7-row) ? printf("*") : printf(" ");

		putchar(10);
	}

	puts("");
```

### 练习题6-n进制

```c

```



## (三) 操作符

### 1. 算术操作符

```c
int a = 5 / 2;
printf("%d \n", a);  // 2 不是2.5 思考是二进制位丢弃？
除法，如果两边的都是整数，得整数
     如果两边的都是小数，或被除数除数一定要有一个小数，才能得小数(涉及数据类型的隐式转换规则)

int a = 5 % 2; // 1
%：两边的操作数必须是整数
```

### 2. 移位操作符(移动的是二进制位)

```c
！警告：对于移位运算符，不要移动负数位，这是未标准化的。
例：int num = 10;
    num >> -1;  // error

<< 左移操作符:
   左边抛弃、右边补0
   int a = 5;
   int b = a << 1;  // ?
   00000000 00000000 00000000 00000101 5的原码
   00000000 00000000 00000000 00000101(0) 8+2=10的原码
   简记：左移一位，相当于*2.
   
>> 右移操作符
	int a = 16;
	int b = a >> 1;  // ?
	0000 0000 0000 0000 0000 0000 0001 0000  16的原码
	0000 0000 0000 0000 0000 0000 0000 1000 8的原码
	右移一位，相当于/2
     
    负数测试：
    1. 算术右移
    	整数最高位是0，0正1负
    	向右移动，右边的丢弃，然后左边最高位保留符号位
    2. 逻辑右移
    	右边丢弃，左边补0
    int a = -1;
	int b = a >> 1;  // -1 我们见到的通常是算术右移

如果要移位，首先要找到它的补码。
正数- 原反补一样
负数- 原码符号位不变，其他取反(得补码)，再+1
```

### 3. 位操作符(二进制基础上)

#### i) bite_c 位

```c
按位运算符分为
	按位逻辑运算符 & | ~
	位移运算符 << >> >>>(无符号右移)

& | ^
注：操作数必须是整数。
& 按位与
	有1个是0就是0，两个都是1才是1
| 按位或
	有1个是1就是1，两个都是0才是0
^ 按位异或
	相同为0，相异为1(同0异1)
	
例1：&
int a = 3;
int b = 5;
int c = a&b;
解析：
00000000 00000000 00000000 0000 0011 3
00000000 00000000 00000000 0000 0101 5
00000000 00000000 00000000 0000 0001 1 结果

0 & 0 == 0
0 & 1 == 0
1 & 0 == 0
1 && 1 == 0
得出性质：假设b某个二进制的某位
	1. 任意位和1做 &运算的结果是它本身，即b&1=b
	2. 任意位和0做 &运算的结果是0，即b&0=0
  利用这个性质，可以关闭指定位，(将指定位设置为0，其他位不变)
  
例2：|
int a = 3;
int b = 5;
int c = a^b;
解析：
00000000 00000000 00000000 0000 0011 3
00000000 00000000 00000000 0000 0101 5
00000000 00000000 00000000 0000 0110 6 结果

0 | 0 == 0
0 | 1 == 1
1 | 0 == 1
1 | 1 == 1

得出性质：假设b某个二进制的某位
	1. 任意位和1做 | 运算的结果是1，即 b|1=1
  	2. 任意位和0做 | 运算的结果是它本身，即 b|0=b 
  利用这个性质，可以关闭指定位，(将指定位设置为0，其他位不变)
  
面试题：
不能创建临时变量，实现两个数的交换
方法一：加减法
int a = 5;
int b = 3;
a = a + b;  // a存放两个数的和 b存放b
b = a - b;  // b存放a (两个数的和a)-b
a = a - b;  // a存放b (两个数的和a)-a的值(b中)
注：相加不能超过int型，所表示的范围，有缺陷，可能会溢出，这种方法就不好了。

方法二：异或的方法 ^
int a = 5;
int b = 3;
a = a^b;
b = a^b;
a = a^b;
printf(""a= %d b= %d\n", a, b"); // a=3 b=5

后面再来研究这个，半加法！！！及其相关性质

^ 
// 表达式
(1001 0011) ^ (0011 1101)
// 结果
(1010 1110)

// 所有的运算结果
0 ^ 0 == 0
0 ^ 1 == 1
1 ^ 0 == 1
1 ^ 1 == 0
  得到以下的性质，假设 b 是某个二进制值的某位。
	1. 任意位和 1 做 ^ 运算的结果是该位取反，即 b ^ 1 = ~b。
	2. 任意位和 0 做 ^ 运算的结果是本身，即 b ^ 0 = b。
	利用上面的性质，我们可以用 ^ 运算符来切换指定位(将指定位取反，其他位不变)
```

面试题1: 求一个整数存储在内存中的二进制，其中1的个数

```c
算法思路：十进制转成二进制，过程中判断是否有1.
补充：想得到123每个位置的数字？
	十进制是，不断%10,然后/10
  	二进制是，不断%2，然后/2
  
方法一： (有缺陷)
int main ()
{
  int num = 10;
  int count = 0;
  scanf("%d", &num);
  
  while ( num )
  {
    if ( num%2 == 1 )
      count++;
    num /= 2;
  }
  printf("二进制中1的个数= %d \n", count);
}
缺陷：负数有问题
  
方法二：右移操作符
int main ()
{
  int num = 0;
  int count = 0;
  scanf("%d", &num);
  
  int i = 0;
  for ( i=0; i<32; i++ ) ？能直接遍历32？先转二进制？
  {
    if ( 1 == (num >> i) & 1 )
      count++;
  }
}
不太对，后期再看看？？

方法三：后期添加
```

补充：位运算符

```c
& | (0擦除 1保留)
7&7=7 这不就是位运算符的5个性质吗

练习：探测是否是1
unsigned char a = 13;
int i = 0;
while ( i < 8 )
  printf("a的第 %d 位 为：%d \n", i, (a | 1 << i++) == a);
分析：
1去探测每一位，每一位只有0/1两种可能，结果只有一种可能，就是1，然后去和原数比较，一样则是1，反之0
我一直不懂的原因是：为什么可以拿去和原数进行比较？
因为二进制中每一位只有0、1两种可能，这里是转化|一位二进制到和原数进行比较
```

#### ii) c程序设计 位

```c
      16          2
       1		0001
       2		0010
       3		0011
       4		0100
       5		0101
       6		0110
       7		0111
       8		1000
       9		1001
       a		1010
       b		1011
       c		1100
       d		1101
       e		1110
       f		1111
       
```

```c
	& 按位与
      性质：
      0&0 = 0 与0 被赋值成0 即擦除
      1&0 = 0 与0 被赋值成0 即擦除
      0&1 = 0 与1 得原结果
      1&1 = 1 与1 得原结果
      应用：
      1. 清零。如果想将一个单元某几位清零，即让其全部二进制为0，只要找一个二进制数，其中各个位符合以下条件：新数中对应位是0，其他不需要清零的位是1，和原二进制数进行&运算，即达到清零的目的。例：改变第三位 1111 1101 第三位清零，从0开始数，想要变成：1111 0101 ，我们只需要 &1111 0111 即可。
      2. 取一个数中指定位。例：一个整数a，2个字节，想要去除低字节的位，只需要a&1111 1111即可。(回看&性质，因为是1，最后的结果完全是a的位决定的，所有可以取出来)
      3. 想保留哪几位(和上面一个意思)。&，保留位是1，其他位是0，就只留下了想要的几位。例：保留1 3 5 7位，另一个数的1 3 5 7位也是1，其他位是0，即可。
      
	| 按位或
      性质：
      0|0 = 0 与0 得原结果
      1|0 = 0 与0 得原结果
      0|1 = 0 与1 被赋值成1
      1|1 = 1 与1 被赋值成1
      应用：
      按位或运算常用来对一个数据的某些位设成1.例：把0000 0100都变成1，只需要 |1111 1111，即可。如果想保留其他位，其他位设成0。
      
     ^ 按位异或
      性质：
      0^0 = 0 与0 得原结果
      1^0 = 1 与0 得原结果
      0^1 = 1 与1 取反值
      1^1 = 0 与1 取反值
      应用：
      异或用来判断两个相等位是否为异，为异则1，为同则0.
      1. 与1相^，使特定为翻转
      2. 与0相^，保留原值
      3. 交换两个值，不用临时变量
      
        int a = 3;
        int b = 4;
	    a = a ^ b;
        b = b ^ a;
			// b = b^(a^b)
			//   = b^a^b
			//   = (b^b)^a
			//   = 0^a
			//   = a
        a = a ^ b;
		   // a = (a^b)^(b^(a^b))
            //   = a^b^b^a^b
            //   = a^(b^b)^a^b
            //   = a^0^a^b
            //   = a^a^b
            //   = 0^b
            //   = b

	~按位取反
		&可以实现同样效果
		
	<< *2
      	高位左移后溢出，舍弃
      	
     >> /2
      	移动右端的低位被舍弃，在右移时，需要注意符号位问题。对无符号数，右移时左边高位移入0，
	对有符号的值，如果原来符号位为0(该数为正)，则左边也是移入0。如果符号位原来为1(即负数)，则左边移入还是1，要取决于所用的计算机系统。有的系统移入0，有的移入1。
	移入0的称为逻辑右移，即简单右移
	移入1的称为算术右移 √
		int a = 0x8000 0001; ？？
	// 10000000 00000000 00000000 00000001
	// 01111111 11111111 11111111 11111111
	a >>= 1;
	//  01000000 00000000 00000000 00000000
	// 11000000 00000000 00000000 00000000
	printf("%x \n", a);
	// c000... 
```

#### iii) 位运算练习

```c
1. 取一个整数a从右端开始的4~7位
		unsigned int a;
		scanf("%x", &a);
		unsigned int b;
		b = 15; 辅助数 000... 00001111
		b<<=4;  制造辅助数1 聪明阿 这就利用上了
		printf("%x \n", a&b); // 20(16进制) 32(十进制)

		b=~(~0<<4); 制造辅助数2 0000...1111  15
		printf("%x \n", (a>>4)&b);

2. 循环移位。。要求将a进行右循环移位，将a右循环移n位，即将a中 原来左面(16-n)位右移n位，原来右端n位移到最左面n位
		unsigned short int a;
		scanf("%x", &a); ox1234 00010010 00110100
		int n;
		scanf("%d", &n); 4

		unsigned short int b, c;
		b = a>>n;  00000001 00100011

		c=a<<(16-n);
			01000000 00000000 左移12位后 c
			00000001 00100011 b
			01000001 00100011 |
			4123 秒阿 
		printf("%x \n". b|c); 

3. 位运算三大算法
	1. 探测某x位是不是1：n & 1<<x 与因子相等或者不等于0
		bool b = (n & 1 << x) != 0;
		其他几种方法
	2. 某x位添加1：n | 1<<x 
		n|= 1<<x;
		^也可以
	3. 挖掉某个位是1：c &= ~(1<<x)
  		00000000 0001 1
  		00000000 1000 1<<3 (3=x)
  		11111111 0111 ~(1<<3)
  		11111111 0111 辅助数
  		与c做 & 运算，即可
  		
```



###  4. 赋值操作符

= += -= /= *= >>= &= |=

### 5. 单目操作符

```c
a+b + 双目操作符
!     逻辑反操作
-     负值
+     正值
&     取地址
sizeof 操作数的类型长度(字节为单位)
~	  对一个数的二进制按位取反
--
++    前置++ 后置++
*     间接访问操作符
(类型)强制类型转换

注：sizeof(类型) 后面是类型的话，不能省略括号。

例1：
short s = 0;
int a = 10;
printf("%d\n", sizeof(s = a + 5)); // 2
printf("%d\n", s); // 0 上面a+5不参与运算，不会改变s值
编译器报错的，理论分析。

~ 按2进制位取反
例2：
int a = 0;
printf("%d \n", ~a); // -1
分析：
00000000 00000000 00000000 00000000 0补码

11111111 11111111 11111111 11111111 ~0补码
11111111 11111111 11111111 11111110 反码
10000000 00000000 00000000 00000001 原码 ->-1
  
例3：
int a = 11;
a = a | (1 << 2);
printf("%d \n", a);
分析：
1011 a补码
0001 -> 100 即1*2*2=4
0100 4补码
1111 逻辑或得 15
  
例4：
int a = 10;
printf("%d \n", ++a); // 11
printf("%d \n", a++); // 11

例5：
int a = 3.14; // 这种情况编译器会报警告，3.14这里默认是double类型，赋值给int型，可能会丢失精度
int a = (int)3.14;


```

### 6. 关系操作符

### 7. 逻辑操作符(位操作符是二进制)

```c
&& || !
&&、|| 和 ！的优先级: ! > && > ||
  
例1：
int a = 3;
int b = 5;
int c = a && b;
printf("%d \n", c); // 1 编译器报了个瞎波浪线

例2：
int a = 0;
int b = 5;
int c = a && b;
printf("%d \n", c); // 0

例3：
int a = 0;
int b = 5;
int c = a || b;
printf("%d \n", c); // 1

例4：
int a = 0;
int b = 0;
int c = a || b;
printf("%d\n", c); // 0

例5：
int i = 0,
    a = 0,
    b = 2,
    c = 3,
    d = 4;
i = a++ && ++b && d++;
printf("%d %d %d %d", a, b, c, d);
// 1 3 3 5 我得答案。错误
// 1 2 3 4 问题在于a++，&&遇到是假，后面都不会执行了，这是第一个就是假。

例6：
int i = 0,
    a = 1, // 改成1了
    b = 2,
    c = 3,
    d = 4;
i = a++ && ++b && d++;
printf("%d %d %d %d", a, b, c, d); 
// 2 3 3 5

例7：
int i = 0,
    a = 0,
    b = 2,
    c = 3,
    d = 4;
i = a++ || ++b || d++;
printf("%d %d %d %d", a, b, c, d);
// 1 3 3 4 ||遇到是真，后面都不会执行了，这是第一个就是真。

例8：
int i = 0,
    a = 1,
    b = 2,
    c = 3,
    d = 4;
i = a++ || ++b || d++;
printf("%d %d %d %d", a, b, c, d);
// 2 2 3 4 依然要记住：||遇到真后面就不执行了
```

### 8. 条件操作符

```c
exp1 ? exp2 : exp3;

if ( a>5 )
  b = 3;
else 
  b = -3;

->
b = (a>5 ? 3 : -3);  
```

### 9. 逗号操作符

```c
// 用逗号隔开得多个表达式
// 自左向右一次执行
// 整个表示得结果是 最后一个表示式的结果

例1：
int a = 1;
int b = 2;
int c = ( a>b, a=b+10, a, b=a+1 ); 
printf("%d \n", c); // 13 

例2：
if ( a=b+1, c=a/2, d>0 )
{
  
}

例3：
a = get_val();
count_val(a);
while ( a>0 )
{
  a = get_val();
  count_val(a);
}
改写：不推荐这样写
whie ( 
  a=get_val(),
  count_val(a),
  a>0
)
{
  
}
```



### 10. 下标引用、函数调用和结构成员

```c
1. []下标引用操作符
	操作数：数组名 + 索引值
	int arr[10];
	arr[9] = 10; // []的两个操作数是arr和9 

2. ()函数调用操作符
	get_max(a, b);

3. . 访问一个结构的成员
	.结构体.成员名
	->结构体指针->成员名
	struct Stu 
    {
      char name[20];
      int age;
      char id[20];
    };
	int main ()
    {
      struct Stu s1 = {"张三", 20, "2341"};
      printf("%s \n", s1.name);
      
      struct Stu *ps = &s1;
      printf("%s \n", (*ps).name);
      printf("%s \n", ps->name);
    }
```

### 11. 表达式求值

``` c
表达式求值的顺序一部分是由操作符的优先级和结合性决定。
同样，有些表达式的操作数在求值的过程中可能需要转换为其他数据类型。

为了获得精度，表达式中的字符和短整型操作数在使用之前 被转换为普通整型，这种转换称为整型提升。

例1：！！！
char a, b, c;
a = b + c;
// 说明：b和c值被提升为普通类型，然后执行加法运算，加法完成后，结果将被阶段，再存于a中

// 如何进行整型(整体)提升呢？
// 按照变量的数据类型的符号位来提升
char c = -1;
1111 1111 c补码
// 因为char是有符号的char，所以整型提升的时候，高位补充符号位，即1
11111111 11111111 11111111 11111111 提升后的补码

char a = 3;
char b = 127;
char c = a + b;
printf("%d \n", c);
分析：
0000 0011 a补码
0111 1111 b补码 
00000000 00000000 00000000 00000011 a补码
00000000 00000000 00000000 01111111 b补码
00000000 00000000 00000000 10000010 相加
因为c是char型，只要八位 10000010
又因为这里打印十进制%d，需要前面补充数？
前面补充1或者0 根据符号位来补
11111111 11111111 11111111 10000010 补后补码
11111111 11111111 11111111 10000001 反码
10000000 00000000 00000000 01111110 原码
-126 (64+32+16+8+4+2)
  
如果是无符号数，直接前面补充0，这里是说的打印时候吗？？？

整型提升的意义：
表达式得整型运算在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度。一般就是int的字节长度，同时也是CPU的通用寄存器的长度。因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。
通用CPU是难以直接实现两个8比特字节直接相加运算，(虽然机器指令中可能有这种字节相加指令)。所以，表达式各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int,然后才能送入CPU去执行运算。

例2：
char a = 0xb6;
short b = 0xb600;
int c = 0xb6000000;

if ( a == 0xb6 ) // 前面会补0 不相等
  printf("a1 \n");
if ( a == 0xb600 ) // 不相等
  printf("a2 \n");
if ( a == 0xb6000000 ) // 相等 但是编译器？？
  printf("a3 \n");

例3：
char c = 1;
printf("%u \n", sizeof(c)); // 1
printf("%u \n", sizeof(+c)); // 4 char型c只要参与表达式运算，就会发生整型提升，所以sizeof是4个字节 -+c
printf("%u \n", sizeof(!c)); // 1


算术转换
也是一种隐式转换。
隐式转换：整型提升 算术转换
描述：如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数转换为另一个操作数。否则操作是无法进行的。
long double 
double 
float 
unsigned long int 
long int 
unsigned int 
int 
(下 转 上)
注：如果某个操作数的类型再上面这个列表中排名较低，首先要转换为另外一个操作数的类型后再运算。但是算术转换要合理，不然会有潜在风险。

小结：复杂表达式的求值又三个影响的因素：
	1. 操作符的优先级
	2. 操作符的结合性(NA(无结合性) LR RL)
	3. 是否控制求值顺序
   
问题表达式：
例1：
a*b + c*d + e*f
分析：
表达式的求值部分由操作符的优先级决定。
在计算的时候，由于比+的优先级高，只能保证*的计算比+早，但是优先级并不能决定第三个*比第一个+早执行。
我们无法让它有一个唯一的计算路径，不同的编译器可能不同的。
表达式的计算机顺序可能是：
a*b 
c*d 
a*b + c*d 
e*f 
a*b + c*d + e*f 
或者：
a*b 
c*d 
e*f 

例2：
c + --c;
分析：
操作符的优先级只能决定自减--的运算在+的运算的前面。
但是我们并没有办法得知，+操作符的左操作数的获取在右操作数之前还是之后求值，所以结果是不可预测的，是有歧义的。
如果c是1，先左边c赋值成c,然后再执行--c 得0 1+0=1 。
如果先计算--c 0 然后0赋值给左边的c 得0+0=0 。
在于+操作符的左操作数的获取在右操作数之前还是之后求值，所以结果是不可预测的。

例3：
非法表达式：
int main ()
{
    int i = 10;
    i = i-- - --i * ( i = -3 ) * i++ + ++i;
    printf("i= %d\n", i);
    return 0;
}
值      编译器
-128  Tandy 6000...
-95   Think..
-86   IBM...
-63   gcc 
...
21    Turbo C/C++..
...
不同编译器都不一样。
因为计算的顺序不一致。导致的。

例4：
int fun ()
{
    static int count = 1;
    return ++count;
}
int main ()
{
    int answer;
    answer = fun() = fun() * fun();
    printf("%d\n", answer); ?
    return 0;
}
让你先算乘法还是减法是可以的，但是3个fun()谁先执行？
2-3*4 
4-2*3 
计算顺序不是唯一的。
函数的调用先后顺序无法通过操作符的优先级确定。

例5：
int main ()
{
    int i = 1;
    int ret = (++i) + (++i) + (++i);
    printf("%d\n", ret);
    printf("%d\n", i);
    return 0;
}
尝试在linux 环境gcc编译器，vs2013环境下都执行，看结果 
视频编译器 12 
linxu     10 
同样的代码产生了不同的结果，这是为什么？
简单看一下汇编代码，就可以分析清楚。
这段代码中的第一个+在执行的时候，第三个++是否执行，这是不确定的，因为依靠操作符的优先级和结合性是无法决定第一个+和第三个前置++的先后顺序。

总结：我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那么这个表达式就是有问题的。
```

## (四) 指针

### 1. 初级指针

#### 1.1 指针是什么

在计算机科学中，指针是编程语言中的一个对象，它的值直接指向存在电脑寄存器中的一个地方的值。

由于通过地址能找到所需要的变量单元，可以说，地址指向该变量单元。

因此，将地址形象化的称为指针，意思是通过它能找到这个地址所在的内存单元。

说指针，先说内存，思考是如何找到地址的，地址具体又是什么呢？

为了合理利用内存，把内存划分成一个一个小的单元，然后逐一编号，这个编号就被称为地址。

那编号是如何产生的呢？

电脑有地址线(多少位机决定的)，通电能产生电信号，电信号转换成数字信号。电信号产生的二进制序列，这个二进制序列就作为一个内存单元的编号。

那一个内存单元多大最好呢？

最好是一个字节，比较合适的。比特视频详细计算过的。

```c
// 如何编址?
// 对于32位的机器，假设有32根地址线，假设每根地址线在寻址时产生的一个电信号-正电/负电 1/0
// 那么32根地址线产生的地址就会是下面这些：
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000001
  ...
11111111 11111111 11111111 11111111
// 总共是：2^32次方个地址
// 每个地址表示一个字节，那么我们可以给
// (
//  2^32Byte == 2^32/1024kb == 2^32/1024/1024mb == 2^32/1024/1024/1024gb == 4G
// ) 的空闲地址编址。
// 64位机同理。
  
// 从这里可以得出：
// 1. 32位的机器上，地址是32个0或1组成的二进制序列，地址，我们用4个字节即可存储。也就是一个指针变量的大小就是4个字节。64位机则是8个字节。
// 2. 指针是用来存放地址的，地址是唯一标识一块地址空间的。指针的大小在32位机是4个字节，64位机是8个字节。
// 测试
printf("%d\n", sizeof(char *));
printf("%d\n", sizeof(short *));
printf("%d\n", sizeof(int *));
printf("%d\n", sizeof(double *));
// 都是4，因为视频中是32位机，这和数据类型无关的。提出一个问题，指针既然都是4个字节，为什么还要区分类型呢？int* char*呢？
```

#### 1.2 指针和指针类型

```c
int a = 0x11223344; // 不会溢出哈
int *pa = &a;
char *pc = &a;
printf("%p\n", pa); 一样
printf("%p\n", pc); 一样
你就会思考地址打印都一样，那类型有什么用呢？

int a = 0x11223344;
int *pa = &a;
*pa = 0; 把地址赋值成0 请去vs查看内存变化
0x00EFF880 44 33 22 11 
0x00EFF880 00 00 00 00

int a = 0x11223344;
char *pa = &a;
*pc = 0; 把地址赋值成0 请去vs查看内存变化
0x00EFF880 44 33 22 11 
0x00EFF880 00 33 22 11
  
对比上面两处赋值0后的内存数据，发现问题了吗？
int型指针，解引用赋值为0，4个字节全部变成了0，
char型指针，解引用赋值为0，1个字节变成了0.
这便是不同的类型的指针，可以访问的内存不同。
char型指针可以访问1个字节，int型指针可以访问4个字节，double型指针可以访问8个字节。
即：指针的类型决定了，对指针解引用的时候有多大的权限，能操作几个字节。
```

指针类型的另外一个意义：指针+整数

```c
int a = 0x11223344;
int *pa = &a;
char *pc = &a;
printf("%p\n", pa);   0095FB58
printf("%p\n", pa+1); 0095FB5C  +4

printf("%p\n", pc);   0095FB58
printf("%p\n", pc+1); 0095FB59  +1

即：指针类型决定了，指针走一步多远，指针的步长。

案例：
int arr[10] = { 0 };
int *p = arr; // arr首元素的地址
int i = 0;
for ( i=0; i<10; i++ )
{
  *(p + i) = 1;
}
结果全部赋值成了1.
若 char *p = arr; 则是修改了10个字节成1.看内存。这里总共是40个字节。
```

#### 1.3 野指针

```c
指针指向的位置是不可知的，随机的，不正确的，没有明确限制的。

野指针原因：
1. 指针未初始化
int main ()
{
	int a; // 局部变量不初始化，默认随机值
  	int *p;// 布局指针不初始化，默认随机值
  	*p = 20;
}
2. 指针越界访问
int main ()
{
  int arr[10] = { 0 };
  int *p = arr;
  int i = 0;
  for ( i=0; i<=11; i++ )
  {
    // 当指针指向的范围超出了数组arr下标范围，即野指针
    *(p++) = i;
  }
}
3. 弹出局部地址
int* test ()
{
  int a = 10;
  return &a;
}
int main ()
{
  int *p = test(); // 地址虽然返回给我了，但是test函数执行完毕后，这个地址已经还给OS了，此时再去访问就是非法访问了，即野指针
  *p = 20;
}

如何规避野指针？
1. 指针一定初始化
2. 小心指针越界
3. 指针指向空间释放即置 NULL
4. 指针使用之前检查有效性 
```

临时补充一个点： * ++(前后)优先级

```c
// 前缀++和*优先级相同
// 后缀++比前缀++优先级低

int arr[5] = { 1,3,5,7,9 };
int *p = arr;
printf("%d ", *++p); // 3
printf("%d ", *p++); // 1 第一次，我就是傻B了，把后++搞错了，打印肯定先输出值的，然后再+1.
printf("%d ", (*p)++); // 1
printf("%d ", *(p++); // 1 我做错了，我做成了3，应该是本次表达式p++之后并没有更新 等同于*p++
printf("%d ", ++*p); // 2 
```

#### 1.4 指针运算

1. 指针+-整数

```c
案例1：打印数组
int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
int sz = sizeof(arr) / sizeof(arr[0]);
int *p = arr;
int i = 0;
for ( i=0; i<sz; i++ )
{
  printf("%d ", *p);
  p += 1; // 指针运算，等价于p++；
}
打印：1 2 3 ... 10 
  
案例2: 打印奇数
for ( i=0; i<5; i++ )
{
  printf("%d ", *p);
  p += 2;
}
打印：1 3 5 7 9 
  
案例3：倒序打印偶数
int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
int sz = sizeof(arr) / sizeof(arr[0]);
int *p = &arr[9];
int i = 0;
for ( i=0; i<5; i++ )
{
  printf("%d ", *p);
  p -= 2;
}
打印：10 8 6 4 2
  
案例4：赋初值
#define N_VALUES 5
float values[N_VALUES];
float *vp;

for ( vp=&values[0]; vp<&values[N-VALUES]; )
{
	*vp++ = 0; // * == 前置++ > 后置++
  	// 等价于(*vp)++ 指针不断叠加
}
```

2. 指针-指针

```c
// 得到中间的元素个数
int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
printf("%d \n", &arr[9] - &arr[0]); 9 类似10-1
printf("%d \n", &arr[0] - &arr[9]); -9 
// 大地址 - 小地址 = 中间元素个数
  
案例：求字符串长度
my_strlen (char *str)
{
  char *start = str;
  char *end = str;
  
  while ( *end != '\0' )
  {
  	end++;  
  }
  return end - start;
}
// 测试
char arr[] = "bit";
int len = my_strlen(arr);
printf("%d \n", len); 3 
```

3. 指针的关系运算

```c
代码1：
#define N_VALUES 5
float values[N_VALUES];
float *vp;
for ( vp = &values[N_VALUES]; vp > &values[0]; )
{
    *--vp = 0;  // 先-- 再解引用 
}

代码1改造2：
#define N_VALUES 5
float values[N_VALUES];
float *vp;
for ( vp = &values[N_VALUES]; vp>=&values[0]; vp-- )
{
    *vp = 0;  
}

// 实际上在绝大部分的编译器上是可以顺利完成任务的，然后我们应该避免这样写 改造代码2不建议，因为标准并不保证它可行。
// 标准规定：允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较，非法访问内存。
```

#### 1.5 指针和数组

```c
int arr[10] = { 1, 2 };
printf("第一个元素地址：%p \n", &arr[0]);
printf("第二个元素地址：%p \n", &arr[1]);

printf("%p \n", arr);     // 首元素地址
printf("%p \n", &arr[0]); // 首元素地址
printf("%p \n", &arr);    // 数组地址
printf("%p \n", &arr+1);  // 数组地址 (指针类型即是数组类型) 加了一个数组的字节，即40个字节
printf("%p \n", &arr[0]+1); // 第二个元素地址
printf("%p \n", arr+1);     // 第二个元素地址

// 数组名大部分是首元素地址，2个例外：
1. &数组名 
2. sizeof(数组名)
  
// 数组也可以用指针来访问，也可以下标访问
int arr[10] = { 0 };
int *p = arr;
int i = 0;
for ( i=0; i<10; i++ )
{
  *(p + i) = i;
  // 等价于 p[i] = i;
}
for ( i=0; i<10; i++ )
{
  printf("%d ", *(p + i));
}
```

#### 1.6 二级指针

```c
// 一级指针
int a = 10;
int *pa = &a; // pa就是一级指针变量 int*就是一级指针变量类型

// 二级指针
int a = 10;
int *pa = &a;
int **ppa = &pa; // ppa就是二级指针 int *(*ppa) = &pa
int ***pppa = &ppa; // pppa就是三级指针

// 认识二级指针
// 指针变量也是变量，是变量就有地址，那指针变量的地址存放的变量叫什么？二级指针变量。
int **ppa = &pa;
第一个*表示：pa指向的那个对象类型是int* 
第二个*表示：ppa是一个指针
即：int* (*ppa) = &pa;
第一步：(*ppa)表示这是一个指针
第二步：int*表示这个指针存放的是一个int型指针

printf("%d \n", **ppa); // 10
**ppa = 20;
printf("%d \n", **ppa); // 20
printf("%d \n", a);     // 20

// 辅助内存地址图理解二级指针
代码               存值            地址
int a = 10;       a 10          0x0018ff44
int* pa = &a;    pa 0x0018ff44  0x0018ff40
int** ppa = &pa; ppa 0x0018ff40 0x0018ff3c
```

#### 1.7 指针数组

```c
// 好孩子   - 是孩子 
// 指针数组 - 是数组
// 数组指针 - 是指针

// 整型数组 - 存放整型 
// 字符数组 - 存放字符
// 指针数组 - 存放指针

int main ()
{
  int a = 10;
  int b = 20;
  int c = 30;
  int *pa = &a;
  int *pb = &b;
  int *pc = &c;
  
  int* arr[3] = 
  {
    &a,
    &b,
    &c
  };
  
  int i = 0;
  for ( i=0; i<3; i++ )
  {
	printf("%d ", *(arr[i])); // 10 20 30
  }
}
```

### 2. 进阶指针

#### 2.0 回顾初级指针

```c
1. 指针就是个变量，用来存放地址，地址是唯一表示一块内存
2. 指针的大小是固定的，多少位机决定了几个字节
3. 指针有类型，决定了指针的加减整数的步长，指针解引用操作的访问权限
4. 指针的运算
```

#### 2.1 字符指针

```c
int main ()
{
  char arr[] = "abcef";
  char *pc = arr; // 数组名-首元素地址
  printf("%s \n", arr); // "abcef" 字符指针无需解引用
  printf("%s \n", pc);  // "abcef" 字符指针无需解引用
  
  printf("%s \n", *pc); // 报错？char*只有一个字节的访问权限，非法访问
  printf("%c \n", *pc); // "a"
}

int main ()
{
  char *p = "abcdef"; // 报错 +const
  // ? 报错 右边7个常量字符串，左边指针变量肯定放不下的。而是把'a'首字符的地址赋值给p。
  printf("%c \n", *p); ?
  printf("%s \n", p);  ?
}

int main ()
{
  char *p = "abcdef"; // 报错 +const
  *p = 'W';
  // 这样应该是语法错误的，vs似乎没底线了，linux反正是报错了
  // 报错信息：segmentation fault 段错误 也就是非法内存相关会导致的错误
  // 因为这个 "abcdef"是常量字符串，不能修改的
  
  // 更加规范准确的写法：指向可以变值不能变
  const char *p = "abcdef"; 
}

// 练习题
int main ()
{
    char arr1[] = "abcdef";
    char arr2[] = "abcdef";
    char* p1 = "abcdef"; // 报错？+const
    char *p2 = "abcdef"; // 报错？+const
  
    if ( arr1 == arr2 )
      printf("hehe \n");
    else 
      printf("haha \n");
   // haha 两个不同的数组，不同的空间，不过是存储了相同的内容而已
  
  	if ( p1 == p2 )
      printf("hehe \n");
    else 
      printf("haha \n");
   // hehe "abcdef"常量字符串，不能更改，两份一样的常量字符串，为了节省空间，内存只存了一份，所以相同
}
```

#### 2.2 数组指针 ？一维二维？

```c
// 是指针
int *pint; 指向整型数据的指针，可存放整型的地址
float *pf; 指向浮点型的指针，可存放浮点型的地址
int *parr[10]; 指向数组的指针，可以存放数组的地址

类比1：
int arr[10] = { 0 };
arr后面紧跟[]，表明是一个数组.
10表示是数组有10个元素
int表示这10个元素都是int型 
类比2：[] > *
int (*p)[10] = &arr;
*p先结合表示是一个指针
[10]表示指向一个10个元素的数组
int 数组元素类型是int型

一维数组指针：int *p = &arr;      ?
二维数组指针：int (*p)[3] = &arr; ?不熟悉

案例1：
char* arr[5];
? pa = &arr; // ?是什么类型
char (*pa)[5] = &arr; 错误，我的答案
char *pa = &arr; 似乎也错误
char* (*pa)[5] = &arr; 答案，上面是char*
案例2：
int arr[10] = { 0 };
? pa = &arr;
int (*pa)[10] = &arr; 答案

如何使用呢？
数组指针指向的是数组，存放的是数组的地址。
int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
int (*pa)[10] = &arr;
int i = 0;
for ( i=0; i<10; i++ )
{
  printf("%d ", *(pa + i));
  // 错误 二维数组？ 首元素地址a[0] 第一行的首元素地址 a[1] 第二行的首元素地址 pa+1即第二行钚元素地址 具体拿第二行第几个，即+j列  不对！
  
  printf("%d ", (*pa)[i]); // 1 2 3... 10 这里和上面解释冲突了 ？？
  printf("%d ", *(*pa + i)); // 1 2 3... 10
}
int main ()
{
  int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
  int* p = arr;
  int i = 0;
  for ( i=0; i<10; i++ )
  {
    printf("%d ", *(p + i)); //  1 2 3... 10
  }
}

一个数组指针的使用：至少二维数组以上方便些
void print1 (int arr[3][5], int x, int y)
{
  int i = 0;
  int j = 0;
  for ( i=0; i<x; i++ )
  {
    for ( j=0; j<y; j++ )
    {
      printf("%d ", arr[i][j]);
    }
    printf("\n");
  }
}
void print (int (*p)[5], int x, int y)
{
  int i = 0;
  for ( i=0; i<x; i++ )
  {
    int j = 0;
    for ( j=0; j<y; j++ )
    {
      printf("%d ", *(*(p + i) + j));
      printf("%d ", (*(p + i))[j]);
      // *(p[i] + j)
      // p[i][j]
    }
  }
}
int main ()
{
  int arr[3][5] = {
          { 1,2,3,4,5 },
          { 2,3,4,5,6 },
          { 3,4,5,6,7 } 
  }
  print(arr, 3, 5);
  print(arr, 3, 5);
}

补充一个：
int arr[4] = { 1,2,3,4 };
int *p = arr;
int i = 0;
for ( i=0; i<10; i++ )
{
  // arr == p
  printf("%d ", *(p + i));
  printf("%d ", *(arr + i));
  printf("%d ", arr[i]);
  printf("%d ", p[i]);
  // arr[i] == *(arr+i) == *(p+i) == p[i]
}

练习：
[] > *
int arr[5];
// 一个数组，5个元素，int型。arr是一个5个元素的整型数组。
int* parr[10];
// []>* 一个数组，10个元素，int*型。指针数组。
int (*parr)[10];
// 一个指针，[]指向一个数组，10个元素，int型，数组指针。
int (*parr[10])[5];
// 一个数组，10个元素，int * [5]型，即5个整型数组指针。指针数组。10个元素，每个元素是一个数组指针，指针指向一个5个元素的数组，每个元素是int型。  不熟悉！
// parr[10]表明是一个数组，指向int(*)[5]，*表示存放的是指针，指向int[5]，一个有5个整型元素的数组。
```



#### 2.3 指针数组

```c
// 是数组，用来存放指针的
int arr[10] = { 0 }; 整型数组
char ch[5] = { 0 };  字符数组
int* parr[4];        整型数组
char* pch[5];	 字符指针数组
char** arr[5]; 二级字符指针数组

案例1：
int main ()
{
    int a = 10;
    int b = 20;
    int c = 30;
    int d = 40;
    int* arr[4] = {
        &a,
        &b,
        &c,
        &d
    };
    int i = 0;
    for ( i=0; i<4; i++ )
    {
        printf("%d ", *(arr[i])); // 10 20 30 40
    }
}

例子2：指针实际用法
int arr1[] = { 1,2,3,4,5 };
int arr2[] = { 2,3,4,5,6 };
int arr3[] = { 3,4,5,6,7 };
int* parr[] = { arr1, arr2, arr3 };

int i= 0;
for ( i=0; i<3; i++ )
{
  int j = 0;
  for ( j=0; j<5; j++ )
    printf("%d ", *(parr[i]+j));
}
```



#### 2.4 数组传参和指针传参

```c
// 写代码的时候难免要把数组或指针传给函数，那函数的参数如何设计呢？

// 一维数组传参
#include <stdio.h>
void test (int arr[]) {}
void test (int arr[10]) {} 10写不写无所谓
void test (int *arr) {}    首元素地址 这就是个指针，首元素误解
void test2 (int *arr[20]) {}
void test2 (int **arr) {}  二级指针
int main ()
{
	int arr[10] = { 0 };
  	int* arr2[20] = { 0 };
  	test (arr);
  	test2 (arr2);
}

// 二级数组传参
// 注：二维数组传参，函数形参的设计只能是省略第一个[]内的数，因为对一个二维数组，可以不知道多少行，但一定要知道多少列
void test (int arr[3][5]) {}
void test (int arr[][]) {}   ×
void test (int arr[][5]) {}
void test (int *arr) {}      ×  // 二维数组的数组名表示是第一行的地址，首元素的地址应该是第一行的地址
void test (int* arr[5]) {}   ×
void test (int (*arr)[5]) {}
void test (int **arr) {}     × // 二级指针应存放一级指针变量，数组地址无法存入
int main ()
{
  int arr[3][5] = { 0 };
  test(arr);
}

// 例1
#include <stdio.h>
void print (int *p, int sz)
{
	int i = 0;
  	for (i=0; i<sz; ++i)
    {
		printf("%d \n", *(p+i));
    }
}
int main ()
{
	int arr[10] = { 1,2,3,4,5 };
  	int *p = arr;
  	int sz = sizeof(arr) / sizeof(arr[0]);
  	print(p, sz);
}

// 例2：
// 思考：当一个函数的参数部分是一级指针的时候，函数能接收什么参数呢？
void test (int *p) {}
void test2 (char *p) {}
int main ()
{
  int a = 10;
  int *p1 = &a;
  test(&a); // 地址可传 
  test(p1); // 一级指针？是。二级指针存放的是一级指针的地址，不是存放一级指针本身
  
  char ch = 'w';
  char *pc = &ch;
  test2(&ch);
  test2(pc);
}

// 例3
// 二级指针传参
void test (int** ptr)
{
	printf("num=%d \n", **ptr);
}
int main ()
{
	int n = 10;
  	int *p = &n;
  	int* *pp = &p;
  	test(pp);
  	test(&p);
  
  	int* arr[10]; // 存了10个指针变量
  	test(arr);	  // 首元素地址 指针变量的地址 需要二级指针类型接收
}
```

#### 2.5 函数指针

```c
// 数组指针- 指向数组的指针
// 函数指针- 指向函数的指针 存放函数地址的一个指针

int Add (int x, int y)
{
	int z = 0;
  	z = x + y;
  	return z;
}
int main ()
{
  int a = 10;
  int b = 20;
  printf("%d \n", Add(a, b));
  printf("%p \n", &Add); // 009110E1 Add函数的地址
  printf("%p\n", Add);   // 009110E1
  // &函数名 和 函数名 都是函数的地址 没有什么首元素
}

// 如何存函数地址呢？
// pa = Add; pa类型如何写呢 ？
int (*pa)(int, int) = Add;
int (*pa)(int x, int y) = Add; // x y 写不写无所谓
// (*pa)- 表明是一个指针
// 然后后面(int, int)一个圆括号表明是一个函数
// 然后两个形参类型
// 前面的int 表示函数的返回值类型

// pa是不是原来的函数呢，验证？调用
(*pa)(2, 3);
printf("%d \n", (*pa)(2, 3)); // 5

// 不同类型函数，函数指针定义区别？
void print (char *str)
{
	printf("%s \n", str);
}
int main ()
{
  void (*p)(char*) = print;
  (*p)("hello bit"); // 打印
}

// 例1
void test ()
{
	printf("hehe \n");
}
// pfun1 pfun2谁能存放test函数地址？
void (*pfun1)();
	√ pfun1先和*结合，说明是一个指针
	后面()，说明指针指向的是一个函数
	()里面没有，说明函数没有形参
	返回值类型是void
void *pfun2();
	× 只是一个函数名而已
	
// 例2：
// 前置知识1
// int (*p)[10] = &arr;
// (*p)表示p是一个指针变量
// 然后[]，指针指向一个数组
// int 数组每个元素是int
// 当我把p去掉，剩下就是它的类型： int(*)[10] 即数组指针

// 前置知识2
// void Print (char *str)
// {
// 	printf("%s \n", str);
// }
// void (*p)(char*) = Print;
// 同上，去掉p后，剩下就是类型: void(*)(char*) 即函数指针

// <<c陷阱和缺陷>>
(*(void (*)())0)();
void (*signal(int, void(*)(int)))(int);
// 里面(*)，表示是一个指针，指向什么？
// 然后()，指向一个函数
// void，函数返回值类型
// (*(type)0)() 把一个类型放在括号里，这叫强制类型转换
// 把 0 强制转换成函数指针类型
// 前面的*，解引用函数地址，最后面的()，调用函数
// 小结：把 0 强制转换成函数指针类型，0 就是函数的地址，调用 0 地址处的该函数。总会一句话，上面代码就是函数调用，调用0地址处的一个返回值类型是void的无参函数

void (*signal(int, void(*)(int)))(int);
// signal是一个函数声明
// signal函数的参数有2个，第一个是int.第二个是函数指针，该函数指针指向的函数的参数是int 返回类型是void
// signal函数的返回类型也是一个函数指针：该函数指针指向的函数的参数是int,返回类型是void 
// 啰里啰唆解析：
// 从名字入手 signal 后面紧跟一个() 那这里是一个函数
// signal(int, void(*)(int)) 第一个参数是整型 第二个参数是函数指针类型
// 这里函数名确定了 函数参数确定了 那返回类型呢？
// 类似：int Add (int, int) 我们把Add(int, int)去掉之后 剩下前面的那个int 就是返回类型 
// 这里剩下 void(*  )(int) 这颗*放在()里面的，说明它是一个指针，后面紧着一个()，说明是一个函数
// void(*  )(int) 这是返回类型 函数的返回类型也是一个函数指针类型
// 提问？
// 为什么不这样写呢？
// void(*)(int) signal(int, void(*)(int)) ??
// 函数指针类型不能这样写的，void(*)(int)
// *需要靠近名字 所以这里需要拆开 
// void(*) signal(int, void(*)(int)) (int)
// 把函数名和参数类型 放在这两个的中间 然后*就和名字放在一起了
// 总结：参数是函数指针，返回类型也是函数指针，然后写法*要和名字挨在一起

// 上面写法太复杂了，有什么办法简化？
// typedef void(*)(int) pfun_t; 起别名 不是这样写的
// typedef void(* pfun_t)(int); ?
// typedef unsigned int uint;

// pfun_t signal(int, pfun_t); 改成这样就简单多了
```

```c
// 函数指针知识点2
// 注：*优先级较低 []优先级比*高
int Add (int x, int y)
{
    int z = 0;
    z = x + y;
    return z;
}
int main ()
{
	int a = 10;
  	int b = 20;
  
  	int(*pa)(int, int) = Add;
  		// 如果pa是一个函数指针，调用时，可解引用，可不解
  	printf("%d\n", (pa)(2, 3)); 5
    printf("%d\n", (*pa)(2, 3)); 5
    printf("%d\n", (**pa)(2, 3)); 5 *都是多余的
    printf("%d\n", (***pa)(2, 3)); 5 *都是多余的
      
    printf("%d\n", *pa(2, 3)); × *优先级低 先产生了5 然后*5 解引用5 报错了
}
```



#### 2.6 函数指针数组

```c
// 应用：转移表

int Add (int x, int y)
{
    return x + y;
}
int Sub (int x, int y)
{
    return x - y;
}
int Mul (int x, int y)
{
    return x * y;
}

int main ()
{
	int* arr[5]; 指针数组
    int (*pa)(int, int) = Add; 函数指针 
    // 能不能把Sub Mul几个函数也存到上面？
    // 因为参数和返回类型都是一样的
    // 这个时候发现需要一个数组，这个数组可以存放3个函数地址  即存放函数指针的数组
      
    // 如何改造呢？
    int(*)(int, int) 函数指针类型 
    int(* parr[3])(int, int) parr是一个数组 3个元素 每个元素是一个函数指针类型  即parr就是一个函数指针的数组 
    int *parr2[10](); 错误
    int (*)() parr3[10]; 错误
    int (*parr1[10])(); parr1先和[]结合，说明是一个数组，元素类型是？int(*)()类型的函数指针 注：[]优先级比*高
      
    // 如何使用呢？
    int i = 0;
    for ( i=0; i<4; i++ )
    {
      parr[i](); 调用时可以不写解引用 函数指针 
      printf("%d\n", parr[i](2, 3)); 5 -1 6
    }
}

// 例1
char* my_strcpy (char* dest, const char* src) {}
  写一个函数指针pf,能够指向 my_strcpy?
    char* (*pf)(char*, const char*);
  写一个函数指针数组pfArr，能够存放4个 my_strcpy函数的地址？
  	char* (*pfArr[4])(char*, const char*);

// 例2
// 计算器-旧版
void menu ()
{
    printf("*******************\n");
    printf("***1. add    2. sub****\n");
    printf("***2. mul  4. div *****\n");
    printf("***** 0.exit ****\n");
    printf("*******************\n");
}
int Add (int x, int y)
{
    return x + y;
}
int Sub (int x, int y)
{
    return x - y;
}
int Mul (int x, int y)
{
    return x * y;
}
int Div (int x, int y)
{
    return x / y;
}
int main ()
{
    int input = 0;
    int x = 0;
    int y = 0;
    do  
    {
        menu();
        printf("请选择:>");
        scanf("%d", &input);
        printf("请输入两个操作数:>");
        scanf("%d%d", &x, &y);
        switch (input)
        { 
            以后拓展了 有其他运算了 继续case???越来越长了 不合理啊这个

            case 1:
            	printf("请输入两个操作数:>");
            	scanf("%d%d", &x, &y);
                printf("%d\n", Add(x, y));
                break;
            case 2:
                printf("请输入两个操作数:>");
                scanf("%d%d", &x, &y);
                printf("%d\n", Sub(x, y));
                break;
            case 3:
                printf("请输入两个操作数:>");
                scanf("%d%d", &x, &y);
                printf("%d\n", Mul(x, y));
                break;
            case 4:
                printf("请输入两个操作数:>");
                scanf("%d%d", &x, &y);
                printf("%d\n", Div(x, y));
                break;
            case 0:
                printf("退出\n");
                break;
            default:
                printf("选择错误\n");
                break;
        }
    } while (input);
}

// 计算器-新版
int main ()
{
    int input = 0;
    int x = 0;
    int y = 0;
    // pfArr 我们希望这个数组可以存放上面几个函数的地址
    // 所以，这里就用到了函数指针！！！
    int (*pfArr[5])(int, int) = { 0, Add, Sub, Mul, Div };  // 这样和选择的数字对应了
    do
    {
        menu();
        printf("请选择》");
        scanf("%d", &input);
        if ( input >= 1 && input <= 4 )
        {
            printf("请输入两个操作数！");
            scanf("%d%d", &x, &y);
            int ret = pfArr[input](x, y);
            printf("%d\n", ret);
        }
        else if ( input == 0 )
        {
            printf("退出\n");
        }
        else 
        {
            printf("选择错误\n");
        }
        
    } while ( input );
}

// 这样后面即使你加了函数，比如:
int XOR (int x, int y)
{
    return x + y;
}
// 我们只需要加上这个函数名
int (*pfArr[5])(int, int) = { 0, Add, Sub, Mul, Div, XOR }; // 这样和选择的数字对应了
// 然后在选择******那里加上这个选项即可。

// 这里pfArr就是一个函数指针数组，通过下标找到元素，再去找元素所指向的函数，我们通常把这样的函数指针数组叫做转义表。
```



#### 2.7 指向(函数指针数组)的指针

```c
// 指向函数指针数组的指针是一个 指针
// 指针指向一个数组，数组的元素都是函数指针

// 回调函数
// 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针(地址)作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。
// 回调函数不是由该函数的实现方直接调用，而是在特定的条件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。

// 例1
// 对计算机案例 case代码改造
void Calc (int (*pf)(int, int)) 函数地址形参
{
    int x = 0;
    int y = 0;
    printf("请输入两个操作数：>");
    scanf("%d%d", &x, &y);
    printf("%d\n", pf(x, y));
}
case 1:
    Calc(Add); 代码放在这里面了
    break;
case 2:
    Calc(Sub);
    break;
...
  
// 例2
int main ()
{
  int arr[10] = { 0 };
  int (*p)[10] = &arr; ?
  
  int (*pfArr[4])(int, int); // pfArr是一个数组，函数指针的数组
  int (*(*ppfArr)[4])(int, int) = &pfArr; ? // (*pfArr)-指针 [4]-数组指针，4个元素  int (*)(int, int)-元素类型是函数
  &数组名，函数指针的数组也是一个数组，这里拿到数组地址之后 需要一个数组指针里面去 ppfArr是一个指向函数指针数组的 指针 
}

// 例3
void print(char *str)
{
    printf("hehe: %s", str);
}
// *p表示是一个指针  后面紧跟一个圆括号表明是一个函数指针 函数的形参是char*类型 返回类型是void
void test (void (*p)(char*))
{
  p("bit");
}
int main ()
{
    test(print);
    return 0;
}

// 例4
// 之前冒泡排序函数 只能排序整型数组 
// 注：接收数组名 可以是一个具体的类型int arr[]，也可以是一个指针类型的，int* parr;
void BubbleSort (int arr[], int sz)
{

}
int main ()
{
    int arr[] = { 1,3,5... };
    int sz = sizeof(arr ) / sizeof(arr[0]);
    BubbleSort(arr, sz);
}
// 现在有一组浮点数，如何排序呢？
// 库里面有个函数 qsort 什么类型都可以排序 视频让自己去研究这个函数 
```



#### 2.8 回调函数

```c
// qsort 快速排序
void qsort (void *base
            size_t num,
            size_t width,
            int(*compare)(const void *e1, const void *e2)
            )
int(*compare)(const void *e1, const void *e2)
  // *compare表明是一个指针 后面紧着一个()表明指向一个函数
  // 函数2个参数 返回类型是int 
  // 这就应该传一个函数地址进去
  
// void*
// 没有任何类型的指针 可以接收任意类型的地址 任何类型都可以赋值给它 
	char ch = 'w';
	void* p = &a;
	p = &ch;

*p = 0;  // 报错，非法间接寻址
		// 因为p是void类型的指针，没有类型 
// 你如何给它解引用呢？
	// 指针类型决定了解引用时候可以访问几个字节
	// 这里连类型都没有，它访问几个内存都不知道，如何解引用呢？
	// 同理，void类型的指针也不能进行+-运送的 p++;

// 总结：
  void* 类型的指针 可以接收任意类型的地址 
  void* 类型的指针 不能进行解引用的操作
  void* 类型的指针 不能进行+-整数的操作
  
// qsort使用：
// 比较两个整型值
int cmp_int (const void* el, const void* e2)
  {
    // 注：形参是 void* el 比较两个整型数值的 所以这里强制转成整型的指针
    // 这个compaare内部封装的规则是： <0 (1<2元素)  0(1=2) >0(1>2)
    return *(int*)e1 - *(int*)e2;
  }
int main ()
{
    qsort(arr, sz, sizeof(arr[0]), cmp_int);
}

// 比较两个浮点数：
int cmp_float (const void*el, const void*e2)
{
	// if else写法
    // if ( *(float*)el - *(float*)el )
    //     return 0;
    // else if (*(float*)el > *(float*)el)
    //     return 1;
    // else 
    //     return -1;
  
  return *(float*)el - *(float*)el;
}
void test2 ()
{
    float f[] = { 9.0,8.0,...4.0 };
    int sz = sizeof(f) / sizeof(f[0]);
    qsort(f, sz, sizeof(f[0]),cmp_float),
    int j = 0;
    for ( j=0; i<sz; j++ )
    {
        printf("%f ", f[j]);
    }
}
int main ()
{
    test2();
}

// 例1
int cmp_str_by_age (const void* e1, const void* e2)
{
    return ((struct Stu*)e1)->age - ((struct Stu*)e2)->age;
}
int cmp_str_by_name (const void* e1, const void* e2)
{
    // 字符串比较不能直接用> <=来比较，应用strcmp函数
    return strcmp(((struct Stu*)e1)->name - ((struct Stu*)e2)->name);
}
void test3 ()
{
    struct Stu s[3] ={
        { "a", 20 },
        { "b", 30 },
        { "c", 40 }
    };    
    int sz = sizeof(s) / sizeof(s[0]);

    qsort(s, sz, sizeof(s[0]), );
}
```

```c
// 封装可以排序任意类型的冒泡排序：
void Swap (char* buf1, char* buf2, int width)
{
    int i = 0;
    for ( i=0; i<width; i++ )
    {
        交换字符
        这个和js不一样的，这个字符串是数组表示的，一个字符一个数组元素的，所以这里需要遍历
        "abcedf" "uiohkd" 这两个交换 利用了指针的+整数 获取到下一个元素的地址
        char temp = buf1;
        *buf1 = *buf2;
        *buf2 = temp;
        buf1++;
        buf2++;
    }
}

void bubble_sort (void* base, int sz, int width)
{
    int i = 0;
    躺数
    for ( i=0; i<sz-1; i++ )
    {
        每一趟比较的对数
        int j = 0;
        for ( j=0; j<sz-1-i; j++ )
        {
            两个元素的比较
            if ( cmp((char*)base + j*width, (char*)base + (j+1)*width) > 0 )
            {
                交换
                Swap((char*)base + j*width, (char*)base + (j+1)*width), width); 
            }
        }
    }
}
cmp(base, base+1)
cmp(base, (int*)base+1)
cmp(base, (char*)base+width) // ? 秒啊妙啊 先转成char一个字节的 然后乘上传进来的宽度 不就是一个数据类型的字节吗
  
  // 封装难点：
  // 传入的数据类型是任意的？
  // 函数参数类型是任意的？
```



#### 2.9 指针和数组面试题的解析

```c
// 数组首元素地址：(2个例外) 其他情况都是首元素的地址
// 1. sizeof(数组名) - 数组名表示整个数组
// 2. &数组名 - 数组名表示整个数组

// 一维数组
int a[] = { 1,2,3,4 };
printf("%d\n", sizeof(a)); // 16 sizeof(数组名)-计算的是数组总大小-单位是字节  
printf("%d\n", sizeof(a+0)); // 4/8 这里放的不是数组名，而是a+0 这时候的a就是首元素地址 首元素地址+0还是首元素地址 地址视频中是32位机 是4个字节 
printf("%d\n", sizeof(*a)); // 4 数组名表示首元素地址，*a表示首元素-- a不属于数组名两个例外，所以是首元素地址，首元素解引用，则是首元素的字节大小 这里首元素的类型是int 是4个字节
printf("%d\n", sizeof(a+1)); // 4/8?? 第二个元素的地址 这是地址啊 地址 首元素地址+1 地址几个字节就和平台有关了
printf("%d\n", sizeof(a[1])); // 4 第二个元素大小
printf("%d\n", sizeof(&a)); // 4/8 &a取出的是数组的地址，但是数组的地址也是地址，地址的大小就是4/8个字节
printf("%d\n", sizeof(*&a)); // 16 *&抵消了 和第一种写法一样的 &a数组的地址，数组的地址解引用访问的是数组 sizeof计算的就是数组的大小 单位是字节
printf("%d\n", sizeof(&a+1)); // 4/8 &a取出数组的地址 然后+1 跳过一个数组 还是一个地址 只要是地址就是4/8 
printf("%d\n", sizeof(&a[0])); // 4/8 第一个元素的地址？为什么是4/8 这不是地址才有平台相关性吗 这就是地址 傻了
printf("%d\n", sizeof(&a[0]+1)); // 4/8 第二个元素的地址 sizeof(第二个元素的地址) 

// 字符数组
char arr[] = { 'a','b','c','d','e','f' };
printf("%d\n", sizeof(arr)); // 6 sizeof计算机的是数组大小 6*char是1个字节=6
printf("%d\n", sizeof(arr+0)); // 4/8 首元素地址 arr是首元素的地址 arr+0还是首元素的地址 是地址就是4/8个字节 
printf("%d\n", sizeof(*arr)); // 1 arr是首元素的地址 *arr就是首元素 char是1个字节
printf("%d\n", sizeof(arr[1])); // 1 第二个元素大小 
printf("%d\n", sizeof(&arr)); // 4/8 &arr虽然是数组的地址 还是地址啊 4/8
printf("%d\n", sizeof(&arr+1)); // 4/8 &arr+1是跳过整个数组后的地址 地址大小是4/8个字节 
printf("%d\n", sizeof(&arr[0]+1)); // 4/8 sizeof(第二个元素的地址)

// strlen找\0 求字符串长度的
// strlen形参是一个地址啊 
printf("%d\n", strlen(arr)); // 随机值 字符数组里面没有\0 往后面的内存找到\0位为止 
printf("%d\n", strlen(arr+0)); // 随机值 首元素地址+0 还是首元素地址 和上面一样的
printf("%d\n", strlen(*arr));  // err 数组名arr是首元素地址 这里解引用 就是首元素了 但是strlen形参是一个地址啊 这样就不匹配了 
printf("%d\n", strlen(arr[1]));  // err 相当于传了一个'b' 相当于传了一个98 98作为一个地址 还是有问题的
printf("%d\n", strlen(&arr));  // 随机值 和上面第一二的情况一样的
printf("%d\n", strlen(&arr+1));  // 随机值-6 跳过当前一个数组 后面的内存中开始计算 找到\0 因为跳过当前一个数组 会比上面的随机值少6-即数组长度 
printf("%d\n", strlen(&arr[0]+1));  // 随机值-1 第一个字符的地址+1 得到b的地址 然后计算时候就从'b'开始计算了 直到遇到\0 最终长度随机值就会少1的比正常的随机值 因为开始项少了一个

```

```c
// 指针笔试1
// 上节课是 char arr[] = { 'a','b','c','d','e','f' };
char arr[] = "abcdef";

printf("%d\n", sizeof(arr)); 7 7*1=7 sizeof计算的是所占空间的大小 
printf("%d\n", sizeof(arr+0)); 4/8 地址名这里没有特殊2种 所以是首元素地址 首元素地址+0还是首元素地址 算地址大小 4/8
printf("%d\n", sizeof(*arr)); 1 每个元素都是1个字符 首元素字符的大小 
printf("%d\n", sizeof(arr[1])); 1 第二个元素大小 
printf("%d\n", sizeof(&arr)); 4/8 地址大小 数组的地址也是一个地址 VC6.0编译器是有bug-测出来可能是7或者其他值
printf("%d\n", sizeof(&arr + 1)); 4/8 &arr+1是跳过整个数组后的地址，但是也是地址
printf("%d\n", sizeof(&arr[0] + 1)); 4/8 第二个元素地址的大小

printf("%d\n", strlen(arr)); 6 
printf("%d\n", strlen(arr+0)); 6
printf("%d\n", strlen(*arr)); 报错-读取某个内存发生了冲突 这里传的一个'a' 就是97 我把97当成是一个地址来使用 但是这个空间不是我们拥有的空间 非法访问内存 这里传入的不是一个地址 strlen形参是一个地址 从给的那个地址开始往后找 直到\0  
printf("%d\n", strlen(arr[1])); 报错 同上 'b'-98 非法访问内存 
printf("%d\n", strlen(&arr));  6 会有个警告 是数据类型的原因 取出数组的地址 数组指针 char(*p)[7] = &arr;
printf("%d\n", strlen(&arr + 1)); 随机值 跳过这个数组的地址 
printf("%d\n", strlen(&arr[0] + 1));  5 'b'的地址 开始往后数 到\0 就是5个元素

char* p = "abcdef";
p指向的是'a'字符的地址

printf("%d\n", sizeof(p)); 4/8 计算p 一个指针变量的大小
printf("%d\n", sizeof(p + 1)); 4/8 p+1 得到的是字符b的地址
printf("%d\n", sizeof(*p)); 1 *p 就是字符串的第一个字符 - 'a'
printf("%d\n", sizeof(p[0])); 1  可以把这个指针当成数组名 然后[0] [1]这样去访问字符 p[0]==*(p+0) == 'a'  int arr[10]; arr[0] == *(arr+0) 这两种写法是等价的 
printf("%d\n", sizeof(&p)); 4/8
printf("%d\n", sizeof(&p + 1)); 4/8 跳过这个p地址 还是地址 
printf("%d\n", sizeof(&p[0] + 1)); 4/8 &p[0]取出a的地址 然后+1 就是b的地址

printf("%d\n", strlen(p)); 6 
printf("%d\n", strlen(p + 1)); 5 
printf("%d\n", strlen(*p)); err 
printf("%d\n", strlen(p[0])); err 
printf("%d\n", strlen(&p)); 随机值 给了一个p指针的地址 这个本身就是未知的 然后从给的这个地址开始找\0 后面内存未知的 随机值 
printf("%d\n", strlen(&p + 1)); 随机值 同上 不过是开始位置跳过了一段而已 
printf("%d\n", strlen(&p[0] + 1)); 5 

  二维数组
int a[3][4] = { 0 };
printf("%d\n", sizeof(a)); 3*4*4=48
printf("%d\n", sizeof(a[0][0])); 4 
printf("%d\n", sizeof(a[0])); 16 一行的大小 4*4
printf("%d\n", sizeof(a[0] + 1)); 4/8 ？！a[0]放在表达式了，表示的就是首元素地址了，不是一行了，+1就是第二个元素的地址
    printf("%p\n", &a[0][0]); 0133F9C0 首元素地址 
    printf("%p\n", a[0] + 1); 0133F9C4 比上面多了4
printf("%d\n", sizeof(*(a[0] + 1))); 4 上面不是说了吗 a[0]+1是第二个元素的地址 这里解引用 就是第二个元素 求第二个元素的大小 
printf("%d\n", sizeof(a + 1)); 4/8 二维数组数组名表示首元素的地址时，表示的是第一行的地址，类似一行一维数组的地址，所以这里应该是第二行的第一个元素的地址
    printf("%p\n", &a[0][0]); 005FFD00 第一个元素
    printf("%p\n", a[0] + 1); 005FFD04
    printf("%p\n", a + 1);    005FFD10 第四个元素 这多了16个字节 也就是抽象的第二行第一个
printf("%d\n", sizeof(*(a + 1))); 16 我差点以为是4了 上面说了啊，第二行的地址，第二行整个的大小 这里相当于sizeof(a[1])
printf("%d\n", sizeof(&a[0] + 1)); 4 第二行的地址 第一行的地址+1 就是第二行的地址
printf("%d\n", sizeof(*(&a[0] + 1))); 16 和上面16一样的 整行的 不是单个的 我老是错
printf("%d\n", sizeof(*a)); 16 a是首元素地址 - 第一行的的地址 *a就是第一行 sizeof(*a)就是计算第一行的大小 
printf("%d\n", sizeof(a[3])); 16 视频很多以为这里会报错 因为没有a[3]0-2 但是之前说过 sizeof括号里面的[3]真的会去访问吗？其实并没有去访问的 我只是根据它的类型去计算它的大小的
                    a[3]是一个4个整型元素的数组 答案是16

// 总结：理解二维数组的数组名 二维数组的每一行的数组名是什么 
// 数组名单独放在sizeof内部 把握这几个点 这些题都简单了
```

```c
指针笔试题
写代码三种境界：
1. 看代码是代码
2. 看代码是内存
3. 看代码是代码(和机器无障碍沟通了)
 
// 例1. 
int main ()
{
    int a[5] = { 1,2,3,4,5 };
    int* ptr = (int*)(&a + 1);
    printf("%d,%d", *(a + 1), *(ptr - 1));
    return 0;
}
2, 5
&a + 1 数组指针类型 不能存到整型指针里面去的 所以需要强制类型转换 
(int*)(&a + 1) 
1 2 3 4 5
         >ptr 
         *(ptr - 1) ptr现在已经是整型了 往前一个整型就是5处的地址了
*(a + 1) a是首元素的地址，不是整个数组的地址 这里+1 就是第二个元素的地址


// 例2.??
struct Test
{
    int Num;
    char *pcName;
    short sDate;
    char cha[2];
    short sBa[4];
}*p;
/假设p的 值为0x1000000,如下表达式的值分别为多少？
/已知，街头提Test类型的变量大小是20个字节
int main ()
{
    printf("%p\n", p + 0x1);
    printf("%p\n", (unsigned long)p + 0x1);
    printf("%p\n", (unsigned long)p + 0x1);
    return 0;
}
解答：这里考察的就是指针+整数 取决于指针类型 什么类型的指针嘛
00000014
00000001 ？？ 
00000004 ？？
p = (struct Test*)0x100000; 把这个16进制变成一个地址！！！
0x1 是16进制 1
0x100000 + 20个字节 = 0x100014
！这种类型的题步骤：需要把数字转成十进制，然后这个题就变成了指针+整数 
然后再根据类型判断指针的步长是多少

(unsigned long)p 0x1000000-16进制 转成10进制 1048576 
(unsigned long)p + 1   1048576+1=1048577转成16进制 0x10000001 就是多了一个1 
整型+1 就是+1 ？？？都忘记了  这里不是指针+整数的题目。

(unsigned int*)p + 0x1 无符号整型 相当于+4了 0x100004
??? 类型是步长啊，哥哥，这里就是指针+整数的题目。


// 例3. 
int main ()
{
    int a[4] = { 1,2,3,4 };
    int* ptr1 = (int*)(&a + 1);
    int* ptr2 = (int*)((int)a + 1);
    printf("%x,%x", ptr1[-1], *ptr2);
    return 0;
}
看不懂。
(int)a
数组a 这里是首元素地址 也就是第一个元素1的地址强制转成int 也就是转成整数啊 
(int)a + 1
整数+1 只是让他向后面加了一个1 
+1之后与不+1 向后偏移了一个字节 也就是地址增加了一个1
(int*)((int)a + 1)
+1之后再转换成地址，与不加之前比较 相当于向后偏移了1个字节 
我们看看内存中每个字节的布局是什么样子的：？
视频中机器是小端存储的。
低地址                                          高地址
01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00 
----------- ----------- ----------- -----------
第一个元素    第二个元素   第三个元素   第四个元素 
|-----------------整个表示的就是a数组-----------|
|&a取数组地址                                  |&a+1 然后把这个强制转成整型指针(int*) 然后赋给ptr1
                                              |ptr1 
   |ptr2(01后面这个00这里)

(int*)(&a + 1)
(&a + 1) 本来这玩意类型是 数组型的 步长+1都是数组长度
强制转成了int*类型  步长就变了 变成了4个字节了 

a假设数组首元素的地址是 0x00 00 00 05
然后(int)a 强制把这个地址转成整型 -> 5 
(int)a+1 5+1=6
然后又转回去 转成int型指针 
(int*)((int)a + 1) 6->0x00 00 00 06
对比这两个16进制的数，前提这两个现在都是地址了！！！
地址相差了1，就是相差一个字节！！！！！！！
所以ptr2的位置 是在数组首元素地址之后一个字节 看上图ptr2的位置

ptr[-1] == *(ptr+(-1)) == *(ptr-1)
ptr因为是一个整型指针，-1就是向前移动了一个整型指针大小，
也就是从ptr1位置，倒着前一个整型空间大小， 04 00 00 00
因为我们是小端模式，所以是倒着的，00 00 00 04 

*ptr2 
在01后面，ptr2是整型指针，我这里解引用，访问4个字节，
00 00 00 02 因为是小端模式 所以是 02 00 00 00 

最终答案：4，2 000 000
这道题的前置知识：内存中最小的内存单位是1个字节，每个字节都给一个地址。

// 例4.
int a[3][2] = {
    (0, 1),
    (2, 3),
    (4, 5)
};
int* p;
p = a[0];
printf("%d", p[0]);
分析：
首先这个初始化，我就遇到了问题，这里并没有初始化完的，逗号表达式计算完也才3个元素的。
a[0] 第一行的数组名 首元素的地址-(第一行的)
p[0] == *(p+0) 
p里面存放的是1的地址，+0还是1的地址
解引用这个1的地址 就是1 十进制输出

// 例5.
5. ？？？ 
int a[5][5];
int(*p)[4];
p = a;
printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
分析：
二维数组的首元素地址和一维数组的首元素地址是不一样的。一个是第一行，一个就是元素。
p = a; 运行上面代码会报错的 a是int(*)[5]类型的，p的类型是 int(*)[4]
两者的类型是不一样的，这里强行赋值给了p p还是指向原来的那里的 ？？？ 
因为我把地址赋值给了p 只是类型不符合而已
p[4][2] == *(*(p+4)+2) 这一步转换至关重要！！！   补充计算机就是这样干的，访问数组 
手机截图 -- -4 -4 
-4 %p输出 
    100000...00100 -4原码 
    111111...11011 反码 
    1111111...1111100 补码 
    %p 来打印，认为里面放的就是地址，地址就不存在原码反码补码 原反补是负数的概念
    地址可以说是一个无符号数 可以说内存存的原码就是它的补码
    这个补码当成地址来处理了 1111处理成f 
    fffffffC
-4 %d输出 
    拿出它的原码来打印？？？
    -4 
答案： FFFFFFFC -4 
  
// 例6.
int main ()
{
    int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
    int* ptr1 = (int*)(&aa + 1);
    int* ptr2 = (int*)(*(aa + 1));

    printf("%d,%d", *(ptr1 - 1), *(ptr2 - 1));
}
分析： 
aa：
1  2  3  4  5  6  7  8  9  10
                             |ptr1
               |ptr2
&aa 和 &aa[0] 注意区分哈
&aa + 1 是跳过一个数组 不是我想的第一行的首元素地址
(&aa + 1) 这是一个数组指针，这里想赋值给ptr1 ptr1是一个整型指针 类型不匹配 就需要强制类型转换
强制类型转换：只是让它的类型发生变化，值是不变的，这里值还是这个地址ptr。

aa是首元素地址，应该就是第一行了，+1 就是第二行了
然后执行解引用操作，就是找到了第二行，这里第二行首元素的地址，就是6的地址，
6的地址本来就是int*，这里强制类型转换int*就是多余的，因为赋值给也是给int*类型的。

ptr1-1 因为ptr1是整型指针，然后-1，回跳一个字节 跳到10处的地址处
然后解引用 *(ptr1-1) 得到10
ptr2-1 ptr2也是整型指针，向前挪动一个字节，就是5处的地址，
然后解引用，*(ptr2-1) 得到5

答案：10 5 我上面似乎写反了。后面整理再说把。

补充一个基础知识：
int arr[10] = { 1,2,3,4,5 };
int* p = arr;
*(p + 2); /== arr[2] p是首元素地址 +2到后的地址是3处的地址 然后解引用 就是3 和直接下标访问3元素 一样的效果。
    一种是通过指针访问，一种是通过下标访问的

然后 上面把 int* p = arr; arr赋值给p 她两是一回事 等价的 那么：
*(p + 2) == *(arr + 2) /== arr[2]
*(p + 2) 可以写成 p[2] 这里就有4种写法了。

编译器会把 arr[2] 转换成 *(arr+2)这种写法的，通过指针+-得到对应的地址 然后访问地址的内容。说白了就是操作内存访问内存！！
说白了，就是操作内存 访问内存。

// 例7.
int main ()
{
    char* a[] = { "work", "at", "alibaba" };
    char* *pa = a;
    pa++;
    printf("%s\n", *pa);
    return 0;
}
分析：
    回忆： 
    int main ()
    {
        char* p = "abcdef"; 这个表示把一个常量字符串的首字符'a'放在p里面
        return 0; 
    }   
char* a[] = { "work", "at", "alibaba" };
a数组 3个元素 类型是char* 这三个常量字符串的首字符的地址
a数组名 首元素的地址 'w'的地址 把这个地址放到pa里面 pa是一个指针变量 
pa类型是char** 对吗？第一个元素类型是char* 首元素的地址 char*的地址 就应该是char**类型 
char* *pa = a; 后一个*表示pa是指针，前面那个*，和char*一起，表示指向的那个元素 它的类型是char* !!!
pa++ 跳过的是一个char*的一个变量 
补充 int* p; p+1 跳过的是一个整型
所以这里pa指向了第二个元素了，a数组的第二个元素 一个char*指针 里面存的是'a' 
然后通过*pa找到这个地址的存放的内容，这里%s打印，打印的就是一个字符串
不就是"at"吗

我有个问题的：pa++ 这里的应该是pa的地址++，和它存放的内容++，是有区别的，？？？

// 例8：
char* c[] = {
    "ENTER",
    "NEW",
    "POINT",
    "FIRST"
};
char* *cp[] = {
    c + 3,
    c + 2,
    c + 1,
    c 
};
char** *cpp = cp;
printf("%s\n", **++cpp);
printf("%s\n", *--*++cpp + 3);
printf("%s\n", *cpp[-2] + 3);
printf("%s\n", cpp[-1][-1] + 1);
分析： 
画内存结构图。前期学习好的技巧。
手机截图 太秒了 我都不想做笔记了 
看着这幅图做这个题 舒服了 
**++cpp => **(++cpp) **两次解引用 因为是三级指针 "POINT"
*--*++cpp -> *(--(*(++cpp))) 这里有个-- 注意：是里面的内容，也就是地址减少了1，这个时候解引用，所访问的地址就发生了改变了的  
*--*++cpp + 3 这里指向c的首元素地址 'E' 然后+3 就是'ENTER' 到'E'开始打印 'ER'
*cpp[-2]+3 -> **(cpp+ (-2)) + 3 -> **(cpp-2)+3 ?? 然后分析了就是 'ST'

cpp[-1][-1]+1  -> *(*(cpp-1)-1)+1 和之前分析差不多 'EW'

答案： 'POINT' 'ER' 'ST' 'EW'
```



## (五) 函数

### 常用函数

```c
printf
sprintf
puts 
putchar 
scanf
scanf_s: %s %c 第二个参数是长度？
atoi 
atof 
```



## (六) 数组

## (七) 文件操作(stdio.h)

### 7.1 File(stdio.h)

```c
fopen 
fclose
fread
fwrite
fseek
ftell

```

### 7.2 **Formatted input/output**

```c
printf
scanf
fprintf
fscanf
fflush
```

### 7.3 **Character input/output**

```
gets
getchar
puts
putchar
```



## (八) 动态分配内存

### malloc

### calloc



## (九) 练手项目

## (十) 算法入门

```c
算法：为解决一个问题而采取的方法和步骤
算法分类：数值运算 非数值运算

如何表示一个算法：自然语言 传统流程  N-S流程 伪代码 PAD图等
用计算机语言表示算法:
	结构化程序设计方法：
		自顶向下
		逐步细化(分而治之)
      	模块化设计(分而治之)
        结构化编码(顺序、选择、循环结构) 
```

## (十一) 自定义数据类型

### 1. 枚举 

```c
// 枚举
// 一一列举
// 枚举类型 枚举是一种类型
enum Day  枚举类型定义
{
    Mon, 枚举的可能取值-叫枚举常量
    Tues,
    ...
    Sum 
};
// 1.
enum Sex 
{
    MALE,
    FEMALE,
    SECRET
};
int main ()
{
    enum Sex s = MALE;
    s = FEMALE;
}
// 2.
enum Color
{
    RED, 0 默认
    YELLOW, 1
    BLUE 2

    RED = 2, 可以赋初值2 之前0是默认值而已
    YELLOW = 4,
    SECRET = 8  这里打印就是 2 4 8

    RED,
    YELLOW = 9,
    SECRET   这里打印就是 0 9 10
};
int main ()
{
    枚举创建变量 取值是之前就创建好的 枚举常量那些
    enum Sex s = MALE;
    enum Color c = BLUE;

    printf("%d %d %d\n", RED, GREEN, BLUE); 0 1 2
}
// 3.
还有和枚举同样效果的写法
#define RED 0  
#define GREEN 1
#define BLUE 2 
int main ()
{
    int color = RED;
}
枚举的写法更加好一点
// 4. 
枚举优点：
C语言的源代码--预编译--编译--链接--可执行程序
              (define写法 预编译中RED会被编译成0 然后可执行程序报错了 就看到一个0的报错信息 都不方便调试)
枚举有类型RED,BLUE define没有类型，不严谨
1. 增加代码的可读性和可维护性
2.和#define定义的标识符比较枚举有类型检查，更严谨
3. 防止了命名污染 - 封装
4. 方便调试
5. 使用方便，一次可以定义多个常量
```

### 2. 联合 联合体 共用体

```c
// 联合类型
// 联合也是一种特殊的自定义类型，这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间，所以联合也叫共用体。

// 1.
struct S 
{};
enum Em 
{};

union Un 
{
    char c; 1
    int i; 4
};
int main ()
{
    union Un u;
    printf("%d\n", sizeof(u)); 4 
    printf("%p\n", &(u));  00F1F90C
    printf("%p\n", &(u.c)); 00F1F90C
    printf("%p\n", &(u.a)); 00F1F90C
}
联合的特点：内存空间至少是最大成员的大小

// 2.1
面试题：判断当前计算机的大小端存储？
回顾之前知识：
int a = 0x11 22 33 44;
-------低地址-------------------->高地址
......[][][][][11][22][33][44][][][][][][] 大端字节序存储模式 低字节放到高地址，高字节刚到低地址
......[][][][][44][33][22][11][][][][][][] 小端字节序存储模式 把一个数的低字节(44)内容，放在低地址处，高字节11内容放到高地址处
低低小 高高大
讨论拍一个数据，放在内存中的字节顺序
大小端字节序问题

int a = 1; 0x 00 00 00 01 用1方便计算
低地址       高地址
01 00 00 00 
小端存储模式 

低地址       高地址
00 00 00 01
大端存储模式 

我们只需要拿出第一个字节 01 00进行对比？
我们只需要拿到地址 然后访问1个字节即可
代码：
int a = 1;
if ( 1== *(char*)&a; )
{
    printf("小端\n");
}
else 
{
    printf("大端\n");
}
优化：封装一个函数
int check_sys ()
{
    int a = 1;
    return *(char*)&a;
    返回1就是小端 0就是大端
}
// 2.2
面试题：判断当前计算机的大小端存储？
这个很巧妙，利用联合类型
搞一个char c=1 int i  然后访问c是1还是0 即可
int check_sys ()
{
    union Un 这里去掉Un名也可以 变成匿名的 反正这里也只用一次
    {
        char c;
        int i;
    }u;
    u.i = 1;
    return u.c; 
    返回1就是小端 0就是大端
} 
// 3.
结构体各自占各自的空间，这个联合是共用空间。
enum Sex 
{
    MALE,
    FEMALE,
    SECRET 
};
int main ()
{
    enum Sex s = MALE;
    printf("%d\n", sizeof(s)); 4 ? 一个整型大小，从默认值是一个整型数字看出的吗？
}

// 4. 
联合大小的计算：
	联合的大小至少是最大成员的大小 
	当最大成语人大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍
union Un 
{
    int a; 4 8 较小值就是4 对齐数是4
    char arr[5]; 5 拿数组的元素类型算对齐数的哈 char 1 默认VS是8 较小值就是1
};
int main ()
{
    union Un u;
    printf("%d\n", sizeof(u)); 5不是4的倍数 整数倍 是8 浪费了3个字节
}
```

### 3. 位段

```c
结构体讲完就得说说结构体实现 位段的能力
位段的声明和结构是类似的，有两个不同：
  1.位段的成员必须是int unsigned int 或者 signed int 
  2. 位段的成员名后面有一个冒号和一个数字
    位段成员的类型一般是相同的类型
    
// 1. 
struct A 
{
    int _a:2;  2个比特位
    int _b:5;  5个比特位
    int _c:10; 10个比特位
    int _d:30; 30个比特位
        总共就是47个比特位，1个字节是8个比特位 就是6个字节搞定
        但是后面打印是8个字节 说明肯定有自己的内存规则
};
struct S s;
printf("%d\n", sizeof(struct A));  8个字节 
A就是一个位段类型 位段A大小？
位段 - 二进制位
int a 我知道这个a 只会有4个可能结果 但是却占了int整个内存空间 int表示的范围2^32次方种状态 
    这里其实我们可以给它2个bit位就够了，表示4个状态 
    上面其他同理 

位段的内存分配
    1.位段的成员可以是int  unsigned int signed int 或者是char (整型家族)类型
    2.位段的空间是按照需要 以4个字节(int) char(1个字节) 开辟的
    3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植性的程序应该避免使用位段

申请4个字节空间-32位 
-------------- 2 a 
-------------- 5 b 
-------------- 10 c 
-------------- 15 (d是30，这里放不下，视频中的编译器选择是直接丢弃这块内存，重新开辟一块4字节的内存空间)

新的一块内存：
-------------- d 30

所以，这里总共使用的内存：
4+4=8字节 

视频提出了一个问题，int d: 30 如果这里大于32呢？
视频说不能大于32的。需要在位段的范围内。
位段就是为了节省空间的。
原本4*4=16个字节 现在是8个字节了 省了一半。

// 2. 
struct S 
{
    char a: 3;
    char b: 4;
    char c: 5;
    char d: 4;
};
自己分析：只要3个字节
int main ()
{
    struct S s;

    s.a = 10;
    s.b = 20;
    s.c = 3;
    s.d = 4;
}

这里假设自右向左开始哈
0 0000 000  000 00000  0000 0000
----------  ---------  ---------
   b    a         c           d 
然后这里s.a = 10 -> 1010 这里a只有3个比特位 只能存3位 --010
s.b = 20; -> 10100 b只有4个比特位 只能存0100 
s.c = 3; =>011 c这里有5个比特位 不够就补0前面
s.d = 4; ->100  0100存的
整个内存就是：
00100010 00000011 00000100 vs调试-窗口-内存 监视是不是这个
(4位)2 2   0  3     0 4
16进制就是： 0x220304 总共就3个字节

// 3.
位段的跨平台问题：
1. int位段被当成有符号数还是无符号数 是不确定的。C没有给出明确标准
2. 位段中最大位的数目不能确定。(16位机器最大16 32位机器最大32 写成27 在6位机器会出问题)
3. 位段的成员在内存从左向右分配，还是从右向左分配标准目前没有标准
4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的

总结：跟结构相比，位段可以达到同样的效果，但是可以节省空间，但是有跨平台的问题。

应用：
位段在网络底层开发中比较常见！！
上网 -- 数据的传输 -- 数据包流转
数据包
手机截图 计算机网络
网络协议--尽可能小空间 使用到了位段 有自己的场景的
```

### 4. 结构体

```c
内置类型: char short int float double
自定义类型: 结构体 枚举 联合体 

// 1. 
声明一个结构体类型
这里声明一个学生类型，是想通过学生类型来创建学生变量(对象)
描述学生：属性+名字+电话+行性别+年龄
struct Stu 
{
    char name[20];
    char tele[12];
    char sex[10];
    int age;
} s4, s5, s6;  // 分号不能丢
// s4 5 6 这叫全局的结构体变量  和下面*处效果一样的
// Stu 叫结构体标签
// {}里面的叫做成员变量 
struct Stu s3; // 全局的结构体变量了 *
int main ()
{
    创建的结构体变量
    struct Stu s1;  // 这是局部的结构体变量
    struct Stu s2;
}

// 2.
// 特殊情况：匿名结构体类型
struct 
{
    int a;
    char b;
    float c;
} x; 
// 匿名结构体类型 没有名字 以后是无法创建的 只有在这声明的时候同时创建一个变量x 

struct {
    int a;
    char c;
} sa;
struct 
{
    int a;
    char c;
} *psa;  // *psa结构体指针了
int main ()
{
    psa = &sa; // 注，这两个结构体看上去一样，其实编译器还是会当成两个不一样的结构体的 不能这样赋值的
   // 编译器会把上面的两个声明当成是完全不同的两个类型，所以是非法的
}

struct Node 
{
    int data; 数据域
    // struct Node n; 结构体自己包含自己的成员变量 无限找下去 报错的
    struct Node* next; 指针域 // 4/8 存下一个结构体的地址 
};
int main ()
{
    sizeof(struct Node);
    return 0;
}

// 3. 
结构体重命名
typedef struct Node 
{
    int data;
    struct Node* next;
} Node;
int main ()
{
    struct Node n1; 都可以
    Node n2; 都可以
}

错误示范
typedef struct 
{
    int data;
    Node* next;
} Node;
这个时候到底是先有类型别名? 还是现有里面的成员变量呢？这个是不确定的
即使要重命名，结构体标签也不能省略的

// 4.
结构体初始化
struct S s = {
    'c',
    100,
    3.14
};
printf("%c %d %lf...%s", s.c, s.a, s.d, s.arr);

// 5. 
结构体内存对齐 (热门考点)
struct S1 
{
    char c1;
    int a;
    char c2;
};
struct S2 
{
    char c1;
    char c2;
    int a;
};
int main ()
{
    struct S1 s1 = {0};
    printf("%d\n", sizeof(s1)); 12
    struct S2 s2 = { 0 };
    printf("%d\n", sizeof(s2)); 8
}

结构体对齐规则：
1. 第一个成员在于结构体变量偏移量为0的地址处
2. 其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处
对齐数 = 编译器默认的一个对齐数与该成员大小的较小值
    vs中默认的值为8 
3. 结构体总大小为最大对齐数(每个成员变量都有一个对齐数)的整数倍 
4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数(
    含嵌套结构体的对齐数)的整数倍  

手机截图看这个分析。！！！！！！
GCC编译器-没有默认对齐数的 对齐数=成员大小的较小值 

// 6.
struct S3 
{
    double d;
    char c;
    int i;
};
printf("%d\n", sizeof(struct S3));
16
8 1 4 =13 4的倍数这最小是16 手机截图
  ----------- 0 偏移量是0
  ...
  ----------- 7 偏移量是7
  ------------8  然后接下来放c 自身1个字节 VS默认对齐数是8 取较小者1 这里8是1的倍数 可以放进去
                 i是4个字节，默认对齐数是8，取较小者4 因为是4个字节 要放到4的倍数的地址(！就是这句话)
  ------------9 9不是4的倍数
  ........这3个属于空间浪费的了
  ------------12 
  ...
  ----------- 16 16是我这最对齐数8(double)的整数倍 所以就是16

// 7.
struct S4 
{
    char c1;
    struct S3 s3;
    double d;
};
printf("%d\n", sizeof(struct S4));
分析：
struct S3 s3; 这里要给他16个字节 也就是需要是它的最大对齐数的整数倍 8的整数倍 
---------------0
1
---------------1
...浪费7个
---------------8
...16
---------------24 
...8
---------------32 

现在是32个字节。但是还有个规则：结构体的的总大小必须是最大对齐数的整数倍。这里必须是8的倍数 这里32满足。

为什么存在内存对齐？
大部分参考资料说法：
1. 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的，
某些硬件平台只能在某些地址处某些特殊类型的数据，否则抛出硬件异常。
2. 性能原因：数据结构(尤其是栈)应该尽可能的在自然边界上对齐。
原因在于：为了访问未对齐内存，处理器需要做两次内存访问；而对齐的内存访问仅需要一次访问。

总体来说：
结构体的内存对齐是拿空间来换取时间的做法

// 8.
struct S 
{
    char c;
    int a;
};
32位机器：
32根地址线
32根数据线 -> 0/1 通用寄存器也是一次读取4个字节
----------0
c 
----------1
...a
----------5 
寄存器一次读取4个字节 0-4 然后拿c倒是挺方便的
但是我要拿a 就继续读取5-后面的这块内存，
因为a是由第一次读取的3个字节 和 第二次读取的1个字节共同组成 
需要做一次运算拼接起来才行。
读取a 读取了2次 并且还有一次拼接

有对齐的版本：
--------------0
...c 
--------------1
...浪费的空间
--------------4 要存a 就要从这里开始 对齐的4的倍数
...a
--------------8
寄存器读取的时候 c一次读取 a也是一次读取，并且没有额外拼接。

这样效率高了，时间块了，虽然空间浪费了点。
思想：空间换时间。说白了，其实还是时间复杂度的优化。

你发现没有：
struct S1 
{
    char c1;
    int a;
    char c2;
};  12个字节
struct S2 
{
    char c1;
    char c2;
    int a;
};  8个字节 
都是这三个类型,只是顺序发生了改变，占的内存都不一样了。
所以，我们需要思考，设计结构体的时候，既要满足对齐，又要节省空间。
！！！ 让占用空间小的成员尽量集中在一起。

修改默认对齐数
#pragma pack(4) 设置默认对齐数字是4
struct S 
{
    char c1;  1
    // 7
    double d;  8 自定义了对齐数字后，这里对齐数-取较小值 8、4 取4 下面大于就是12了
     1 + 上面就不是浪费7个字节了，是3个字节了 + 8个字节 = 12个字节 省了4个字节 
};
int main ()
{
    struct S s;
    printf("%d\n", sizeof(s));   16
}

如果设置成1，就相当于没有对齐了。
如果设置成了1 就是9个字节  1+8 

结论：在对齐方式不合适的时候，我们可以自己重新设置对齐数。
一般都是2的次方数 2 4 8 16 ... 
  
// 9.
  偏移量是0 就是自己那块地址
struct S 
{
    char c; 相对于起始地址偏移量是0
    int i; 相对于起始地址偏移量是4
    double d; 相对于起始地址偏移量是8
}
我们认为起始位置偏移量是0.
如果我们想知道每个成员变量的偏移量呢？除了自己计算
提供了一个函数 offsetof()
计算结构体成员 相对于结构体起始位置的偏移量是多少
这不是一个函数 是一个宏  
struct S 
{
    char c;
    int i;
    double d;
};
int main ()
{
    printf("%d\n", offsetof(struct S, c)); 0
    printf("%d\n", offsetof(struct S, i)); 4
    printf("%d\n", offsetof(struct S, d)); 8
}

宏：参数是可以传类型的 不是个变量名 这里struct S就不是变量名

// 10.
写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明
考察：offsetof宏的实现 
```

```c
// 结构体传参
struct S 
{
    int a;
    char c;
    double d;
};
void Init (struct S tmp)
{
    tmp.a = 100;
    tmp.c = 'w';
    tmp.d = 3.14;
    你以为就是这样？这是值传递 拷贝副本的 视频带我看了内存地址都不同 形参地址和实参地址
    上指针
}
void Init (struct S* temp)
{
    ps->a = 100;
    ps-> = 'w';
    ps->d = 3.14;
    然后看内存 监视 这个一定要学会 看内存 相当重要
}
void Print1 (struct S temp)
{
    printf("%d %c %lf\n", temp.a, temp.c, temp.d);
}
void Print2 (struct S* ps)
{
    printf("...", ps->a, ps->c, ...);
}
int main ()
{
    struct S s = { 0 };
    Init(s);
    Init(&s);

    Print1(s);
    Print2(&s);

    // s.a = 100;
    // s.c = 'w';
    // s.d = 3.14;

    printf("%d\n", s.a);
    return 0;
}

传值和传址。仅仅一个4/8字节的地址，如果结构体过大，你进行拷贝，这样开销会过大的。
如果传递一个结构体对象的时候，结构体过大，参数压栈的系统开销较大，导致性能下降。
传值可能更加安全一点，因为是拷贝副本，不会改变原来数据。
前面加一个const即可，就无法改变了？？？无法改变什么 视频说的太快了
void Print2 (const struct S* ps) {}

结论：结构体传参的时候，要传结构体的地址。
```

## (十二) 程序的环境和预处理 

### 1. 程序的环境

```c
分为：翻译环境 执行环境
1. 
总体概述：
c代码(文本文件)
test.c -> 编译 链接 -> test.exe -> 运行
源文件(源程序)          二进制信息(二进制文件) 
------翻译环境-------> ---执行环境--->

在ANSI C的任何一种实现中，存在两个不同的环境。
第一种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。
第二种是执行环境，它用于执行代码。

多个源文件(每个是编译器单独处理) -> 编译器 -> 目标文件(.obj) -> 链接器 (链接库) -> 可执行程序 
上课的时候就会不断自己回想知识，巩固

test.c                       test.exe 
---------翻译环境-------------     ------运行环境-------
---------编译(编译器)--------- obj ----链接(链接器)-----
--预编译--编译--汇编----------
  
2. 翻译环境
  这三个过程用linux最好讲
  2.1. 预处理 选项 gcc -E test.c -o test.i 预处理完成之后就停下来了，
      预处理之后产生的结果都放在test.i文件中
      是把stdio.h文件全部替换进去了 
      stdio.h widows在vs安装包中 X86那个目录  inlcude 
      linux /根目录下 /user/include 中
      vim /user/include/std 打开 
      vim /user/include/stdio.h  我打不开呢？
      1. #inlcude 头文件的包含 文本替换
      2. 注释删除 使用空格替换 文本删除
      3. #define 预处理符号 也是这个阶段完成 文本替换
      总归一句话：这个阶段是文本操作。文本删除 替换
      
  2.2 编译 tcc -S test.c 编译完成之后就停下来了，结果存在tset.s中 
      gcc -S test.i 
      rm -f test.s 删除 
      vim test.s 打开 里面放的是汇编指令 
      这里是把c语言代码 翻译成 汇编指令 
      (编译原理 词法分析 语法分析 语义分析 符号汇总(后面链接有用 把函数名 全局变量汇总))
      编译原理((程序员的自我修养-简单入门))- 如何实现一个编译器 构造成词法树  

  2.3. 汇编 gcc -c test.c 汇编之后就停下来了，结果存在test.o中 
      gcc -c test.s 转成test.o文件了
      vim test.o 打开 但是看不懂 都是二进制指令 我打不开呢？
      1. 形成符号表
          int Add (int x, int y)
          {
              return x + y;
          }
          Add 0x100 函数也是有地址的 类似这样形成符号表
          Sub 0x??? 类似形成一张表
      2. 汇编指令 -> 二进制指令 ---test.o 

3. 运行环境
  链接：
      形成 test.exe 
      1. 合并段表 
          比如这里有多个.o文件，需要链接在一起
          一个文件，会分成几个段，各自的段放对应类型的内容 elf文件格式
          多个文件，合并，就是对应的段数据合并在一起，这就是合并段表
          最终生成.exe文件 
          如果，你把对应的函数注释了，符号表没有这个函数了,程序运行，就会报错，链接错误。
          报错信息：LNK 无法解析的外部符号 
      2. 符号表的合并和符号表的重定位

  vim攻略： coolshell.cn/articles/5426.html 

  运行时：
      1. 程序必须载入内存中。在有操作系统的环境中，一般由OS完成，在独立的环境中，程序的载入必须由手工安排，
          也可能是通过可执行代码置入只读内存来完成
      2. 程序的执行便开始。接着便调用main函数
      3. 开始执行程序代码，这个时候程序将使用一个运行堆栈，存储函数的局部变量和返回地址，
          程序同时也可以使用静态内存，存储于静态内存中的变量在程序的整个执行过程一直保留它们的值
      4. 终止程序，正常终止main函数，也可能时意外终止

    推荐-<程序员的自我修养>
```

### 2.  围绕预编译

```c
1. define 
#define MAX 100 这是你自己定义的符号 不叫预定义符号
语言本身已经定义好的符号 - 预定义符号 
int main ()
{
    printf("%s \n", __FILE__); 所在文件绝对路径
    printf("%d \n", __LINE__); 53行 代码所在的行数 
    printf("%s \n", __DATE__); 日期 
    printf("%s \n", __TIME__); 时间 
    // 未来你想看代码什么时候执行的，就会用到，日志打印

    // 写日志文件 查看日志文件 
    int i = 0;
    int arr[10] = { 0 };
    FILE* pf = fopen("log.txt", "w");
    for (i=0; i<10; ++i)
    {
        arr[i] = i;
        fprintf(pf, "file:%s line:%d date:%s time:%s i=%d \n",
        __FILE__, __LINE__, __DATE__, __TIME__, i);

        printf("%s \n", __FUNCTION__); main 所在函数名字 
    }
    fclose(pr);
    pf = NULL;
    for (i=0; i<10; ++i)
    {
        printf("%d ", arr[i]);
    }
}

__STDC__ 严格遵守ansi c 这个就是1，反之未定义 
vs不遵守，linux严格遵守了的

加不加分号呢？
#define MAX 100
#define STR "hehe"
printf("%s \n", STR); 

#define reg register 
reg int a;

#define do_foreever for(;;)
do_foreever;

加不加分号呢？ 尽量不要加分号 
#define MAX 100;
int main ()
{
    int a = MAX; 如果上面加了分号，这里就是;;两个分号了  
        int a = 100;;
    printf("%d\n", MAX); 这样语法就报错了 
        printf("%d\n", 100;);
}
报错，是替换之后的报错，预编译之后的错误
尽量不要加分号。

#define 定义宏
#define机制包括了一个规定，允许把参数替换到文本中，
这种实现通常称为宏或者定义宏

#define SQUARE(X) X*X 
int main ()
{
    int ret = SQUARE(5);
                5*5 

    int ret = SQUARE(5 + 1);
    printf("%d \n", ret); 11 ?
        5+1*5+1 = 11 
        如何解决这个问题呢？
        #define SQUARE(X) (X)*(X) 即可
    所以，在写宏的时候，如果可能有优先级问题，最好加一个()
}

#define DOUBLE(X) X+X 
int main ()
{
    int a = 5;
    int ret = 10 * DOUBLE(a);
        int ret = 10 * a + a;
                  10 * 5 + 5 
    printf("%d \n", ret); 55 
    这个时候你加上() 以为就能解决问题？
    #define DOUBLE(X) (X)+(X) 结果依然是55 
        10 * (a) + (a)
    解决是：把整体括起来
    #define DOUBLE(X) ((X)+(X)) √ 
}
提示：用对于数值表达式进行求值的宏定义都应该用这种方式加上括号，
避免在使用宏时由于参数中的操作符或邻近操作符之间不可预料的相互作用

注：
1. 宏参数和#define定义中可以出现其他#define定义的变量，但是对于宏，不能出现递归
2. 当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索

```

```c
# ##
1. #
void print (int a)
{
    printf("the value of a is %d \n", a);
}
int main ()
{
    int a = 10;
    int b = 20;
    // printf("the value of a is %d \n", a);
    print(a); the value of a is 10
    print(b); the value of a is 20 这里应该是b是20，不是a了
}
函数无法做到，传入a或者b，字符串中打印则是对应的值
传入a，打印--"a的值是10"
传入b，打印--"b的值是20"
  
咋办？？ 宏
前置知识：
    printf("hello world\n");
    printf("hello " "world\n");
    printf("hel" "lo " "world\n");
    打印结果都是一样的，printf会把所有参数字符串，处理成一个
问题：如何把参数插入到字符串中？
#define PRINT(X) printf("the value of "#X" is %d\n", X)
int main ()
{
    int a = 10;
    int b = 20;
    PRINT(a); "the value of "a" is 10" 合成一个字符串
    PRINT(b); "the value of "b" is 20" 
}
总结：使用#， 把一个宏参数变成对应的字符串

2. ## 
#define CAT(X, Y) X##Y 
int main ()
{
    // int Class84 = 2023;
    printf("%d\n", CAT(Class, 84)); 2023 
    // printf("%d\n", Class##84);
    // printf("%d\n", Class84);
}
然后linxu去验证了。
gcc test3.c -E > test3.i 
vim test3.i 
代码在最后行看见了 替换了class84 
字符串拼接 差不多
```

```c
1.
带副作用的宏参数
当宏参数在宏的定义中出现超过一次的时候，如果参数才有副作用，那么你在使用这个
宏的时候就可能出现不可预测的后果。副作用就是表达式求值的时候出现的永久性结果。
例：
x+1; 不带副作用
x++; 带有副作用 
MAX宏可以证明具有副作用的参数引起的问题。

例1：
int main ()
{
    int a = 10;
    
    int b = a + 1; /a变成了1
    int b = ++a;   /a变成了2
    这两句代码，对于b没有变化，但是对于a来说，就发生了变化
}

例2：
#define MAX(X, Y)  (X)>(Y)?(X):(Y)
int main ()
{
    int a = 10;
    int b = 11;
    // int max = MAX(a, b);
    // printf("%d \n", max); 11 

    int max = MAX(a++, b++); 有副作用了
     printf("%d \n", max); ? 12 
     printf("%d \n", a);   ? 11
     printf("%d \n", b);   ? 13 
    明确：宏是替换进去的，不是算好的
    ((a++)>(b++) ? (a++) : (b++))
    10>11 ? 12(没有执行这个代码，因为执行了:后面的代码) : 13 

    注： a>b ? a : b 如果是a<b,那？后面代码没有执行的
    和if else 一个道理。
}

例3：
宏和函数的对比 ？
int Max (int x, int y)
{
    return (x > y ? x : y);
}

#define MAX(X, Y) ((X)>(Y)?(X):(Y))

int main ()
{
    int a = 10;
    int b = 20;
    int max = Max(a, b);
    max = MAX(a ,b);
}

例4：
函数好，宏好？
int main ()
{
    float c = 3.0f;
    float d = 4.0f;

    int max = Max(c, d); 但是函数形参是整型，这传入浮点型 类型不匹配

    max = MAX(c, d); 宏 没有这个问题，是替换进去的，和类型无关的  
        宏更加灵活一点
}
转到反汇编，看这个代码。
调用Max函数的时候，29句汇编代码 才回来。函数在调用的时候，会有函数调用和返回的开销

宏的时候，预处理阶段就完成了替换，就不到十句话。
没有函数调用和返回的开销。

使用宏原因有二：
1. 用于调用函数从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。
所以宏比函数在程序的规模和速度方面更胜一筹
2. 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。
反之这个宏可以适用于整型 长整型 浮点型等可以用于>来比较的类型。
宏是类型无关的。

宏相比函数劣势的地方：
1. 每次使用宏的时候，一份宏定义的代码插入到程序中，除非宏比较短，否则可能大幅增加代码长度
2. 宏是没法调试的
3. 宏由于类型无关，不够严谨
4. 宏可能带来运算符优先级的问题，导致容易出现不可预测的错误

例5：
宏有时候可以做到函数做不到的事情。比如：宏的参数可以出现类型，但是函数做不到。
#define SIZEOF(type) sizeof(type)
int main ()
{
    int ret = SIZEOF(int);
    printf("%d \n", ret); 4 
}

#define MALLOC(num, type) (type*)malloc(num * sizeof(type))
int main ()
{
    之前使用malloc 麻烦 
    int *p = (int*)malloc(10*sizeof(int));

    int *p = MALLOC(10, int); 这样使用更加方便阿 定义一个宏 
        秒阿 
}

例6：
1. 每次使用宏的时候，一份宏定义的代码插入到程序中，除非宏比较短，否则可能大幅增加代码长度
int main ()
{
    TEST(); 如果一个宏是100行代码，这里是问题替换，就是300行代码，而函数则是100行
    TEST(); 函数只有一份函数体，宏则是全部替换
    TEST();
}
2. 宏是没法调试的
test.c  -> test.exe可执行文件
我们最后调试的是最后的.exe可执行文件 
而预编译早已经结束了，在编译阶段就结束了
3. 宏是文本替换，不做表达式计算
函数是参数是一个表达式，是会把表达式求值的，然后传入函数
而宏不是，直接文本替换的 

宏与函数对比小结：
代码长度 
执行速度
操作符优先级 
带有副作用 
参数类型 
调试 
递归 
宏名一般全部大写，函数则是首字母大写  
c++c99 inline-内联函数 很好解决了宏的不足

例7：
#unref 移除一个宏
#define MAX 100 
int main ()
{
    printf("MAX= %d \n", MAX);
#undef MAX  // 下面就无法使用MAX了
    printf("MAX= %d \n", MAX);

}
```

```c
1. 命令行定义
执行某些命令的时候 加一些参数
许多C的编译器提供了一种能力，允许在命令行中定义符号，用于启动编译过程。
例：
当我们根据同一个源文件要编译出不同的一个程序的不同版本的时候，这个特性有点用处，
假定某个程序声明了一个某个长度的数组，如果机器内存有限，我们需要一个很小的数组，
但是另外一个机器内存大些，我们需要一个数组能够大些 。

linux演示：
int main ()
{
    int arr[SZ] = {0};
    int i = 0;
    for (i=0; i<SZ; ++i)
    {
        arr[i] = i;
    }
    for (i=; i<SZ; ++i)
    {
        printf("%d ", arr[i]);
    }
}
vim test.c (不想vim打开,cat test.c 直接查看)
gcc test.c (直接编译报错)
gcc test.c -D SZ=10 (SZ设置成了10)(-D 参数，放在编译的时候处理)
./a.out  

gcc test.c -D SZ=100 (SZ设置成了100)
./a.out 

2. 条件编译
在编译一个程序的时候 我们如果要将一条语句(一组语句)编译或者放弃是很方便的。因为我们有条件编译指令。
选择性的编译，预编译的时候就删除了。

#define DEBUG 1
#define DEBUG 0
#define DEBUG  只要定义就生效
int main ()
{
    int arr[10] = {1,2,3};
    int i = 0;
    for (i=0; i<10; ++i)
    {
        arr[i] = 0;
#ifdef DEBUG
        printf("%d ", arr[i]);
#endif 
    }
}
如何做到的呢？
预处理的时候，判断DEBUG是否存在，存在就加入编译，反之删除

例1：
#if 常量表达式
    // ...
#endif  
如：
#define __DEBUG__ 1
#if ___DEBUG__
    // .. 
#endif 

例2：
多个分支的条件编译 
#if 常量表达式 
    ... 
#elif 常量表达式 
    。。。
#else 
    ...

#if 1==1
    printf("haha \n");
#elif 2==1
    printf("hehe \n");
#else 
    printf("gugu \n");
#endif 

例3：
判断是否被定义 
#if defined(symbol)
#ifdef symbol 

#if !defined(symbol)
#ifndef symbol 

#define DEBUG 0 不管0还是其他 只要定义过
int main ()
{
#if defined(DEBUG) 只要定义过 
    printf("hehe \n");
#endif 

写法2 
#ifdef DEBUG 
    printf("hehe \n");
#endif 

没有定义它，才参与编译呢？
#if !defined (DEBUG)
    printf("hehe \n");
#endif

写法2 
#ifdef DEBUG 没有定义 就加入到编译中 
    printf("hehe \n");
#endif 
}

例4：嵌套指令
#if defined(OS_UNIX)
    #ifdef OPTION1
        unix_version_option1();
    #endif 
    #ifdef OPTION2
        unix_version_option2();
    #endif 
#elif defined(OS_MSDOS)
    #ifdef OPTIONS2
        msdos_version_options2();
    #endif 
#endif 

3. 
#include 指令
#include 指令可以使另外一个文件被编译，就是包含到我这个程序中被编译。
  
#include <stdio.h> 引入库函数 
#include "add.h"   引入自己程序的头文件
int main ()
{
    int ret = Add(2, 3);
    printf("hehe \n");
}
例1：
#include <> "" 区别：

本地文件包含：用 ""
查找策略：先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标准位置查找头文件。如果找不到就提示编译错误。 
	vs环境的标准头文件路径：c:\Program Files(x86)\Micorsoft Visual studio\vc\include 注：按照自己的安装路径去找 
	linux环境的标准头文件的路径：/user/include

库文件包含：<>
去标准路径下查找，如果找不到就提示编译错误

这样是不是可以说，对于库文件也可以使用""的形式 ？是的，可以
但是这样做效率低了点，当然这样也不容易区分是库文件还是本地工程文件了
视频举例了一个大型项目，编译就花了4个小时，所以更得优化

例2：
重复引入头文件？
linux演示：vim + gcc预编译命令 查看代码确实复制了3份
解决方案：条件编译
写法一：
test.h 
#ifndef __TEST_H__
    #define __TEST_H__

    int Add (int x, int y);

#endif 

写法二：
#pragma once 加上这句代码即可 现代语法写法 
int Add (int x, int y);

注：<<高质量c/c++编程指南>>
参考：<<c语言深度剖析>> 面试笔试的秘密

4. 
其他预处理命令
#error 
#pragma
#line 
... 
```

```c
面试题
请编写宏，计算机结构体中某变量相对于首地址的偏移，并给出说明？
#include <stddef.h>
struct S 
{
    char c1;
    int a;
    char c2;
};
int main ()
{
    printf("%d \n", offsetof(struct S, c1)); 0
    printf("%d \n", offsetof(struct S, a));  4
    printf("%d \n", offsetof(struct S, c2)); 8
}

这道题，就是让你实现一个这样的宏
视频巧妙思路：
#define OFFSETOF (struct_name, member_name) (int)&(((struct_name*)0)->member_name) 
直接思路：
#define OFFSETOF (struct_name, member_name) ((char*)&struct_name - (char*)&member_name)
分析：
偏移量理解
(int)&(((struct_name*)0)->member_name) ???一脸懵逼
(int*)k 将k转换为指针类型，这样k变成了一个指向int的指针 

(int)地址 -> ？
这里取0是因为，方便后面做偏移量的时候，不用减

代码跑不起来？
```

​	