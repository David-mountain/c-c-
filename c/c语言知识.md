# c语言知识

## (零) 此总结后面会有大型练手项目

## (一) 数据类型

### 1. 数据类型介绍

#### 1.1 内置类型

char short int long float double 

整型家族：

​	char(存的ascii值，也归类整型)

​		unsigned char  0~255

​		signed char      -128~127

​	short 

​		unsigned short [int]     // []表示可写可不写

​		signed short [int]

​	int 

​		unsigned int

​		signed int 

​	long 

​		unsigned long [int]

​		signed int [int]

浮点型家族：

​	float 

​	double 

#### 1.2 自定义类型(构造类型)

数组类型    int arr[length]

结构体类型 struct

枚举类型     enum

联合类型     union

指针类型

​	int* pi;

​	char* pc;

​	float* pf;

​	void* pv;

#### 1.3 c没有字符串类型

#### 1.4 类型的意义

i. 使用这个类型开辟内存空间的大小(大小决定了使用范围)

ii. 如何看待内存空间的视角

#### 1.5 空类型void

void 表示空类型(无类型)

通常应用于函数的返回类型，函数的参数，指针类型

​	void* pv;

​	void test () {}

​	void test (void) {} 或者不写void

### 2. 整型在内存中的存储

#### 2.1 原码、反码、补码

一个变量的创建要在内存中开辟空间的，空间的大小是根据不同的类型决定的。

int a = 20;  14 00 00 00 

int b = -10; f6  ff  ff  ff ？

你会好奇这些是如何得出来的？

因为计算机中不同的数据类型采用了不同的存储方式，有符号数有三种表示方法，即原码、反码、补码，注意整型和浮点数不是这样的存储方式。 

三种表示方法都是有 符号位和数值位两部分，符号位0正1负，而数值位三种方法则各不相同。

原码：直接将二进制按照正负数的形式翻译成二进制即可

反码：将原码的符号位不变，其他位依次取反即可

补码：反码+1即可？

注意：

无符号数：原码 反码 补码 一样

有符号数：原码 反码 补码 都不一样

```
int a = 20; // 4个字节 32bit 对整型而言，三者都是一样的
00000000 00000000 00000000 00010100 原码  16进制-0x00 00 00 14
00000000 00000000 00000000 00010100 反码
00000000 00000000 00000000 00010100 补码

int b = -10;
10000000 00000000 00000000 00001010 原码
11111111 11111111 11111111 11110101 反码 
11111111 11111111 11111111 11110110 补码  16进制-0xff ff ff f6 (快捷1111->15)

```

####  2.1为什么会有反码 补码这些个万一呢？

反码忘记了，只记得补码了

i). 对于整型而言，数据存放在内存中，是以补码的形式的 ？

因为在计算机系统中，数值一律用补码来表示和存储。原因是使用补码，可以将符号位和数值域统一处理，

同时，加法和减法也可以统一处理(cpu只有加法器)，此外，补码和原码相互转换，其运算过程是相同的，

不需要额外的硬件电路。

ii). 只有加法，那 + - * / 呢？ 

```
没有补码错误案例：
1-1 -> 1+(-1)
1的原码：  00000000 00000000 00000000 00000001
-1的原码： 10000000 00000000 00000000 00000001
相加：     10000000 00000000 00000000 00000010
结果：    -2 (不对)

科学家想出来了补码来解决。
1的补码：  00000000 00000000 00000000 00000001
-1的补码： 11111111 11111111 11111111 11111111 
相加：     10000000 00000000 00000000 00000000 0
结果：     0 (正确)
因为我是int型，32位，最高位1被干掉了，剩下全是0了。

这是减法的过程，也是补码的过程。
```

### 3. 大小端字节序列介绍及判断

#### 3.1 引出大小端

我们发现之前int a = 20;的16进制数，应该是0x00 00 00 14，但是在vscode内存显示中是反过来的，是14 00 00 00 这是为什么呢？而且也不是完全的数字相反？这就涉及到大小端了。

首先我们要明确的是不要以为vs这里是16进制的数，就以为内存中存储的是16进制的数，内存中始终都是存放的0、1数字，这里转成16进制只是为了方便程序员看。

另外一个需要明确的点是，数据在内存中的存储顺序，是以字节的顺序，不是二进制的顺序。比如0x 11 22 33 44，这里11是一个字节，是以字节为基本存储单位的。

还有一个点，内存空间是有编号的，编号有大有小的，地址线，编号小的叫低地址，大的叫高地址。

大端(存储)模式：指数据的低位保存在地址的高地址中，而数据的高位，保存在内存的低地址中。(低高大)

小端(存储)模式：指数据的低位保存在地址的低地址中，而数据的高位，保存在内存的高地址中。(低低小)

```
0x11(高位) 22 33 44(低位)   16进制
 11(低地址)22 33 44(高地址)  内存中的显示(转成16进制是为了方便看) 大端存储模式 
 44(低地址)33 22 11(高地址)  小端存储模式 
 
 vs内存显示：左(低)->右(高)
 16进制数字：左(高)->右(低)
```

#### 3.2 思考为什么有大端小端呢？

因为在计算机系统的，我们是以字节为单位的，每个地址单元都对应一个字节。

一个字节为8bit,C语言中还有16bit的short，32bit的long(看具体的编译器)

对于位数大于8位的处理器，例如16位或32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个或者多个字节的安排问题，因此就出现了大端存储模式和小端存储模式。

```
例：一个16bit的short型x,在内存中的地址为0x0010，x的值为0x1122
0x 11(高位) 22(低位)
 00(低地址，高位)10(高地址，低位) 若按此地址存，大端模式
 00(低地址，低位)10(高地址，高位) 若按此地址存，小端模式
 
 采用小端模式： 常用的x86结构、ARM DSP
 采用大端模式： KELL CS1
 有些ARM处理器可以自己选择大端或小端模式。
```

#### 3.3 百度笔试题 大小端判断

请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。10分

```
算法思路1：
int a = 20;
0x 00 00 00 14(低位)
 14(高位地址) 00 00 00  -小端
 00(低位地址) 00 00 00  -大端 
注意：内存中是以字节为单位的。
所以，我们想到了一个思路，只需要找出第一个字节，看是否是00即可，然后我们思考如何访问一个字节呢？想到了char*，访问一个整型数据的第一个字节即可。

答案：最好封装成函数
#include <stdio.h>
int check_sys1 ()
{
  int a = 1; // 设置1方便
  char* p = (char*)&a;
  if ( *p == 1 )
  	return 1;
  else 
  	return 0;
}
// 简化版
int check_sys2 ()
{
  int a = 1;
  return (*char( *)&a);
}
// 测试
int main ()
{
  int ret = check_sys();
  if ( ret == 1 )
  	printf("小端\n");
  else 
  	printf("大端\n");
}
```

拓展指针类型的意义：

1. 指针类型决定了指针解引用操作符能访问几个字节  

   char* p ,* p可以访问1个字节，int* *p, *p可以访问4个字节

2. 指针类型决定了指针+1 -1时候的步长，可以加减几个字节。

   char* p; p+1跳过1个字节， int *p; p+1跳过4个字节

   ​

### 4. 浮点数在内存中的存储解析

#### 4.1 浮点数介绍

```c
float 
double 
long double 
float f1 = 3.1415f;
double d1 = 1E10;  // 1*10的10次方
printf("%f \n", f1);
printf("%lf \n", d1); 

浮点数取值范围：float.h中有定义
数据类型的取值范围：limits.h中有定义
```

#### 4.2 练习题

```c
int main ()
{
  int n = 9;
  float* pFloat = (float*)&n;
  printf("n的值为：%d \n", n);             // 9
  printf("*pFloat的值为：%f \n", *pFloat); // 0.000000
  
  *pFloat = 9.0;
  printf("num的值为：%d \n", n);           // 1094567616
  printf("*pFloat的值为：%f \n", *pFloat); // 9.000000
}
得出结论：整型和浮点型在内存中的存储方式不一样的。

解释浮点数在计算机内部的表示方法：
根据国际标配IEEE(电气和电子工程协会)754，任意一个二进制浮点数V可以表示成下面的形式： (-1)^S * M * 2^E 。
	(-1)^s表示符号位，当s=0，V为正数，当s=1，V为负数
	M表示有效数字，大于等于1，小于2  
	2^E表示指数位
举例1：
十进制   5.0
二进制 101.0
(-1)^0 * 1.01 * 2^2
(-1)^S *  M   * 2^E 
S = 0，M = 1.01，E = 2
举例2：
十进制   -5.0
二进制 -101.0
(-1)^1 * 1.01 * 2^2
(-1)^S *  M   * 2^E 
S = 1，M = 1.01，E = 2
  
IEEE规定：对于32位的浮点数，最高的1位是符号位S,接着的8位是指数E，剩下的23位有效数字M。1+8+23
注意：E是一个无符号整数，但是E是有可能是负数的。8位，0-255。
解决负数的方案是：存入内存时E的真实值必须再加上一个中间值，对于8位的E，这个中间数是127。如果E = -1；存入内存的时候 +127 = 126(这是存入内存的最终值)。
```

```c
int main ()
{
  float f = 5.5; // 内存中存的值是什么？
}
分析：
(-1)^0 * 1.011 * 2^2 
S = 0
M = 1.011 
E = 2
32bit: 0 10000001 01100000000000000000000
16进制：0x40 b0 00 00 
10000001? 
  0000 0010  +2
  0111 1111  127(规则要求+127)
  1000 0001  129(最终结果)
二进制快速转16进制？
	0100 0000 1011 0000...0000
  0100->2^2=4(16)
  1011->2^3+2^1+2^0=11->b(16)
  得：40 b0 00 00 
  
因为我们是小端模式，所以最后内存显示是：00 00 0b 40
```

#### 4.3 取浮点数

上面都是存入浮点数类型，取出浮点数还有一些特殊情况。

指数E从内存中取出还可以再分成三种情况：

1. E不全为0或不全为1
2. E全为0
3. E全为1

### 5. 代码题

```c
int main ()
{
  char a = -1;
  signed char b = -1;
  unsigned char c = -1;
  printf("a=%d,b=%d,c=%d", a, b, c);
}
-1 -1 255 
分析：
char a = -1;
	10000000 00000000 00000000 00000001 原码
	11111111 11111111 11111111 11111110 反码
	11111111 11111111 11111111 11111111 补码
	11111111 char型 1个字节只能保存8位 截取8位
printf("a=%d,b=%d,c=%d", a, b, c);
	a 打印整型%d,然而这里是字符型，所以需要类型提升。
	11111111最高位的1当成是符号位，前面补1，至共32位，这是补码的。
	然后拿着补码倒回去算原码，-1。口诀：-1的补码才全是1！！
	b 同上，不要被signed吓到，可以省略的。
	c 无符号数，高位直接补0，0000...11111111 ->255 口诀：8个1是255
```

```c
 int main ()
{
  char a = -128;
  printf("%u\n", a);
}
分析：
首先强调自己明白了一个点，和上面的无符号，unsigned char和这里(signed) char，这个的不同直接决定了后面是直接补充0还是看最高位的数来决定。
10000000 00000000 00000000 10000000 原码
11111111 11111111 11111111 01111111 反码 
11111111 11111111 11111111 10000000 补码 
10000000 char型 发生截断 
这里打印%u无符号整数，需要类型提升，注意这里是char a，不是unsgined char a，所以这里需要看最高位的，来决定补充0还是1，这里是1，前面补充1，1111111...10000000，这里补码整型提升后还是补码，又因为这里是打印无符号数的，原反补码都是一样的。所以直接将这个二进制转成十进制即可。

int main ()
{
  char a = 128;
  printf("%u\n", a);	
}
```

```
char类型能表示的数值范围：
1个字节，8个bit位。

--------------unsigned char:
当成补码看  数值
0000 0000  0
0000 0001  1
...
1000 0000  128 *
1000 0001  129
...
111111111  255

--------------signed char:
当成补码看  数值
0000 0000  0
0000 0001  1
...
0111 1111  127 
1000 0000  -128 *
1000 0001  -127
...
111111111  -1 (反码1111 1110 -> 原码1000 0001)

--------------分析-128来源？
对于有符号位整数，二进制的最高位表示正负，不表示数值，最高位是0时表示正数，为1时表示负数，这样一来，能表示数值的就剩下(n-1)位了。
比如：char a = -1; 二进制表示就是1000 0001，1表示0000 0001.
所以，signed char 型出去符号位剩下的7位最大是 1111 111 = 127；加上符号位是：0 1111111 = 127; 那范围也应该是-127~127阿，哪里来的-128？

这里补充一个知识，反码的由来，从减法中来的：？
1-1=？计算机只会做加法，会转换成1+(-1)
0000 0001  1  (原码)
1000 0001  -1 (原码)
0000 0010  -2(相加结果不对)
为了避免减法运算错误，发明了反码。
规定：正数的反码原码相同，负数的反码是原码除了符号位，其余都取反。
0000 0001  1  (反码)
1111 1110  -1 (反码)
1111 1111  反码 -> 原码 1000 0000 = -0 (正确) 

补码的由来，解决重复的0：？
虽然反码解决了相减的问题，却又带来了另外一个问题，-0，既然0000 0000表示0，那么就没有-0的必要了，出现了+0=-0=0，其实一个0就够了，为了避免两个0的问题，科学家又发明了补码。
规定：整数的补码是其本身，负数的补码为其反码+1。
0000 0001  1的补码
1111 1111  -1的补码
1 0000 0000 结果是9位，由于是char型，8个bit，保留8位，最高位1被丢弃，结果是0.
-0 原码：1000 0000 
   补码：1000 0000 0 由于char是八位，取低八位
   补码：0000 0000
+0 原码：0000 0000
   补码：0000 0000 
虽然补码都是相同的，但是有两个0，既然有两个0，况且0既不是整正数，又不是负数，用原码 0000 0000 表示就行了，这样一来，有符号的char，原码都用来表示-127~127之间的数。唯独原码1000 000没有用。
其实你自己用排列组合也可以算出来，0??? ????，也能表示128个数，0~127刚刚好。
1??? ????，也能表示128个数。总共signed char 有256个数。最后谈论剩下的那个1000 0000.为什么-0可以表示-128？

如果不限制为char型，(即不要限定为8位)，再来看，-128的原码：1 1000 0000，9位。
最高符号位，再算它的反码：1 0111 1111，进而，补码为：1 1000 0000，这是-128的补码。
128的原码和-0(1000 0000)的原码是不相同的，但是在char中，是可以用1000 000表示-128的，关键在于char是8位，它把-128的最高位符号位1丢弃了，截断后-128的原码为 1000 000 和-0的原码相同，也就是说 1000 0000 和-128丢弃最高位之后余下的8位相同，所以才可以用-0表示-128，这样，当初剩余的-0(10000 0000)，被拿来表示截断后的-128，因为即使截断后的-128和char型范围的其他数(-127~127)运算也不会影响结果，所以才敢这样表示-128.比如：
-128+(-1) = ?
1000 0000    丢弃最高位的-128
 111 1111    -1
10111 1111   char取八位，结果不正确，没关系，结果-129本来就超出char型了，当然不能表示

-128+127 = ？
1000 0000   -128
0111 1111
1111 1111   -1(正确)

char a = -128;
printf("%d", a); -128 记死把这个！最高位丢弃了，输出时应该是1000 000的原码的十进制数-0，但为什么能输出-128呢？以后自己研究。
char a = -129;
printf("%d", a); -129在补码为10 0111 1111 只取后八位存储，即0111 1111，这个值刚好是127。

unsigned char a = 1;
if ( 1 > a )
	printf("大于");
else 
	printf("小于");
结果：小于。
a是unsigned无符号，它的八位都用来存储数值，没有符号位，编译器把-1转换成补码为1111 1111，(1000 00001 -> 1111 1110 -> 1111 1111)，但是由于是无符号位，计算机会把 1111 1111，当作是无符号来对待，自然就是 2^8-1=255了，所以原代码是 if( 1 > 255 ) 肯定就是小于。
```

这里要插入一幅图，数值范围的圆图！

```c
int main ()
{
	int i = -20;
  	unsigned int j = 10;
  	printf("%d\n", i+j);
}
-10 
 10000000 00000000 00000000 00010100  -20原码 
 11111111 11111111 11111111 11101011     反码
 11111111 11111111 11111111 11101100     补码
 00000000 00000000 00000000 00001010   10原码反码补码
 11111111 11111111 11111111 11110110   两者补码相加，得结果
 
 11111111 11111111 11111111 11110101   得结果的反码
 10000000 00000000 00000000 00001010   得结果得原码 -10
```

```c
int main ()
{
	unsigned int i;
  	for ( i=9; i>=0; i-- )
    {
      printf("%u\n", i);
    }
}
死循环
我自己还傻傻去算原码反码补码，没有认真读完整个程序就下手了。
因为i是一个无符号整数，不可能是负数阿，取值范围是0~255，就一直满足for循环的判断了，形成了死循环了。
```

```c
int main ()
{
  char a[10000];
  int i;
  for ( i=0; i<10000; i++ )
  {
    a[i] = -1 - i;
  }
  printf("%d", strlen(a));
}
答案未知
和我分析的差不多，但是我还差一步。
知识补充：strlen结束标志：\0
当你以为是随机值的时候，发现本题的重点不是在最后查，而是在赋值阶段。
char型，取值范围-128~127，这里的-1~-10000不可能完全存入的，超出的都会转成这个取值范围的值，比如：
-1-128 = -129 ->
1000 0000 1000 0001  -129原码
1111 1111 0111 1110      反码
1111 1111 0111 1111      补码 
因为char型，保留8位，0111 1111(作为补码)。
最高位是0，计算机认为是正数，是127.
圈圈图(-128 逆时针+1就是 127)
所以，数组里面存放的都是这些值。代码非法访问内存了，这只能作为练习题看看。
```

```c
unsigned char i = 0;
int main ()
{
  for ( i=0; i<255; i++ )
  {
    printf("hello world \n");
  }
}
死循环 
因为是无符号数，取值范围是0~255，这里判断条件是i<255，只有大于255才能终止循环。
```

总结：这几个练习题，其中关于死循环的几个题目，我们可以得出：unsigned 和 char 之类，这几个数据类型导致了不满足for终止循环的条件，从而产生bug。

## (二) 分支和循环

## (三) 操作符

## (四) 指针

## (五) 函数

## (六) 数组

## (七) 文件操作

## (八) 动态分配内存

## (九) 练手项目

