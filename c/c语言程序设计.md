64-while 
90-一维数组
228-位运算
229-& 
	0&0 = 0 与0 被赋值成0，即擦除
	1&0 = 0 与0 被赋值成0，即擦除
	0&1 = 0 与1 得原结果
	1&1 = 1 与1 得原结果
	清零：如果想将一个单元清零，即使其全部二进制位为0，只要找一个二进制数，其中各个位符合以下条件：原来的数中为1的位，新数中相应位为0。然后使二者进行&运算，既可以达到清零目的。 a&0 a即被清零

	取一个数中某些指定位：如有一个整数a(2个字节)想要其中的低字节。只需将a与(377)8进制 按位与即可 这里是a&0xff 8个1--255--ff   a&1 a对应位置被取出来 (回看&性质,因为是1，最后的结果完全就是a决定了，所以可以取出来) 像视频一样整理16-2进制的15个
	
	要想将哪一位保留下来：就与一个数进行&运算，此数在该位取1即可  例：要保留1 3 5 7 位的，另一个数的二进制对应位 1 3 5 7 也是1即可，和上面的的性质一样的，&1保留了，其他位是0，即擦除了

230-|
	0|0 = 0 与0 得原结果 
	1|0 = 1 与0 得原结果
	0|1 = 1 与1 被赋值成1
	1|1 = 1 与1 被赋值成1
	按位或运算常用来对一个数据的某些位定值为1
	我想把0000 0100 都变成1，只需要和一个都是1111 1111的做|运算，即可。其他位置为了防止有影响，都是0，因为0|0=0 1|0=1，即原来是什么，结果依然是什么

231-^ XOR (同0异1)
	0^0 = 0 与0 得原值
	1^0 = 1 与0 得原值
	0^1 = 1 与1 取反值
	1^1 = 0 与1 取反值
	异或意思是判断两个相等得位值是否为异，为异1，同则0
	应用：
	1. 与1相^,使特定位翻转
	2. 与0相^，保留原值
	3. 交换两个值，不用临时变量
		a = a ^ b;
		b = b ^ a;
		a = a ^ b;

	a: 00000100 00100000 00001000 00010011(这里8位取反,前面其他位不变)
	b: 00000000 00000000 00000000 11111111 (看上面性质)

	int a = 3;
	int b = 4;
	a = a ^ b;
	b = b ^ a; // b=b^(a^b)=b^a^b=(b^b)^a=0^a=a ?
	a = a ^ b; // a=(a^b)^(b^(a^b))= 
			// a=a^b^b^a^b=
			// a=a^(b^b)^a^b=
			// a=a^0^a^b=
			// a=a^a^b
			// a=0^b=
			// a=b

232 ~按位取反
	&可以实现同样效果

233 << 
	* 2 
	高位左移后溢出，舍弃

234 >>
	移到右端的低位被舍弃
	在右移时，需要注意符号位问题。
	对无符号数，右移时左边高位移入0，
	对有符号的值，如果原来符号位为0(该数为正)，则左边也是移入0。如果符号位原来为1(即负数)，则左边移入还是1，要取决于所用的计算机系统。有的系统移入0，有的移入1。
	移入0的称为逻辑右移，即简单右移
	移入1的称为算术右移 √
	int a = 0x8000 0001;
	// 10000000 00000000 00000000 00000001
	// 01111111 11111111 11111111 11111111
	a >>= 1;
	//  01000000 00000000 00000000 00000000
	// 11000000 00000000 00000000 00000000
	printf("%x \n", a);
	// c000... 

位运算练习：
	1. 取一个整数a从右端开始的4~7位
		unsigned int a;
		scanf("%x", &a);
		unsigned int b;
		b = 15;
		b<<=4; 聪明阿 这就利用上了
		printf("%x \n", a&b); // 20(16进制) 20(十进制)

		b=~(~0<<4); 
		printf("%x \n", (a>>4)&b);

	2. 循环移位。。要求将a进行右循环移位，将a右循环移n位，即将a中 原来左面(16-n)位右移n位，原来右端n位移到最左面n位
		unsigned short int a;
		scanf("%x", &a); ox1234 00010010 00110100
		int n;
		scanf("%d", &n); 4

		unsigned short int b, c;
		b = a>>n;  00000001 00100011

		c=a<<(16-n);
			01000000 00000000
			00000001 00100011 b
			01000001 00100011 |
			4123 秒阿 
		printf("%x \n". b|c); 

238- 位段 

242- 文件 

3- 
	scanf("%d %d %d", &a, &b,  &c);

4- 算法
	为解决一个问题而采取的方法和步骤
	算法分类：数值运算 非数值运算
5- 1*2*3*4*5
	算法1：硬乘 1*2 然后*3 
	算法2：p=1 i=2 p=p * i ++i; i<=5 
	
	50个学生，成绩大于80以上的学号和成绩输出
	判断2000-2500每一年是否是闰年
	1-1/2+1/3-1/4+...+1/99-1/100 
		int main ()
		{
			while (deno <= 100) 
			{
				int sign = 1;
				double sum = 1.0;
				int deno = 2;
				sign = (-1)*sign; 标识正负
				double term = sign*(1/deno);
				sum += term;
				++deno;
			}
		}
		对比视频代码：我上面代码就很凌乱 定义 初始化区分开来 
		int main ()
		{
			float sum, term;
			int deno, sign;
			sum = 1.0;
			deno = 2;
			sign = 1;

			while ( deno <= 100 )
			{
				sign = -1 * sign;
				term = sign * 1.0 / deno;
				sum += term;
				++deno;
			}
			printf("1-1/2+...1/100= %f", sum);
		}
	对一个大于或等于3的正整数，判断它是不是一个素数
		从2开始

6- 如何表示一个算法
	常用方法：自然语言 传统流程  N-S流程 伪代码 PAD图等
7- 用计算机语言表示算法
	结构化程序设计方法：
		自顶向下
		逐步细化(分而治之)
		模块化设计(分而治之)
		结构化编码(顺序、选择、循环结构) 

8- 作业截图word 
	交换2个变量
	输入10个数 找出最大 
		int a;
		int max;

		scanf("%d", &a);
		max = a;

		for (int i=2; i<=10; ++i)
		{
			scanf("%d", &a);
			if ( a > max )
				max = a;
		}
		printf("max=%d \n", max);
	a b c 排序，三个数最小输出 a(存最小) b c
		int a, b, c;
		int temp;
		scanf("a=%d b=%d c=%d", &a, &b, &c);
		if ( a>b )
		{
			temp = a;
			a = b;
			b = temp;
		}
		if ( b>c )
		{
			temp = b;
			b = c;
			c = temp;
		}
		if ( a>b )
		{
			temp = a;
			a = b;
			b = temp;
		}
		printf("a=%d b=%d c=%d", a, b, c);

	1+2+..+100
		int sum;
		sum = 0;
		for (int i=1; i<=100; ++i)
		{
			sum += i;
		}
		printf("1+...+100=%d", sum);

	判断一个数能否被3 5整除
		int n;
		scanf("n=%d", &n); 严格按照这种格式输入哟
		if ( n%3==0 && n%5==0 )
			printf("%d 能 \n", n);
		else 
			printf("%d 不能 \n", n);

	100-200之间素数输出
		int judge (int n)
		{
			int w;
			w = 0;
			for (int i=2; i<=sqrt(n); ++i)
			{
				int r;
				r = n % i;
				if (r==0)
				{
					w = 1;
					break;
				}
			}

			return w; 优化

		<!-- 	if (w == 0) 
				return 1; 素数
			else 
				return 0; -->
		}
		int main ()
		{
			int n;
			for (n=100; n<=200; ++i)
			{
				if (judge(n) == 0)
				printf("%d是素数 \n", n);
			}
			else 
			{
				printf("%d不是素数 \n", n);
			}
		}

	两个数m n的最大公约数 
		int main ()
		{
			int m, n;
			int min;
			scanf("%d %d", &m, &n);

			if (m<n)
				min = m;
			else
				min = n;

			for (int i=min; i>=1; --i)
			{
				if (m%i==0 && n%i==0)
				{
					printf("%d是%d和%d的最大公约数 \n", i, m, n);
					break;
				}
			}
		}

	ax^2 + bx + c = 0的根。分别考虑两同根 两不同根 
		float a, b, c;
		scanf("a=%d b=%d c=%d", &a, &b, &c);
		float disc;
		disc = b*b-4*a*c;

		if (disc > 0)
		{
			printf("x1=%f", (-b+sqrt(disc)) / (2*a));
			printf("x2=%f", (-b-sqrt(disc)) / (2*a));
		}
		else if (disc == 0)
		{
			printf("x=%f", -b/(2*a));
		}
		else 
		{
			printf("方程没有实根 \n");
		}

10- 3章 数据类型、运算符与表达式
	算法处理的对象是数据 截图word，而数据是以某种特定的形式存在的(例如整数 实数 字符等形式)
	所谓数据结构指的是数据的组织形式
	C语言的数据结构是以数据类型形式出现的

11- 常量和变量
	常量和符号常量 
	
29- 数据输入输出的概念以及C中的实现

90- 一维数组
？- 函数
140- 全局变量

175- 指针
204- 结构体与共用体 

--------------
175- 指针
变量的属性：名、值和地址
变量的访问方式：直接访问 间接访问
变量的地址称为该变量的指针
指针变量是存放地址的变量

vs看内存 单步调试。
%d %x-打印地址16进制输出 %p-打印地址

int i, j;
int * i_pointer, * j_pointer;

i_pointer = &i;
j_pointer = &j;

printf("i=%d \n", * i_pointer); * i_pointer == i 
printf("i=%d \n", * j_pointer); * j_pointer == j 

177- 
int i;
int * i_pointer;

i_pointer = &i;

printf("i=%d \n", i);
printf("* i_pointer=%d \n", * i_pointer);

178-
定义指针变量的一般形式：
基类型 * 指针变量名；

我也犯错了，输入scanf("%d,%d")
输入时候没有输入逗号，直接就是空格

* p++
* ++ 同优先级，结合方向自右向左，这里等价于* (p++) 即先引用p的值，实现* p的运算，然后再p自增1 
* (p++) 与 * (++p) 作用不同哈？
++(* p)  元素值加+1 

若p当前指向a数组中第i个元素a[i]，则：
* (p--) 相当于a[i--]，先对p进行* 运算，(求p所指向的元素的值)，再使p自减.

	//输出数组100个元素 
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	int * p = arr;
	while ( p < arr+10 )
		printf("%d ", * p++);

书 237页---






