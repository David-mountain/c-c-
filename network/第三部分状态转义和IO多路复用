1 
线程版服务器 
主线程只干监听 子线程服务客户端的 以前是进程，现在是线程 
看吧，然后教学代码，在来写，不然。
覆盖什么问题？不是很明白
这里也是写一个回射服务器哈 
多是C语言的语法 底层还是C写的，上层应用是C++写的！！！
写完测试 
acwing 学习数据结构与算法
放在堆区 如果放在栈去 提取速度和复制速度快慢可能会导致覆盖问题

2
TCP状态转换图
粗的实线- 主动方
虚线- 被动方
细的实线- 特殊情况
三次招手 四次挥手 
netstat命令是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息 有很多参数选项 常用 
netstat -anp | grep 8000  

3
半关闭
底层是到CLOSED才是关闭  客户端先会关闭写端，可以继续收 处于半关闭状态-系统操作的
我能不能自己控制半关闭，需要函数 int shutdown(int sockfd, int how)
how: SHUT_RD(0)-关闭读端 SHUT_WR(1)-关闭写端 SHUT_RDWR(2)-关闭读写端
close则是 关闭一个计数器-1 只会影响一个 而shutdown则是当前文件描述符影响所有的使用

4
心跳包 
如果对方异常断开，本机检测不到，会一直等待，浪费资源
需要设置TCP的保持连接，作用就是每隔一定的时间间隔 发送探测，如果连续发送多个还未回，就将此连接断开
man setsockopt 
SO_KEEPALIVE 保持连接检测对方主机是否崩溃，避免服务器永远阻塞于TCP连接的输入
根据业务不同，可能写的心跳包也不一样的 没什么特殊要求，可以使用它提供的这个
setsockopt()

心跳包 最小粒度 1.2个字节就可以了
乒乓包：携带比较多的数据的心跳包，特殊情况
用法这些很简单，理解了练习哈就可以了
这是创建套接字之后才后的哈

5 
端口复用
端口重新启用
教学中同学想，自己组包 飞秋
8000端口已经被用了，我就想使用8000呢？
之前的8000就没有用了，最后启动这个端口的才会使用到
setsockopt() 里面有个参数 我省略了

6
多路IO转接技术
高并发服务器 并发量大点
查看进程中栈的空间大小 ulimit -a  这个方案不好？内存也可能用完 不是很明白

阻塞等待
	5个进程，1个监听，4个服务，现在4个客户端
	会有什么问题？客户端不是每时每刻发的，有间隔的
	read()是阻塞的，这样效率很低的
	又来一个客户，又开一个进程，浪费资源
	每个进程线程都阻塞等待着，所以叫阻塞等待， 消耗资源
非阻塞忙轮询
	3个客户 一个老板 几个服务器 轮询看这些文件描述符 很消耗CPU 不是很理想这种
多路IO转接(多路IO复用)
	IO 对应文件描述符的读写缓冲区 监听文件描述符的读写缓冲区
	增加一个中间层秘书 监听轮询 有需要服务(数据发来了)就报告给老板去服务
	有个内核监听机制就是这个秘书(内核监听有三种技术方式，poll epoll select) 
	内核监听多个文件描述符的属性(读写缓冲区)变化
	如果某个文件描述符的读缓冲区变化了，这个时候就是可以读了，将这个事件报告给应用层

	poll epoll select
	windows 使用select较多，跨平台
	poll 使用较少 
	epoll 使用较多 linux下用 android也是linux麻 

7
select API
复习文件描述符，进程控制块PCB 
内核表什么样子？位图 和MFC中 WIN32的位图什么区别
默认已经有3个了哈 0 1 2，stdin stdout strerr 
man select 
功能：监听多个文件描述符的属性变化 (读写异常)
硬件的也可以监听 
文件描述符集合 
返回值是： 是变化的文件描述符的个数

9
select实现原理
应用层父进程 -> 内核select -> lfd cfd1 cfd2 cfd3 
内核秘书效率不高，每次都是应用层拷贝到内核中
搞一个oldset存放所有需要监听的 文件描述符集合
内核监听中把没有事件触发的文件描述符踢出，然后返回给应用层，应用层遍历即可

代码实现
#define PORT 8888      别名 数据

1.创建套接字 绑定
2.监听
3.while
	根据select的返回值来判断是否文件描述符有变化

4.select监听 

这里代码细节很多部分不是很懂 
得自己写哈才行 

11
select优缺点
优点：缺点
自定义数组 而不是使用系统最小到大的数组去遍历

假设现在4-1023个文件描述符需要监听，但是只有5-1002发来消息 ， 无解  
大量并发，少量活跃，select效率低 

13
数组版select 
有点迷迷糊糊的 
man dup2()
遇到空的 把最大的挪到这个空的 这样效率会高点点 这样可以保证每个依次都有指向

14
poll 
优点：相对于select没有最大1024文件描述符限制
	请求和返回是分离 
	可自己配置大小 
	可以使用cat命令查看一个进程可以打开的socket描述符上限 
	cat /proc/...  这个是在内存中的，即机器开机才会有的
缺点：和select差不多

监听的不是文件描述符，二是结构体 (fd event = 读 revent = 读)
会自动更新，不用我们每次去原有的再复制
man poll 
监听数组 

15
poll代码实现
位操作 更快把
和昨天的select数组版 差不多

16
epoll API
这个的产生就是为了解决之前的问题的

没有文件描述符1024的限制
以后每次监听 都不要此将需要监听的文件描述符拷贝到内核
返回的是已经变化的文件描述符，不需要遍历树

进程 -> 内核epoll 
创建一棵红黑树 
将需要监听的文件描述符上树
监听

变化的会放到内核链表中 就不用遍历树了 把内核链表拷贝到应用层

创建：
epoll_create() 返回树的句柄

上树 下树 修改节点：
man epoll 
epoll_ctl()

树的节点是结构体，不是基本数据类型，结构体存放是上树的节点，
typedef union epoll_data 共用体
{
	void *ptr;
	int fd;
	uint32_t u32;
	uint64_t u64;
} epoll_data_t;

struct epoll_event 
{
	uint32_t events;
	epoll_data_t data;
}

节点如何上树呢？
int epfd = epoll.create(1);
struct epoll event ev;
ev.data.fd = cfd;
ev.events = EPOLLIN;
epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &ev);

监听：
监听树上文件描述符的变化
epoll_wait()

父子进程的通信 管道 + epoll技术 到这里我差点忘记了这个技术产生的背景，就是客户端服务端通信的
时候，效率问题，所以，这个技术应该说是用在 任意通信两方的技术 不仅仅是服务端客户端的
涉及到通信就可以考虑使用 

17 epoll代码实现
回顾：上树 下树 等

创建套接字 绑定
监听
创建树
将lfd上树 
while监听 

18
跳 

19 epoll的两种工作方式
只要缓冲区有数据，就会触发，这种触发方式叫水平触发，
比如接收到数据，然后要触发十次的情况，但是epoll_wait是个系统调用，触发多了也不好，影响效率
工作种不怎么使用这种水平触发，边缘触发，数据来一次，我只触发一次epoll_wait，如果数据没有读取干净，
最后read阻塞，？

还有种叫边缘触发

水平触发LT：持续的高电平或者持续的低电平
边缘触发ET：电平由高到低的一个变化或者由低到高的变化

epoll_wait的水平触发和边沿触发
监听读缓冲区的变化：
水平触发：只要读缓冲区有数据就会触发epoll_wait 
边沿触发：数据来一次，epoll_wait只触发一次，一次是否能处理完呢？必须要都干净每次

监听写缓冲区的变化： (只能用边沿触发)
水平触发：只要可以写，就会触发
边沿触发：数据从有到无，就会触发
     满了，就发出去，就又可以写了

20 epoll的边沿触发和水平触发
默认是水平触发
如何设置成边沿触发 ev.events = EPOLLIN | EPOLLET(边沿触发)  (man epoll_ctrl)
如何一次将数据读干净？
循环读+设置非阻塞模式 
	设置非阻塞模式：
	int flags = fcntl(cfd, F_GETFL);
	flags |= O_NONBLOCK;
	fcntl(cfd, F_SETFL, flags);

如果读一个缓冲区，缓冲区没有数据，如果是带阻塞，就阻塞等待，
如果是非阻塞，返回值等于-1，并且会将errno值设置我EAGAIN-宏

思路：
因为设置为水平触发，只要缓冲区有数据epoll_wait就会被触发 epoll_wait是一个系统调用，尽量少调用
所以尽量使用边沿触发，边沿触发数据一次只触发一次，这个时候要求一次性将数据读完，所以while循环读，
读到最后read默认带阻塞，不能让read阻塞，因为不能再去监听，设置cfd为非阻塞，read读到最后一次返回值
为-1，判断errno的值为EAGAIN,代码数据读干净了

水平触发-写的时候不能用，最后还是用边沿触发

工作中 使用边沿触发 + 非阻塞 = 高速模式 ！


