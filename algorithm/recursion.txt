BFS - QUEUE

DFS - 解决二叉树大部分问题
大部分的二叉树问题本质上都是二叉树的遍历问题！！！
要遍历二叉树来解决问题，大部分使用前序遍历和后序遍历即可

练习实践：二叉树最大深度 前序遍历 后序遍历

多次调用递归：
	递归处理多叉树
	 多叉树没有中序遍历，不能确定把根节点放在哪一个子节点的后面

培养抽象思维：从具体场景中抽象出对应的数据结构
	员工信息 [ [1,5[2,3]], [2,3,[]], [3,3,[]] ]
	给你一个员工id，求员工及其下属的重要度之和
	5+3+3 = 11 
	尝试找出问题背后的数据结构
	当前这个不就是一个多叉树吗？ 每个节点就是一个员工
	！！！这里相当重要，然后求重要度之和，这里就抽象成了树的遍历问题 遍历过程中节点中重要度相加
	struct node 
	{
		int id;
		int importance;
		int subIds[];
	}

DFS可以解决大部分图论问题
	大部分图论问题就是图论遍历问题

递归的实际应用：
	线性数据结构 -- 多用迭代 理解 性能好
	非线性结构 -- 二叉树 多叉树 图结构 多用递归

	排序算法：快速排序 归并排序 
	汉诺塔
	分治
	回溯

	快速排序：
		重点是：对于这个问题的树抽象化，算法本身不重要，对于这个问题的分析更重要，可以让我举一反三
		算法无所谓，重点是对于这个算法问题的分析，对于问题的剖析值得借鉴的
		快慢指针 判断即可
		递的过程中分区
	归并排序：同上 分析更重要
		也是树抽象化，然后才决定使用什么样的数据结构去实现这个算法，我们学习的核心是
		用代码实现算法即可，我们不是研究算法
		这些简直就是极其符合递归的 
		这里还涉及一个 合并两个有序的数组区间 我记得这是一个力扣题
		归的过程中 merge(int start, int mid, int end)

	汉诺塔
		起始柱子 目标柱子 缓冲柱子
		拆分大问题 拆成3步 直至最后的最小可解子问题
		这个拆分，是一步一步去尝试，自己找规律找出来的
		



