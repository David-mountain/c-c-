堆栈 场景区分
看地址让我想到了 内存4分区 
using namespace LVXIN; 含义不明确 当前默认的是使用 LVXIN 如果要使用全局的则是前面加 ::
思考题：
1、请问如何在堆空间上分配和释放指针数组；
const char* ps[] = {"abc","efg","test",NULL};
2、在堆空间上分配和释放二维数组；
double ds[3][12] = {89.8,66.4,77.99};
cin cout 类的实现
int& k = n;//挂在n变量 p = &n; 
k = m;//这个语句是赋值不是挂载语法 就不可更改了？？
struct中 混合了数据结构和处理数据结构的函数
void Print(vector<double>& v) {}
size_t i = -1, size = v.size(); 突然觉得好陌生了 
C++封装类的高明：有两项高明
a)通过封装类，程序员可以定义任意多的动态数组对象（链表对象等）
（你想想C语言能实现吗？）
b)模板技术也叫泛型技术，程序员可以定义任意多种类型的数据来使用算法类
& 不用&取地址了，void swap(int& i, int& j)    swap(x, y);
const float PI = 3.14159f; 这个放在main里面，和放在main之外但是不是其他函数的位置的这种全局，二者有什么区别？
vector 方法有 
int(v.size())  (int)v.size()  
myints.insert(myints.end(), 10, 100); 不熟悉
strstr 这个证明之前c的字符串还没有总结到位 突然想起来，之前只是看了练了一遍，就过了？
它是今后泛型语法起源，C++模板技术的内部原理就是重载的继续升级。
但凡内部有指针变量的不能保存 ，也不能用于今后网络数据传输。
今后所有含有指针的数据结构都不能发送，list,vector,map等。 错误代码演示呢
extern static 
无论VC++升级到什么版本，语言标准不一定升级。
int * p1 = (int*)malloc(sizeof(int)*5);
int *p1 = new int[5];
封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！ ??想起来了，就是像鸭子的案例 走同一个接口，不同的效果，不就实现了接口重用了
一般情况下，构造函数是专门用来初始化对成员变量的 所以最好不要在构造函数中进行与对象的初始化无关的操作。
构造函数分为无参数，有参数和拷贝构造函数   使用=符号来调用构造函数 
拷贝构造函数：拷贝构造函数是特殊的构造，主要是用一个已有对象整体初始化新的对象。

第五天完了
我觉得最好还是一天或者二天就总结，多几天就很麻烦了














