--进程和程序
回想昨天学的 IO函数等
之前遗留的 时间相关函数
utime time 
看man手册

执行中的程序 进程
程序是静态的，进程是动态的
有生命周期 进程
卡一下 CPU忙不过来 
在linux系统中，OS是通过进程去完成一个个的任务的，进程是管理事务的最小单位
进程拥有自己独立的处理环境和系统资源

单道程序设计 多道程序设计(必须有硬件基础)
时间片轮转
并行：(同时)指在同一时间，有多条指令在(多个处理器)上同时执行
并发：(交替)指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行
人眼是毫秒级的，计算机则是更小1秒10亿次

MMU 内存管理单元
他是CPU用来管理虚拟存储器、蓄力存储器的控制线路
同时也负责虚拟地址和物理地址

进程控制块PCB(进程控制块)
内部成员很多 掌握部分即可
vim /user/src/linux-header-4.10.
task_struct 结构体 linux内核的结构体
命令模式 /task_struct 按n下一个 搜索字符

进程的状态(因为进程是动态的，才有状态一说，程序则没有)
三态模型 五态模型
所有的资源都已经被调度好了，只差调用了，这叫就绪态
僵尸态 子进程挂了，没有收尸 
停止态 运行态收到一个SIGTSTP信号就转为停止态
不可中断等待态 
可中断等待态 

除了就绪态能到 运行态，其他所有态都不能直接到运行态
ps aux 查看进程状态
USER 所属者
VSZ 虚拟地址
RSS 空闲地址
TTY 设备终端 ？？
STAT --进程状态
STAR 起始时间 
TIME 运行时间 
COMMAND 命令

都是看文档来的 视频中说 
进程是一个具有一定独立功能的程序，他是操作系统执行的基本单元

进程相关命令：
ps -a 
tty-是终端? 
-x 现实没有控制终端的进程

top 动态显示运行中的进程 
kill 
指定进程号的进程，需要配合PS使用
kill [-signal] pid 

sleep 3000 前台执行 
sleep 3000 & 后台执行 不占用终端
ctrl + c无法干掉后台的进程 
ps -a 
kill 83190(进程号)
ps -a 这个进程被杀掉了

kill -9 9378 有些无法杀死，强制结束

ps aux | grep sleep 

存在进程名相同的进程，无法使用进程名杀死
进程号是不一样的 

killall 通过名字杀死进程 都杀死

--进程号和相关函数
2^16 65536
2^15 32768 
进程号范围：0-32767
ps -a 

三个不同的进程号：
进程号：PID
父进程号：PPID
进程组号：PGID

进程号可以被重用
2个头文件 
#include <sys/types.h>
#include <unistd.h>
pid_t getpid(void)
man getpid 查看手册 总是返回正确的 不用判断
pid_t pid = -1;
pid = getpid();
printf("%d",pid);

gcc testpic.c 
./a.out 每次调用进程号都是变化的
./a.out  

pid_t getppid(void);
测试代码自己写 这个父进程号 每次都是一样的
因为视频在终端执行 所有终端的父进程都是bash这个
当时这个父进程号是5710
ps aux | grep 5710 查看这个父进程是什么 是bash 即当前的bash
当前bash创建一个子线程来 执行这个打印进程号的程序

pid_t getppid(pid_t pid)

进程组号和进程号一样，因为当前只有一个进程 即组长

--进程的创建
系统允许一个进程创建新进程，即为子进程
子进程还可以创建新的子进程，形成进程树结构模型
pid_t fork(void)

int main ()
{
	fork();
	printf("hello world");
}
编译之后 子进程 父进程 谁先执行说不准
两次hello world 或者 一次打印
因为如果父进程先打印，就退出了，子进程的打印就没了-错了
这里还是出现在了终端上 因为bash是父进程的父进程 
如果子进程先执行，然后是父进程，就是2次打印。

使用fork()函数得到的是子进程 是父进程的一个复制品
然后子进程就不会从fork()开始执行了，从后面一句开始执行
fork 代价很大

取指令
分析指令
执行指令
三级流水 三条指令整条向上挪动 计算机系统结构中的
说这些主要就是为了 讲解为什么执行的结果 子进程的PC指针也是FORK之后
因为父进程此时PC指针指向了fork之后，子进程是父进程的拷贝
这决定了执行的流程

linux fork通过写时拷贝，推迟甚至避免拷贝数据的技术
读时共享 写时拷贝

--父子进程关系
上面父子进程谁先执行 不好说的 有多个调度算法
使用fork代价很大的 
子进程相比父进程 只有小量的信息不一样 其他全是复制
解决： 写时拷贝 读时共享 

--区分父子进程
并发编程中 父进程做一件事 子进程做一件事 如何区分二者
父进程中没有接口 可以获取到子进程的 pid 
fork在子进程中返回0 父进程中返回子进程中的进程号？
exit(0); 退出子进程
这是进程，父子进程，之前的是线程，我差点混了。
父子进程中的代码 无法预测谁先执行的，并行还是并发 很多因素 调度算法等多因素
对哈，在xshell中写代码 不是很舒服吗
代码演示极其重要！！！
父子进程代码放在同一文件中

--父子进程地址空间
读时共享 写时拷贝 见代码
栈空间中变量
全局变量在 数据段中 都是读时共享 写
内存划分区：栈区 堆区 BSS区 数据区 代码区

--父子进程堆空间
测试内容泄漏的函数
val 
valgrind ./a.out 
显示结果中 执行中有几个进程 就HEAP SUMMARY显示
上面先显示是父进程 下面再是子进程 

--GDB调试多进程
使用gdb调试的时候，gdb只能跟踪一个
默认调试父进程
要调试子进程 需要设置
set follow-fork-mode child 
set follow-fork-mode parent 
注意：一定要在fork函数调用之前设置才有效。

gcc -g xx.c 
gdb a.out 
b main 
run 
n 
n 
p p 
n 
n 

调试子进程
set follow-fork-mode child 
info break
n 
n 
n 

--进程退出函数
停 累了
void exit (int status); 标准库函数
void _exit (int status); 系统调用-直接退出，不做任何清理工作
结束调用此函数的进程 二者有点区别的

--等待子进程退出函数
每个进程退出的时候，内核释放进程所有资源，但是依然保留部分信息
父进程通过调用wait waitpid 得到它的退出状态并同时彻底清除这个进程
wait 阻塞
waitpid  不阻塞 可指定等待哪个子进程结束
注：一次wait waitpid调用只能清理一个子进程，清理多个进程应用循环

pid_t wait (int *status);
等待任意一个子进程结束，此函数回收该子进程的资源
宏函数 分成三组，判断状态
代码演示了 成功 杀死 暂停
kill -l 看到所有的状态信号
kill -18 进程号  恢复暂停
kill -19 进程号  暂停

pid_t waitpid (pid_t pid, int *status, int options);
pid <-1 -1 0 >0 
waitpid(-1, &status, 0) == wait()
0 阻塞

--孤儿进程
父进程已经运行结束，子进程还在运行的子进程称为孤儿进程
每当一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init
执行完子进程之后，init善后
没什么危害 
终端是init 1号进程 如果是图形界面则不是1号进程了-10791
ps -aux | grep 10791 查看这个进程是 有图形界面这个进程就一直在后台运行

--僵尸进程
进程终止，父进程尚未回收，子进程残留资源存放于内核中，变成僵尸进程
进程号一直被占用 资源一直无法得到释放
getchar() 用于代码演示

ps aux | grep z 子进程没有僵尸
ps aux | grep a.out 有一个Z+ 僵尸了
killall a.out 僵尸是否可以被杀死？它本身就是死的，无法被杀死

子进程执行结束了，父进程还在睡眠，就会出现僵尸进程
ps aux | grep Z 就有一个僵尸了 代码演示我省略了
睡醒就没有僵尸了 

--进程替换
exec函数簇 Linux中不存在exec()函数，指一组函数，一共6个
数组指针 指针数组
char *const argv[] 数组指针，指向一个数组
exec函数簇作用是：根据指定的文件名或目录找到可执行文件，并用
它来调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件
man execlp 
逻辑学--确实需要学习
系统编程转变思维，不要纯用C语言思维

代码演示：
int main (void)
{
	execlp("ls", "ls", "-l", "/home", NULL);
	printf("hello world \n"); 这不执行了？因为上面execlp把内存数据都替换了
}
进程数据全部替换之后，又会从main函数开始执行

int main (void)
{
	char *argvs[] = {"ls","-l","/home",NULL}; 指针数组
	printf("hello a \n");
	execvp("ls", argvs);
	printf("hello b \n");
}
最后一定是NULL结尾，联想字符串

exevc execvp 
剩下两个不看了，11 min 用到再说 
