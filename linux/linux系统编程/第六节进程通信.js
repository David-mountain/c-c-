、、进程间通信

--进程间通信
为何存在？边下载边播放，如果下载是一个进程，播放一个进程，这里
假设是进程哈，可能实际是线程，类比麻，然后二者肯定要相互通信，
下载的部分才能播放麻

每个进程都是独立的资源分配单元
进程间通信的目的：
数据传输 
通知事件 
资源共享 多个进程之间共享同样的资源，为了做到，需要内核提供互斥和同步机制
进程控制

Linux OS支持的主要进程间通信的通信机制：
同一主机进程间通信：
  Unix进程间通信方式： 无名管道 有名管道 信号 
  System V进程间通信方式： 消息队列 共享内存 信号量
  POSIX进程间通信方式：  消息队列 共享内存 信号量
不同主机(网络)进程间通信： socket套接字 

半双工(同一时刻，一个方向的数据流动，你说我只能听) 
全双工(打电话，你说我也可以说)
管道：写入叫写端 读入叫读端 
先进先出 队列
管道多少个字节算一个消息，它不管，所以需要我们自己先约定好协议
比如一个报文18字节，管道只是一个传输的介质，以字节作为单位传递
不是普通的文件，不属于某个文件系统，(只存在于内存中) linux内核维护
无名管道没有名字，只能在有公共祖先的进程中使用
管道是一种特殊类型的文件，在应用层体现为两个打开的文件描述符
fd[0] 读端   fd[1] 写端

--无名管道的创建
int pipe(int pipefd[2]);
pipefd是int型数组的首地址，存放了管道的文件描述符 pipefd[0] [1]
成功返回0 失败返回-1
一般文件I/O函数都可以操作管道，(除了lseek()，因为管道只能按照顺序读，不需要偏移量)
改vim配置 代码片段创建
代码演示
突然想到一个简单的东西，却要大量复杂冗余的语法来阐释，如何做到快速理解这个东西呢？
管道在内存里面哈

--无名管道应用 进程(有血缘关系那种)间通信
子进程是父进程的一份拷贝
在fork()之前先 创建打开管道
那幅图很经典！
父进程 写端    子进程 读端
如果要父也可以读，子也可以写，则必须要再来一根管道了
代码演示  close(fds[1/0]) 关闭

read 读管道 write 写管道
如果子进程先执行呢？那不是没有数据？
管道是阻塞型的，会等待父进程来数据的

为什么要要求有公共血缘关系？
因为拷贝时候才能有公共的管道

--管道读写的特点
4 种情况 
阻塞是管道的属性，不属于读写函数的属性

--查看管道缓冲区的大小
ulimit -a 
pipe size 即是 8块 * 512字节 = 4K 
可设置 

long fpathconf (int fd, int name);
printf("pipe sizie: %ld \n", fpathconf(fd[0], _PC_PIPE_BUF));
printf("pipe sizie: %ld \n", fpathconf(fd[1], _PC_PIPE_BUF));

管道默认是阻塞，可以设置成非阻塞的
设置方法：看教学文档 这里省略了

--管道设置为非阻塞
fcntl()

--有名管道
FIFO文件
和无名管道不一样的地方在于：
1.FIFO在文件系统中作为一个特殊的文件而存在，但FIFO中的内容却存放在(内存)中
2.当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用
3.FIFO有名字，不相关的进程可以通过打开命名管道进行通信

mkfifo fifo 
ls 
fifo文件 
ls -l fifo 

通过函数创建有名管道
int mkfifo(const char *pathname, mode_t mode)
成功0 失败-1
代码演示
man 3 mkfifo
若已存在就不创建了  如何判断已经存在呢？
man access 

FIFO 先进先出 I/O函数大部分都支持

--管道的读写操作
以只写的方式打开管道
写管道
#define SIZE 128 我不熟悉，想不起来
char buf[SIZE]
memset(buf, 0, SIZE);
sprintf(buf, "hello %d", i++);
和读写文件差不多

读管道 只读方式
ret <= 0 不是报错，是读到结尾了

然后写一个 makefile文件
all: read write 

read: read.c 
    gcc $< -o $@ 

write: write.c 
    gcc $< -o $@ 

.PHONY: clean 
clear:
  rm -rf read write 

make -n 测试 
make 
./read 阻塞了
开另一个写端 
如果读端 关闭了，写端会异常终止

--有名管道实现 简单版聊天
有名管道注意事项 
使用多进程的方式改写聊天程序 有名管道

分析：
管道是半双工的 所以聊天肯定要两条管道的
r - w 管道1
w - r 管道2

talkA进程思路：
1. 以只读的方式打开管道1
2. 以只写的方式打开管道2
3. 循环 读-写
  while (1)
  {
    读管道1
    从标准输入获取输入内容fgets
    写管道2
  }
4. 关闭管道1和管道2 

talkB进程思路：
1. 以只写的方式打开管道1
2. 以只读的方式打开管道2
3. 循环 写-读
  while (1)
  {
    从标准输入获取输入内容fgets
    写管道1
    读管道2
  }
4. 关闭管道1和管道2 

--有名管道实现 简单版聊天2
注意顺序，是先读后写还是先写后读
makefile 改
然后测试 
记住某块谁先 写
后面学了网络可以 网络编程

--共享存储映射
存储映射I/O使一个磁盘文件与存储控件中的一个缓冲区相映射
虚拟内存 映射 物理内存
这样即在不使用read write的情况下，使用地址(指针)完成I/O操作 
共享内存可说是最有效的通信方式，也是最快的 IPC形式，因为
进程可以直接读写内存，而不需要任何数据的拷贝

说白了，就是搞一块共有的内存地方，大家一起数据通信。 和之前的管道有啥区别阿，之前不也是同一块内存，然后一个读一个写？

存储映射函数
mmap函数 一个文件或其他对象映射进内存
munmap函数 
覆盖的会

这里操作内存就是操作文件

--注意事项
映射权限 文件权限
等

--共享映射实现 父子进程通信
内存分布： 栈往下 堆往上
图 省略了 重要
通过文件来了建立两个进程之间的渠道

--不同进程之间的通信
代码演示  

之前想的是用来存储，但是却是用来进程之间的通信！

--匿名映射实现父子进程通信
使用映射区完成文件操作十分方便，父子进程间通信也比较容易，
缺陷是，每次创建映射区一定要依赖一个文件才能实现
之前的temp文件 流程麻烦，可以直接借助匿名映射来代替
这个只能用于父子进程间通信
匿名映射区，无需依赖一个文件可创建映射区，

flags 有所改变 看文档

19 到信号了
跳 

20 信号的概述
信号是linux进程间的最古老的方式。信号是软件中断。他是软件层次上对中断机制的一种模拟。 
21 信号的编号
POSIX.1 对可靠信号做了标准化 
kill -l  

sleep 3000 &
sleep 3000 &
jobs 查看后台进行的进程 

ps aux | grep sleep 
grep sleep 
当1号终端退出时，相关联的进程都会终止的 因为一个信号 SIGHUP 

信号表 
进程收到这个信号就终止 

汇编代码 这里有点蒙了
命令都忘记了 走神了

接了每个信号的 出现场景
段错误 通过看日志 定位到错误的行 

22 信号的四要素
每个信号必备四元素，分别是：编号 名称 事件 默认处理动作
似乎就是windows的消息
一流标准协议 二流技术 三流产品

man 7 signal 
跨平台用名称 因为编号不一样的，唯一性

有2个信号比较特殊 SIGKILL SIGSTOP 无法被捕捉 被阻塞 被忽略

23 信号的状态
信号的产生 
未决状态：没有被处理
递达状态：信号被处理了

阻塞信号集 类比电话的黑名单，屏蔽某些特定电话
未决信号集 类比未接电话

信号的实现手段导致有很强的延时性

linux内核的进程控制块PCB是一个结构体，task_struct，除了包含进程ID，状态
工作目录，用户ID，组ID，文件描述表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集

24 信号产生函数
kill函数 int kill(pid_t pid, int sig); 给指定进程发送指定信号(不一定杀死)
 
25 使用raise函数给自己发送信号
int raise(int sig)
给当前进程发送指定信号(自己给自己发) 等价于kill(getpid(), sig)
sig 信号编号

26 使用abort给自己发送一个异常信号
void abort(void)
给自己发送异常终止信号 
if (4 == i) 常量写在前面 

27 使用 alarm设置超时 
unsigned int alarm (unsigned int seconds)
设置定时器(闹钟)，在指定N秒后，内核会给当前进程发送14 SIGALRM信号，进程收到该信号，
默认动作终止，每个进程都有且只有唯一的一个定时器
取消定时器alarm(0)，返回旧闹钟余下秒数 

man alarm 

29 settimer定时器
int settimer (int which, const struct itimerval *new_value, struct itimerval *old_value);
设置定时器，可替代alarm函数，精度微妙us，可以实现周期定时
which 指定定时方式 自然定时 虚拟空间计时 运行时计时 
0 成功  -1 失败
man settimer 

30 signal函数
man signal
函数指针还是指针函数？
typedef void (*sighandler_t)(int) 函数指针 指向函数的指针
sighandler_t signal(int signum, sighandler_t handle);

信号捕捉过程中不能有睡眠函数 

31 使用 signal捕捉超时信号 
信号用在异步处理中

32 信号集和信号集操作函数
PCB中两个重要的信号集，一个阻塞信号集，一个未决信号集
这两个信号集都是内核使用(位图机制)来实现的，但OS不允许我们直接进行位操作
而需要自定义另外一个集合，借助信号集操作函数对PCB的这两个信号集进行修改 

位图机制 就是二进制位 表示的 节省内存 之前vc++说过的
内核链表 位图 哈希 这三个使用较多

自定义信号集函数 
通过函数修改 信号集

33 信号屏幕集设置和演示
sigprocmask函数 
通过这个函数修改当前信号掩码来改变信号的阻塞情况
信号阻塞集也称信号屏蔽集、信号掩码。每个进程都有一个阻塞集，创建子进程时子进程将继承父进程的阻塞集
并集| 删除某个&~ 清空并赋值某个=

34 获取未决信号集
sigpending函数
int sigpending (sigset_t *set)
读取当前进程的未决信号集 只能读，不能写 因为这是内核完成的

举例不是很明白

35 信号的处理方式
一个进程收到信号的时候，以下方法进行处理：
执行系统默认动作 
 对大多数信号来说，系统默认动作就是终止该进程
忽略此信号(丢弃)
 接收到此信号后没有任何动作
执行自定义信号处理函数(捕获)
 用户定义的信号处理函数处理该信号

 注意：SIGKILL SIGSTOP不能更改信号处理方式，因为它们向用户提供了一种进程终止的可靠方法

用户区 内核区 图 看教案把

36 信号的捕捉sigaction函数
struct sigaction 
{ 函数指针变量
  void(*sa_handle)(int);
  void(*sa_sigaction)(int, siginfo_t *, void *);
  ..  
}

37 不可重入和可重入函数概述
sigqueue 很少通过这个信号发送信号
给指定进程发送信号 

不可重复 可重入函数概述
如果有一个函数不幸被设计成这样：不同任务调用这个函数时可能修改其他任务调用这个函数的数据，
从而导致不可预料的后果，这样的函数时不安全的函数，也叫不可重入函数
不可重入函数： 函数体内使用了静态的数据结构 调用了malloc free  调用了标准I/O函数

系统调用 和 I/O函数 区别和联系：
  I/O函数调用了系统调用来实现的。
  最本质区别：I/O函数包含缓冲区 

可重入函数： 。。 
保证函数的可重入的方法：多用局部 对于要使用的全局变量要加以保护-互斥量 等

linux常见可重入函数

38 使用信号避免僵尸进程
子进程退出时，父进程会收到一个信号

SIGCHLD信号产生的条件：
  子进程终止时
  子进程接收到SIGSTOP信号停止时
  子进程处在停止态，接收到SIGCOUNT后唤醒时

如何避免僵尸进程
最简单方法，。。。。看教案
在父进程中 搞个子进程退出的回调函数 然后回收子进程的资源

