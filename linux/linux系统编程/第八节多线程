多线程出现的背景，子进程。。。
轻量级的进程，本质就是一个进程，只是在应用层之上是线程 
底层理解： 如果这个函数在底层做了一个深拷贝，就是进程，做了浅拷贝就是一个线程
linux环境下，线程的本质还是进程
为了让进程完成一定的工作，进程必须包含一个线程

进程：
	线程A栈
	线程B栈
	堆区
	BSS区
	数据区
	代码区

进程是CPU分配资源的最小单位，线程是CPU调度的最小单位

进程有自己的地址空间，线程使用进程的地址空间，也就是说，进程里的资源，线程都是有权访问的，比如堆 栈 静态存储区阿
NPTR ？本地线程库 克服了原有的缺点，也符合POSIX的要求
getconf GNU_LIBPTHREAD_VERSION

2 
线程的特点和优缺点
类Unix系统中，早期没有线程的概念，80年代才引入，借助进程机制实现了线程的概念
因此，这类系统中，进程和线程关系密切：
	线程是轻量级进程，也有PCB，创建线程使用的底层函数和进程一样，都是内核函数clone 
	从内核里看进程和线程是一样的，都有各自不同的PCB
	进程可以蜕变成线程
	线程是最小的执行单位，进程是最小的分配资源单位 (进程是资源管家，线程是干活的 分配资源以进程为单位)

实际上，无论创建进程的fork，还是创建线程的pthread_create，底层实现都是调用的内核函数clone 
如果复制对方的地址空间，那么就产生一个进程 
如果共享对方的地址空间，那么就产生一个线程
linux内核是不区分进程和线程的，只在用户层面上区分的。
所以，线程所有操作函数 pthread_* 是库函数，而非系统调用

线程共享资源
 文件描述符表
 每种信号的处理方式
 当前工作目录
 用户ID和组ID
 内存地址空间

线程非共享资源
 线程ID
 处理器线程和栈指针 内核栈
 独立的栈空间 用户空间栈
 errno变量
 信号屏蔽字
 调度优先级

任务管理器 - 性能 - CPU 看线程个数 

线程的优缺点：
优点：提高程序并发性 开销小 数据通信 共享数据方便
缺点：库函数不稳定 调试编写GDB不支持 对信号不支持
优点突出，缺点不是硬伤，进程线程本质就差不多


3 
pthread_self pthread_equal 函数
进程有进程号，线程有线程号，进程是整个系统中唯一的，但线程号不同，
线程号只在它所属的进程环境中有效
进程号 pid_t 非负整数 
线程号 pthread_t 无符号长整数

有的OS在实现pthread_t的时候，用一个结构体表示，所以在可移植的OS实现不能把他作为整数处理

man pthread_self 
返回值 这个函数总是返回成功

每个进程 都默认有一个线程

gcc xx.c -pthread 
这个.c代码里打印了线程号 然后这里编译需要链接 -pthread库

获取当前线程线程号
比较两个线程ID是否相同

4 线程的创建
在进程中创建线程
man pthread_create 
主线程，又创建的一个子线程

int var = (int)(long)arg; 强转
(void*)0x3 做一个地址传过去

5 多线程共享数据验证
如果线程资源没有被回收，就会成为僵尸线程
我发现对指针int*p 不是很熟悉了 尤其是在运用的时候
int a = 1; a = 2;
int* pa = &a; *pa = 2;

代码验证

6 pthread_join 回收线程资源
进程回收函数？wait()
线程回收函数，pthread_join 
等待线程结束，此函数会阻塞，并回收线程资源

void pthread_join (pthread_t thread, void **retval);
 retval 用来存储线程退出状态的指针的地址

7 pthread连写讲解
案例 打印机 
gcc 发现不对，因为没有刷新缓冲区 
如何刷新 哪个接口？ man fflush 
代码里面要加上 fflush(stdout);
如果没有刷新，输入的字符都放在缓冲区，如果刷新之后，每输入一个都会显示在终端了

AbBbCc..
不一定先大写还是小写
创建线程之后，CPU来调度谁先执行，后执行的 调度算法，交替执行

8 pthread 分离状态
一般情况下，线程终止后，其终止状态一直保留到其他线程调用pthread_join获取它的状态为止
但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态
不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误 

pthread_detach 
使调用线程与当前进程分离，分离后不代表此线程不依赖与当前进程，
线程分离的目的是将线程资源的回收工作交由系统自动完成，
所以，此函数不会阻塞 

视频中VIM操作非常熟练，文件复制，代码删除 复制等
进程退出了，子线程也退出了

9 线程退出和线程的取消
exit(0) 进程退出
在一个线程中我们可以通过一下三种不终止整个进程的情况下停止它的控制流：
线程从执行函数中返回
线程调用phread exit退出线程
线程可以被同一进程中的其他线程取消

注意：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点
就像游戏存档，必须到达一个场所才能存档
取消点：是线程检查是否被取消，并按请求进行场所的一个位置。
通常是一些系统调用create open pause close .. 
可粗略任务一个系统调用(进入内核)即为一个取消点 

原子操作： 不可被细分的操作
原语？

pthread_cancel() 线程取消

10 线程属性 
跳 

12 资源竞争举例说明
打印机模型 加锁 
银行 存折 银行卡 取钱  加锁
临界区代码(加锁解锁之间的代码) 同一个时刻只能被同一个任务执行
不可被打断 

13 同步和互斥的概念
现代OS基本都是多任务OS，同时有大量可调度尸体在运行。
在多任务编程中，同时运行的多个任务可能：
  都需要访问、使用同一个资源
  多个任务之间有依赖关系，某个任务的运行也依赖于另一个任务
这两种情形是多为任务编程中遇到的最基本的问题，也是多任务编程中的核心问题，同步和互斥
就是用于解决这两个问题的。

互斥
同步：散步在不同任务之间的若干程序片段，它们的运行必须严格按照规定的某种先后次序来运行

同步是一种更为复杂的互斥，而互斥是一种特殊的同步。

14 为什么需要互斥锁 

15 互斥锁Mutex介绍
在线程里有这么一把锁，互斥锁，也叫互斥量 
互斥锁是一种简单的方法来控制对共享资源的访问，互斥锁只有两种状态，加锁和解锁
互斥锁的数据类型是： pthread_mutex_t 
操作流程：加锁 解锁 加锁后，其他视图加锁的线程会被阻塞，知道锁被释放

比如：上厕所加锁

安装对应帮助手册：
sudo apt-get install manpages-posix-dev 

pthread_mutex_init 初始化互斥锁
	restrict c语言的一种类型限定符
pthread_mutex_destory 销毁一个互斥锁 
pthread_mutex_lock 对互斥锁上锁，则调用者阻塞 
pthread_mutex_unlock 对互斥锁解锁

临界区代码 -加锁解锁之间的代码
这样打印机就不会出现交叉出门的情况了

16 修改数据不一致原因
原子操作 ？
100的变量 读写

17 死锁基本概念和场景
线程1需要线程2正在使用的资源2
线程2需要线程1正在使用的资源1
这样，两个都一致处于阻塞状态，无法继续，这种情况即死锁
程序申请资源操作不当 造成的

死锁指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象
若无外力作用，它们都将无法推进下去。
这种用于在互相等待的进程叫死锁进程

死锁产生的原因： 3种
死锁的必要条件：4个
处理死锁的思路：。。 由必要条件出发思考

预防死锁的方法： 。。

18 死锁场景代码演示

19 读写锁概述
查询不存在资源改动 没必要加锁
读线程 写线程 
线程提供了读写锁来实现
对数据的读写操作种，读操作较多，写操作较多

读锁 如果其他线程申请了读锁，其他线程可以再申请读锁，但不能申请写锁
写锁 如果某线程申请了写锁，其他线程不能申请读锁，也不能申请写锁

POSIX定义的读写锁的数据类型是： pthread_rwlock_t 

pthread_rwlock_init函数 用来初始化rwlock所指向的读写锁
pthread_rwlock_destory 销毁一个读写锁 并且释放相关联的资源
pthread_rwlock_rdlock 
pthread_rwlock_unlock 
pthread_rwlock_tryrdlock

pthread_rwlock_wrlock 
pthread_rwlock_trywrlock
pthread_rwlock_unlock 

21 读写锁 案例
当一个读线程加锁，其他所有读线程加锁都能OK，所有写线程都会阻塞
当一个写线程加锁，其他所有的读线程和写线程加锁都会阻塞

跳

23 条件变量 ？不是特别能理解
与互斥锁不同，条件变量是(用来等待)而不是用来上锁的，条件变量本身不是锁
条件变量会自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。
条件变量两个动作：
 条件不满，阻塞线程
 当条件满足，通知阻塞的线程开始工作
条件变量类型： pthread_cond_t 

pthread_cond_init 初始化一个条件变量
pthread_cond_destroy 
pthread_cond_wait 
pthread_cond_signal 

原子操作：不能被取消 被中断 

对这个条件变量 我不是很理解？

24 代码演示
唤醒 阻塞 
加锁一次 不能解锁两次


25 生产者和消费者基本模型
线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是常见的一种方法
假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。
两个线程同时操作一个共享资源，称之为汇聚，生产向其中添加产品，消费者从中消费产品。

会用到链表 头插法 尾插法
每生产一个 通知消费者消费 如果一直没消费，越来越多，构成了一个链表

写代码：
先搭整体架子 然后再具体填充代码

链表节点
生产的产品 就是挂在链表上 用头插法插入
消费 循环消费  
这个模型 -就是对于数据结构链表的操作 插入和删除 
这里不加锁？可能这里删除了，另外一个又在插入 就出现异常了
当使用malloc等 就要加锁了

26 生产者和消费者条件变量模型
跳 

27 信号量概述和相关函数分析
信号量广泛用于进程或线程间的同步和互斥，信号量本质上是一个非负的整数计数器，
它被用来控制对公共资源的方访问。

编程时可根据操作信号量的结果判断是否对 公共资源具有访问的权限，当信号量大于0时，
则可以访问，否则将阻塞。

PV原语 是对信号量的操作，一次P操作使信号量减1，一次V操作使信号量加1 
信号量数据类型 sem_t 

信号量用于互斥 好像智能指针 搞个计数器

sem_init 初始化一个信号量
sem_destroy 删除
sem_wait p操作 -1 
sem_post v操作 +1 

28 信号量 互斥场景

29 生产者和消费者信号量模拟
信号量用于同步
两个信号量 就是两个计数器分别统计生产者和消费者 用于什么时候可以消费 生产的统计 我是这样理解的
sem1 存放商品容器的个数
sem2 表示可以消费的商品个数

8min 开始代码演示

30 哲学家就餐问题
线程： 五个哲学家
资源： 五根筷子 -五把锁

先拿右手的筷子 如果5个线程都拿到了 那就是饿死了

多线程，多把锁的一个操作：
 按顺序访问共享资源
 如果没有枪到另一个资源，释放已经抢到的资源

-- 银行家算法 感兴趣可以看看 不难的
这些实践之后，可以看看王道的视频，做个总复习麻。
刚把王道的视频打开看了哈目录，我发现了黑马说的这些都是OS这的内容
只不过是代码实践，理论 + 实践 不是线性的，而是不断反复的

安全序列 安全状态 不安全状态
可以在资源分配之前先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应
资源分配请求，这也是银行家算法的核心思想

银行家算法步骤：
检查此次申请是否超过了之前声明的最大需求数
检查此时系统剩余的可用资源是否还能满足这次请求
试探着分配，更改各数据结构
用安全性算法检查此次分配是否会导致系统进入不安全状态

假设法
抽象成了矩阵 

安全性算法步骤：
检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程
加入安全序列，并把该进程持有的资源全部回收
不断重复上述过程，看最终是否能让所有进程都加入安全序列


