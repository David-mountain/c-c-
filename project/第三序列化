1
protobuf 
其他的序列化工具暂时不说

序列化： 数据->特定格式的字符串 (编码)
反序列化

这个模块用c++实现，用OOP的思想，能收能抽象成一个类 
不是面向过程的C来思考 

2
如何使用UML描述一个类
处理成类和类之间关系的时候，用图表 表示
类的关系： (五大类)
 继承关系 (空心三角形)
  普通继承
  抽象继承(纯虚函数 多态等概念 抽象类无法实例化)  UML名字是倾斜的(没有实现的类 抽象类还是普通类，看是否倾斜！)
 关联关系 (一个箭头)
  单向关系
  双向关系
  自关联
 聚合关系
 组合关系
 依赖关系

不同的关系如何用代码表示出来

类的UML画法
 Person 类名
 
 - name:String = Jack 属性

 + getName() : String 方法
 + setName(name: String) : void   这里的和TS的参数写法很像了 类型在变量后面
 # play(): void
 -pass(): void

 - private
 + public
 # protected


4
uml中描述关联关系
在c++中通常将一个类的对象作为另一个类的成员变量

关联关系
单向关联： (箭头指向不能错 包含address就指向它)
class Address 
{};
class Customer
{
	private: 
		Address address;
}

双向关系： (互为箭头)
互为成员变量
class Product 商品类
{
	private:
		Customer customer; 该商品属于哪一位顾客，作为成员变量
}
class Customer 顾客类
{
	private:
		Product product[4]; 给顾客购买了哪些商品，作为成员变量
}

突然想到了类的设计，如何设计？数据库的设计呢？表设计？ 

自关联关系： (箭头指向自己)
自己包含自己的  在链表中非常常见
单向链表Node中会维护一个它的前驱Node，等
一个类中包含类本身的实例对象 
class Node 链表节点
{
	private:
		Node* nextNode; 指向后继节点的指针，作为成员变量
}

5
uml中对组合和聚合的描述
聚合关系：
整体与部分的关系
在聚合关系中，成员对象是整体的一部分，但是成员对象可以脱离整体对象独立存在
UML中，聚合关系是带 空心棱形的直线表示
汽车与引擎、轮胎、车灯等
多个子部件 组合成一个整体

class Engine {};
class Wheel {};
class Light {};
clas Car 
{
	public:
	Car (Engine engine, Light light, Wheel wheel)
	{
		this->engine = engine;
		this->light = light;
		this->wheel = wheel;
	}
	void drive () {}

	private:
	Engine engine;
	Light light;
	Wheel wheel;
};

空心棱形指向整体，箭头指向部分。

代码实现聚合关系，成员对象通常以构造方法、Setter方法的方式注入到对象整体对象之中的

如果当车销毁了，这些零部件没有析构，就是聚合，如果析构销毁了，就是组合了。


组合关系：
整体和部分的关系
整体没了，部分也不存在，就是组合的，不是聚合哟
UML中 组合关系 用带实心棱形的直线表示 
脑袋 鼻子和嘴 脑袋没了 鼻子嘴也没了

代码实现组合关系，通常在整体类的构造方法中直接实例化成员类，
因为组合关系的整体和部分是共生关系，如果通过外部注入，那么即使整体不存在，
那么部分还是存在的，这就相当于变成了一种聚合关系

子在组合，子不在聚合！

6
依赖关系
是一种使用关系
在需要表示一个事务使用另一个事务时使用依赖关系
大多数情况下依赖关系体现在某个类的方法使用另一个类的对象作为参数
在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。
比如：驾驶员开车 Driver类 

依赖关系通过三种方式来实现：
1.将一个类的对象作为另一个类中方法的参数
2.在一个类的方法中将另一个类的对象作为其对象的局部变量
3.在一个类的方法中调用另一个类的静态方法

class Car 车类
{
	public:
	void move();
};
class Driver 司机类
{
	public:
	void drive (Car car)
	{
		car.move();
	}
}

关系：
继承
包含与被包含
整体与部分
如果前三都不是，就是依赖 

依赖关系使用 带箭头的虚函数 连接 
依赖谁，指向谁

以后，写程序，就先给一个类图给你，思考如何写程序
有些公司还要求写代码之前画好类图，我怎么知道你设计好了呢？
大体的需求分析书和类图 
会看 会画 
代码的设计能力 

之前学习的代码，用UML画出来呢？管理系统阿 


8
序列化介绍
序列化：将对象的状态信息转换位 存储或传输的形式的过程
实现数据序列化：
 要有原始数据
  复合类型-常见情况
  基础数据类型 
 通过某些方式 -> 另外一种形式的数据 
 得到的数据干啥？ -》目的：进行分发，分发到不同的终端/平台，保证不同的平台能正确解析
  网络传输(内存到内存)
  磁盘拷贝(内存到磁盘到内存)

序列化目的不是为了加密，为了数据的跨平台传输

序列化与夫序列化主要用于 在跨平台和跨语言的情况下，模块之间的交互和调用，
但本质上是为了解决数据传输问题。

9
网络通信中常见问题分析

发送过程中遇到的一些问题？
平台不同
 32bit/64bit
  long 
 平台不同，某些数据类型占用的内存大小不同
如果不是字符串，需要进行字节序转换
 字符串没有字节序(按字节来，最小单位是字节来的，高位字节和低位字节)问题 字符在内存中占用一个字节
 如果发送的是结构体 
 大小端问题 
语言不同
 语言不同数据类型占用的内存可能不同
  c char 1byte 
  java char 2byte 
字节对齐问题

序列化的整体过程：
 发送端
  原始数据->序列化->特殊格式的字符串
  发送这个字符串
 接收端：
  接收数据
  特殊格式的字符串-》反序列化-》原始数据
  对原始数据进行处理

序列化-编码
反序列化-解码 

10
常见的数据序列化方式
XML
json 
protocol buffer 
ASN.1 抽象语法标记
boost 序列化的类 ！！！C++不会这个只能算半个C++

XML
类似html(用来标记数据)
用来描述数据
相同点：用的都是标签 
<？xml encoding="utf-8"> 文件编码一般是utf-8

Json (javascirpt object notation)
产生来自于一种关联数组的概念
本质就是采用键值对的方式来描述对象
优点：人眼可读
相对于XML，序列化后的数据更加简洁，(XML产生的序列化文件是JSON的两倍)，
协议较简单，解析速度更快
JSON格式具备JS的先天性支持，是AJAX事实标准协议 

json是一种数据格式，不是语言 和平台语言无关

11
protobuf使用步骤
版本2 -支持语言较少 
版本3 -支持语言较多了
protobuf是一种纯粹的展示层协议，可以和各种传输层协议一起使用
支持的数据类型相对较少，不支持常量类型，由于其设计的理念是纯粹的展现层协议，
目前没有一个专门支持的protobuf的RPC框架
有官方文档

操作流程：
准备数据
创建一个文件 xxx.proto
将我们需要序列化的数据 写入到proto文件中
 有语法格式
通过一个命令 protoc 将xxx.proto文件生成一个c++的类
 对应一个头文件、源文件
 操作命令-在window终端中        protoc xx.proto -cpp_out=./ 就会生成两个文件
直接使用这个类
 里面有对数据操作的API 
  读数据API
  写数据API

CMake工具 生成另外的文件 其实就是VS项目了 然后编译 看到一个Debug目录 双击 
有protoc.exe 还有很多库  

proto设置到环境变量中 把库目录和头文件放在任何一个地方电脑中

12
编写proto文件并生成对应的类
桌面创建一个文件 person.proto
这用版本3 版本2与3有些不兼容 
struct Person
{
	int id;
	string name;
	string sex;
	int age;
}

syntax = "proto3"; 3版本
//解析person结构体
语法格式 借代(message就是原数据)
message 关键字(相当于被创建出的类的名字)
{
	// 成员变量
	数据类型 变量名 = 变量的编号； 从1开始编的，不能重复
}

message Person 
{
	// int 在这protobuf应该怎么写呢？有一个表 对应写法
	int32 id = 1; // 编号从1开始
	// string对应两个： string bytes(中文有用这个)
	string name = 2;
	string sex = 3;
	int32 age = 4;
}

13
protobuf生成的类分析 
新建一个windows桌面项目 空的
test.cpp 
然后把之前命令生成的两个文件 拷贝到这个项目.cpp同级目录下

设置文件库目录和包含目录 

看头文件，很多API 
读 写数据 
生成的API如何用 

朗木达表达式 和 mutable 语法

14
复习 暂停了

