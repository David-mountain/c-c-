1
文档介绍
openssl加密 用c语言编写的开源的密码库 https就是以这个为基础的
protobuf 谷歌的 数据序列化 网络通信的时候 跨平台传输 linux-windows
git 版本管理工具 小乌龟或者VSCODE 我喜欢用命令

需求分析书-需求文档
需求说明书 业务的介绍 转换成代码
项目部署手册 部署到使用者的电脑上 

2
3
这个也是项目中的一个模块，项目一般开发都是6-1年左右 
需要自己寻找一个业务场景，和这里进行结合，来进行项目面试

网络通信
 数据传输-需要保证数据的安全性
  对数据的加密
 项目1主要实现的功能
  对网络通信数据进行加解密的模块

4
序列化介绍
google protobuf库
为什么要进行序列化呢？
解决数据的跨平台传输，
	字节序(大小端问题) 
	计算机位数-32 64位-int几个字节   
	字节对齐
	序列化-编码
		将原始数据按照某种格式进行封装-》特殊的字符串，进行发送
	反序列化-解码 
		接收到序列化的特殊字符串-》解析，得原始数据
		按照业务需求处理数据
	套接字通信 
		tcp
		线程池 主要用在服务器 
		连接池 客户端可用    都需要多线程的使用，
	共享内存操作 shm qt有转么的类
		进程间通信的一种方式
		效率最高 之前说的进程间通信方式都需要fd   fd?磁盘
			管道
				匿名-不需要读磁盘
				有名-需要磁盘文件 
			本地套接字 
			内存映射区 -> mmap 
		不需要对磁盘文件进行操作
	数据库操作 
		使用oracle 
		使用oracle官方提供的c++接口
			OCI接口


GO JAVA C++都支持protobuf。

而且笔试中，字节对齐也考 
struct A 
{
	int a; 4
	char b; 1
	int c; 4
} 电脑中字节对齐，12了 char还会补3个

6
基础模块在项目中的作用
项目整体架构图
密码学
服务端 客服端使用同一个密钥
密钥保存 共享内存中-进程间通信
数据库--server端远程访问 
数据库可能是集群的，不一定在一个地方的 
这里视频中教学和其他的就有差别了，这里讲的不好 CS架构没有说到

客户端实现模式：
 桌面程序-QT
 	需要将桌面创建搭建起来
 	写的QT程序
 		可以使用纯C语言/c++ 写业务逻辑
 终端交互-linux终端- 教学使用这个

服务器：
 做成后台的守护进程也可以

我很好奇，为什么不写一个带业务流程的模块，而是搞了一个加解密的一个独立模块？

8 
加密三要素
 明文、密钥、算法
 明文-原始数据
 密文-加密之后的数据
 密钥-定长的字符串
 	对称加密 的密钥比较短 自己生成
 	非对称加密 的密钥比较长 有对应的生成函数，有对应的算法
 	(随机生产一个数 )
 算法-
 	加密算法
 	解密算法 

 举例：
 	明文 123
 	密钥 111
 	加密算法：明文 + 密钥
 	解密算法：密文 - 密钥
 	加密： 123 + 111 = 密文 = 234
 	解密：234 - 111 = 明文 = 123 

 	算法是固定的，还是不安全，有了密钥未知数后，更安全，

 	现成开源的算法，当然你有能力也可以自己开发

9
对称加密和非对称加密的 密钥

对称加密
	密钥比较短 
	密钥只有一个
		加密解密使用的密钥是相同的
	加密的效率高 
	加密强度相对较低(非对称加密)
	密钥分发困难 -因为密钥需要保密不能泄漏 

非对称加密
	密钥比较长
	密钥有两个，所有的非对称加密算法都有生成密钥的函数 
		这两个密钥对 保存到不同的文件中 一个文件是公钥文件(较小)，一个是私钥文件(较大)
		公钥 可以公开的
		私钥 不能公开
	加解密使用的密钥不同的
		如果使用公钥加密，必须私钥解密
		如果使用私钥加密，必须公钥解密
		谁加密都可以，反正密钥对 
	效率低
	加密强度较高(对称加密)
	密钥可以直接分发(公钥)

10
对称和非对称加密的特点

私钥一定要保管好

11 12 13 
对称加密算法
!DES/3DES 
	DES 已经被破解了，不安全了 安全的时候用的这个
		密钥长度是8个字节
		对数据分段(分组)加密，每组8字节 
		得到的密文和明文长度是相同的 最后一组不够8字节会填充的 解密还需要去除添加的字节 最后会有一个添加了几个的数
	3DES 3重DES，来3次 
		得到的密文和明文长度是相同的 8字节
		密钥长度24字节 3个8 在算法内部会被平均分成3份，每份8字节
			看成是3个密钥
			每个8字节
		安全的，效率比较低
		处理逻辑
			加密 -密钥1 * 加密算法
			解密 -密钥2 * 解密算法
			加密 -密钥3 * 加密算法
			这里设计为了兼容DES 看密钥 12密钥不能相同 
			123密钥都不相同，加密等级是最高的 

!AES 项目用的这个
	最安全，效率最高的公开的对称加密算法
	密钥长度 可选的 16字节、24字节、32字节 
	密钥越长，加密的数据越安全，效率越低  先要破解密钥，长了，难破解
	分组加密，每组长度16个字节
	每组的密文和明文的长度相同 16byte ！！

Blowfish
RC2/4/5
IDEA
SKIPJACK

15
密钥分发过程

非对称加密
加密算法
 ！RSA 数字签名和密钥交换
 	项目中用这个
 	两个非常大的数字 算法自己拓展

 ECC 椭圆曲线加密算法 效率最高
 Diffie-Hellman DH 密钥交换
 El Gamal 数字签名
 DSA 数字签名

反正就数字签名和密钥交换 2个

密钥交换过程
 假设通信的双方为：客户端C，服务器端S
 为什么要交换？
  1非对称加密密钥分发方便，但是效率低-》改进，需要使用对称加密
  2使用对称加密，踹快分发困难，-》改进，使用非对称加密进行密钥分发
  	分发的是对称加密的密钥，本质就是一个字符串

 密钥交换的过程：
  1在服务器端生成一个非对称加密的密钥对：公钥 私钥
  2服务器将公钥发送给客户端，客户端有了公钥
  3在客户端生成一个随机字符串，这就是对称加密需要使用的密钥
  4在客户端使用公钥对生成的对称加密的密钥进行加密，-密文
  5将加密的密文发送非服务器
  6服务端使用私钥解密 -对称加密的私钥
  7双方使用同一密钥对称加密通信

  说白了，就是用服务端的公钥，拿到客户端进行非对称加密 这样服务端有了？
 流程要清楚，不然代码写不出来
 不一定是服务端生成，这里举例的是服务器生成的场景而已，看具体情况

16 哈希算法特点
 Hash算法 (单向散列函数)
 就是函数
 特点：
  不管原始数据有多长，通过哈希算法进行计算，得到的结果长度是固定的
    是一个二进制的字符串 
  只要是原始数据不一样，得到的结果就不一样，
    原始数据差点，得到的结果是完全不一样的
  有很强的抗碰撞行
  	碰撞：原始数据不同，但是通过同样的哈希算法进行计算能得到相同的结果
  	推到出的结论：数据不同得到的结果就不同 
  	使用场景：数据校验 登录验证 存储不会存储原始密码-哈希运算之后的 都是让你重置密码，不会给你发原始密码过来-危险
  		网盘妙传功能实现-已有的文件的哈希对比，不是所有文件都可以，前提是服务器有这个文件了，操
  不可逆
   得到的结果不能推导出原始数据 原始的数据大小不定的

 MD4/5
 	散列值长度：16字节
 	抗碰撞性已经被破解
 SHA-1
  散列值长度：20字节
  抗碰撞性已经被破解
 SHA-2
  一个系列
  sha224(位)
   散列值长度：224bit/8=28byte 
  sha256
   256bit/8=32byte 
  sha384
   384/8=48
  sha512
   512/8=64
 SHA-3... 

17 
常用哈希算法以及散列值长度

哈希算法的结果：
 散列值
 指纹
 摘要
 
18
能不能哈希算法成为加密算法，不能，不可逆，无法解密

19
消息认证码 HMAC (H-哈希 MAC-认证码)
哈希算法的另外一个应用
消息认证码作用：在通信的时候，校验通信的数据有没有被篡改  没有加密的功能
消息认证码本质是一个散列值
(原始数据+密钥) * 哈希函数 = 消息认证码
 最关键的数据： 密钥

校验的过程：
 数据发送方A，数据接收方B 
 在A或B端生成一个密钥：X，进行分发->A和B端都有了密钥：K
 在A端进行散列值运算：(原始数据 + x) * 哈希函数 = 得到散列值
 在A端：将原始数据和散列值同时发送给B 
 在B端： AB端使用的哈希算法是相同的
  接收数据
  校验：(接收的原始数据 + x) * 哈希函数  = 散列值New
  比较散列值：接收到的和New的 是否相同 同则没篡改 不同则修改了

缺点：
 密钥分发困难
 不能区分消息的所有者(已经泄漏了，发给你你也不知道)
 
20
数字签名 就是解决上面的缺点
电脑上的软件都是有签名的，软件的.exe- 属性-数字签名
签名就是为了判断是否有篡改别人的东西，可以鉴别所属者是谁

作用：
校验数据有没有被篡改(完整性)
鉴别数据的所有者
不能对数据加密

数字签名的过程： 私钥加密数据
 生成一个非对称加密的密钥对，分发它的公钥
 使用哈希函数 对原始数据进行哈希运算 - 散列值
 使用私钥对散列值加密 - 密文
 将原始数据和密文 一起发送给接收者 

校验签名的过程：
 接收签名的一方分发的公钥
 接收签名者发送的数据，接收的原始数据和签名 
 对数据进行判断：
  对接收的原始数据 进行哈希运算 -散列值NEW
   和签名的时候使用的哈希函数相同-必须相同
  使用公钥对签名(密文)解密 - 得到散列值OLD
  比较两个散列值
   同则数据所有者确实是A，并且数据没有被篡改 (拿A的公钥)
   不同，数据的所有者不是A或者数据被篡改了 

没有这个逻辑，程序没法写。

21
openssl介绍
是一个安全套接字层 密码库，包括密码算法，常用的密钥和证书管理功能及SSL协议

认清现实：找到的市面大部分的库，没有官方文档？？？ 怎么学呢
网上查资料，有错有对，多查，甄别能力

SSL 安全 套接层 协议 
TLS是SSL的升级版
HTTPS就是使用的SSL 
目标是保证两个应用间通信的保密性和可靠性，可在服务端和用户端同时实现支持，工业标准

标准IO -文件操作麻 
遇到陌生的API，不要说不会用，尝试用 不要怕 
项目中大量的陌生库，参考别人代码怎么用的，多问也可以 所以写代码要多思考

22 
windows下openssl安装
其实也就是VS下怎么使用 C++程序员
创建的项目是32位还是64位的，才安装多少位的，不是根据你的电脑多少位的

32位项目加载32位的库，64位同理！！！

傻瓜式安装
2个地方 第二个 最后都不勾选

源文件-编成库 头文件

23
VS下openssl的配置

创建一个桌面项目windows的
要用这些库，需要把库路径和头文件路径 设置到我们的项目中 ！！！
右键-VS++目录-包含目录 即头文件目录 include 
库目录-动态库的目录 lib

代码：
#include <stdio.h>
#include <openssl/md5.h>

编译-报错 无法解析的外部符号 就是找不到动态库！！！
openssl是动态链接，用的时候才找，找不到现在
！！！ 链接器-输入-附加依赖项-libssl.lib libcrypto.lib 就是lib下的两个文件
我之前犯过这个错的 
只是做密码，第一个lib就可以了

测试成功，就生成了一个字符串

静态库 动态库 都忘记了
.dll .lib 

配置到环境变量？
此电脑-属性-高级系统设置-环境变量-系统变量-path-添加一行即可 
注销或者重启电脑 才能生效 环境变量

24
linux下安装openssl
跳


