没有通过检测的禁止向下学习！！！正反馈阿这是，突然忘记了这个点。！！！！！！！！

 ## 基础知识02

 ### 1.3 汇编语言的组成
 3类组成：
 1. 汇编指令(机器码的助记符) -核心
 2. 伪指令 (由编译器执行)
 3. 其他符号 (由编译器识别)

<<编码的奥义>>- CPU如何构成的

### 1.4 存储器
cpu是计算机的核心。它控制整个计算机的运作并进行运算，要想让一个CPU工作，就必须向它提供指令和数据。
指令和数据在存储器中存放，也就是平时说的内存。
所以，汇编(或者说是编程语言)就是把代码转成机器语言后，放到存储器后，即执行存储器的指令即可。
指令：告诉它怎么做
数据：告诉它哪些是被做的

一台PC机中内存的作用仅次于CPU
磁盘不同于内存，磁盘上的数据和程序，如果不读到内存中，就无法被CPU利用

### 1.5 指令和数据
在内存和磁盘上，指令和数据没有任何区别，都是二进制信息

### 1.6 存储单元
存储器不一定是内存阿，还有显存阿之类的！
存储器被划分成若干个存储单元，每个存储单元从0开始顺序编号
例：
一个存储器有128个存储单元，编号从0-127

计量单位
1kb = 1024b  2^10 
1mb = 1024kb 
1gb = 1024mb 
1tb = 1024gb 

磁盘的容量单位同内存的一样

### 1.7 CPU对存储器的读写
CPU要想进行数据的读写，必须和外部器件，进行三类信息的交换：
	存储单元的地址        -地址信息
	器件的选择，读或写命令 -控制信息
	读或写的数据          -数据信息

那么CPU是通过什么将地址、数据和控制信息传到存储芯片中的呢？
电子计算机能处理、传输的信息都是电信号，电信号当然用导线传送

在计算机中专门有连接CPU和其他芯片的导线，通常称为总线

物理上：一根根导线的集合
逻辑上划分：
	地址总线
	数据总线
	控制总线


## 基础知识03 

8086CPU 基础架构
### 1.8 地址总线
CPU是通过地址总线来指定存储单元的
地址总线上能传送多少个不同的信息
CPU就可以对多少个存储单元进行寻址

想达到完全的64位：
64位的CPU + 64位的OS + 64位的软件 

一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N。
这样的CPU最多可以寻找2的N次方个内存单元

内存单元是以一个字节为一个单元的

### 1.9 数据总线
CPU与内存或其他器件之间的数据传送是通过数据总线来进行的
数据总线的宽度决定了CPU和外界的数据传送速度

8088CPU数据总线一次可以传8位
8086CPU数据总线一次可以传16位

### 1.10 控制总线 
CPU对外部器件的控制是通过控制总线来进行的
在这里控制总线是个总称，控制总线是一些不同控制线的集合

有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制
所以，控制总线的宽度决定了CPU对外部器件的控制能力

## 04基础知识 
小结知识
1. 汇编指令是机器指令的助记符，同机器指令一一对应
2. 每一种CPU都有自己的汇编指令集
3. CPU可以直接使用的信息在存储器中存放
4. 在存储器中指令和数据没有任何区别，都是二进制信息 
5. 存储单元从零开始顺序编号
6. 一个存储单元可以存储8个bit 8个二进制数
7. 1B = 8b 1kb = 1024b
8. 每一个CPU芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线，一个CPU可以引出三种总线的宽度标志了这个CPU的不同方面的性能：
	地址总线的宽度-寻址能力 
	数据总线的宽度-CPU与其他器件进行数据传输时的一次数据传送量 
	控制总线的宽度-CPU对系统中其他器件的控制


用汇编指导写出更加好的高级语言的程序。

## 1.11 内存地址空间 
一个CPU的地址线宽度是10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成这个CPU的内存地址空间。
首先介绍两部分基础知识：主板和接口卡 

## 1.12 主板
在每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件
这些器件通过总线(地址 数据 控制总线)相连

## 1.13 接口卡
计算机系统中，所有可用程序控制其工作的设备，必须受到CPU的控制
CPU对外部设备不能直接控制，如显示器，音响，打印机等。直接控制这些设备工作的是 插在扩展插槽上的接口卡 

例： CPU控制显卡 显卡 控制显示器 

## 1.14 各类存储器芯片 
从读写属性上看分为两类：
	随机存储器RAM 和 只读存储器ROM 
从功能和连接上分类：
	随机存储器RAM 
	装有BIOS的ROM
	接口卡上的RAM 

PC机中各类存储器的逻辑连接情况

装有BIOS的ROM：
	基本输入输出系统
	BIOS是由主板和各类接口卡厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM 

## 1.15 内存地址空间
上面的存储器在物理上是独立的器件
但是它们有两点上相同：
	1. 都和CPU的总线相连
	2. CPU对他们进行读或写的时候都通过控制线发出内存读写命令

截图-第二幅。
假设：上图中的内存空间地址段 分配如下：
	地址0~7FFFH的32KB空间为主随机存储器的地址空间
	地址8000H~9FFFH的8KB空间为显存地址的空间
	地址A000H~FFFFH的24KB空间为各个ROM存储器的地址空间

不同的计算机系统的内存地址空间分配情况是不同的

8086PC机的内存空间分配(比较经典的CPU)：
00000
...
... (主存储器地址空间)RAM
...
9FFFF
A0000
...	(显存地址空间)
...
BFFFF
C0000
... (各类ROM地址空间)
...
FFFFF

最终运行程序的是CPU，我们用汇编编程的时候，必须从CPU角度考虑问题
我们学习这门课程的核心思维！！！

视频一个帖子问题代码：
{
	int i=5, j=5, q, p;
	p = (i++) + (i++) + (i++);
	q = (++j) + (++j) + (++j);
	printf("%d, %d , %d, %d \n", p, q, i, j);
	q为什么不是6+7+8=21 ？而是22呢？
	小甲鱼说不同编译器编译出来是不同的？
	我想到了比特说的，有歧义的表达式问题
	编译器搞的鬼，7+7+8 它这个编译器是先执行两次++操作，然后再相加 通过反编译看出来的 ！！！
}

对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，他的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。

-----------------第二章---------------
## 寄存器(CPU工作原理) 01
本章主要说CPU的内部通信 

本章目录概述
cpu概述
寄存器概述
	通用寄存器 
	数据在寄存器中的存放区情况
	为了兼容8086上一代CPU的寄存器是8位的，每个寄存器可以分为两个独立的8位寄存器使用 例：AX可以分AH(8~15) AL(LOW)(0-7),可以合可以拆开使用

## 寄存器(CPU工作原理) 02
2.2 字在寄存器中的存储 
关于数制的讨论 
几条汇编指令(汇编不区分大小写)
没有通过监测点请不要向下学习-王爽汇编

https://www.bilibili.com/video/BV1Rs411c7HG/?p=8&spm_id_from=pageDriver&vd_source=3a90c28136589066688d4183d633571f

## 寄存器(CPU工作原理) 03
2.4 物理地址
CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。
我们将这个唯一的地址称为物理地址。

2.5 17位结构的CPU
概括的讲，16位结构描述了一个CPU具有以下几个方面特征：
1. 运算器一次最多可以处理16位的数据
2. 通用寄存器的最大宽度是16位
3. 寄存器和运算器之间的通路是16位的

2.6 8086CPU给出物理地址的方法
8086有20位地址总线，可传送20位地址，寻址能力为1M (2^20 = 1Mb)
8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64K  (2^16 = 64KB)

问题：那么，8086CPU如何用内部16位的数据转换为20位的地址呢？
8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。

截图--8086CPU 相关部件的逻辑结构

8086CPU读写内存时，发生了这么一些事：
1. CPU中的相关部件提供两个16位的地址，一个称为段地址，一个称为偏移地址
2. 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件
3. 地址加法器将两个16位地址合成一个20位的地址
... 

地址加法器合成物理地址的方法：
	物理地址 = 段地址 * 16 + 偏移地址

例如：8086CPU访问地址为123C8H的内存单元

段地址*16 有一个更为常用的说法，就是数据左移4位，(二进制位)

我们通过观察移位次数和各种形式数据的关系：
1. 一个数据的二进制形式左移1位，相当于数据乘以2 
2. N位 2^N 
3. 地址加法器如何完成段地址 * 16的运算？

举例了：
两张只能写三位数的纸条，写下2826数字？
200 这张纸条*10 + 下面纸条的和 = 2826
826

## 寄存器(CPU工作原理) 04
2.8 段的概念
错误认识：
	内存被划分成一个一个的段，每一个段有一个段地址。
其实：
	内存并没有分段，段的划分来自于CPU，由于8086CPU用(段地址*16 + 偏移地址 = 物理地址)的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。

两点需要注意：
1. 段地址*16 必然是16的倍数，所以一个段的起始地址也一定是16的倍数
2. 偏移地址为16位，16位地址的存址能力为64K，所以一个段的长度最大为64K. 2^16b = 64kb 

内存单元地址小结：
CPU访问内存单元时，必须向内存提供内存单元的物理地址
8086CPU在内部用段地址和偏移地址移位相加的方法形成最终的物理地址

1. 观察下面的地址，有什么启发？
物理地址   段地址   偏移地址
21F60H    2000H     1F60H
		  2100H 	0F60H
		  ...		...

结论：CPU可以用不同的段地址和偏移地址形成同一个物理地址
条条大路通罗马。
2. 如果给定一个段地址，仅通过变化偏移地址来进行寻址，最多可以定位多少内存单元？
结论：偏移地址16位，变化范围为0-FFFFH，仅用偏移地址来寻址最多可寻64K个内存单元。
比如：给定段地址1000H，用偏移地址寻址，CPU的寻址范围为：10000H-1FFFFH.

在8086PC机中，存储单元的地址用两个元素来描述。即段地址和偏移地址。

数据在21F60H内存单元中。对于8086PC机的两种描述：
1. 数据存在内存2000：1F60单元中
2. 数据存在内存的2000段中的1F60单元中

可根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段

<<疯狂的程序员>> 程序员成长 励志类


## 寄存器(CPU工作原理) 05
### 2.9 段寄存器 段寄存器就是提供段地址的 8086CPU有4个段寄存器：
CS(提供代码地址) 
DS(提供数据地址) 
SS(提供堆栈地址)
ES(什么都有的地址，前面都放不下，放这个)
当8080CPU要访问内存时，由这四个段寄存器提供内存单元的段地址

### 2.10 CS和IP
CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址
CS为代码段寄存器
IP为指令指针寄存器(偏移地址的寄存器)

8086PC读取和执行指令的部件 图 动画演示！！！
工作过程的简要概述：
1. 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器 
2. IP = IP + 所读取指令的长度，从而指向下一条指令
3. 执行指令。转到步骤一，重复这个过程

在8086CPU加电启动或复位后，(即CPU刚开始工作时)，CS和IP被设置为CS=FFFFH，IP=0000H
即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行
FFFF0H单元中的指令是8086PC机开机后执行的第一条指令

在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行
如果说，内存中的一段信息曾被CPU执行过的花，那么，它所在的内存单元必然被CS:IP指向过

### 2.11 修改CS、IP的指令
在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的操控
CPU从何处执行指令是CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令

我们如何改变CS、IP的值呢、

如何修改AX中的值呢？
mov指令
如： mov ax, 123 
mov指令可以改变8086CPU大部分寄存器的值，被称为传送指令
能够通过mov指令改变CS、IP的值吗？

mov指令不能用于设置CS、IP的值，8086CPU没有提供这样的指令

8086CPU为CS、IP提供了另外的指令来改变它们的值：转义指令；

同时修改CS、IP的内容：
jmp 段地址：偏移地址
	jmp 2AE3:3
	jmp 3:0B16
功能：用指令中给出的段地址修改CS，偏移地址修改IP。

仅修改IP的内容：
jmp某一合法寄存器
	jmp ax (类似 mov IP, ax)
	jmp bx 
功能：用寄存器中的值修改IP

问题分析：CPU运行的流程  图片
内存中存放的机器码和对应汇编指令情况：
(初始：CS=2000H，IP=000H)
图片
图片的结果：
1. mov ax, 6622
2. jmp 1000:3
3. mov ax, 0000
4. mov bx, ax
5. jmp bx        ？？
6. mov ax, 0123H 
7. 转到第(3)步执行

### 2、12 代码段
对于8086PC机 在编程时，可以根据需要，将一组内存单元定义为一个段
可以将长度为N(N<=64kb)的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元，这段内存是用来存放代码的，从而定义了一个代码段
(段地址都是16的倍数，因为要*16的+偏移地址)

例如：
mov ax, 0000       (B8 00 00)
add ax, 0123       (05 23 01)
mov bx, ax         (8B D8)
jmp bx              (FF E3)

这段长度为10字节的字节的指令，存在从123B0H~123B9H的一组内存单元中，我们就可以认为，123B0H~123B9H这段内存单元是用来存放代码的，是一个代码段，它的段地址为123BH，长度为10字节。

如何使得代码段中的指令被执行呢？	
将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动的将我们定义的代码段中的指令当作指令来执行

CPU只认被CS:IP指向的内存单元中的内容为指令。
无论数据还是指令，计算机都是二进制的数
所以要将CS:IP指向所定义的代码段中的第一条指令的首地址

小结：
1. 段地址在8086CPU的寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址。
2. CS存放指令的段地址，IP存放指令的偏移地址

8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。

3. 8086CPU的工作过程：
	1. 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器
	2. IP指向下一条指令
	3. 执行指令。转到步骤1，重复这个过程
4. 8086CPU提供转移指令修改CS、IP的内容 

检测点2.3 
下面的3条指令执行后，CPU几次修改IP？都是在什么时候？最后IP的值是多少？
mov ax, bx
sub ax, ax 
jmp ax
答案：？
第一次：读取mov ax,bx之后 

第二次：读取sub ax,ax之后 

第三次：读取jmp ax之后 

第四次：执行jmp ax修改IP 

最后IP的值为0000H，因为最后ax中的值为0000H，所以IP中的值也为0000H  


## 实验一 寄存器 06
查看CPU和内存，用机器指令和汇编指令编程
程序是调试出来的。

具体看PPT内容。
几个指令。

## 寄存器 07 
讲作业 
也是实验性质的 后期来把 换个电脑实验  

# 第三章
## 寄存器(内存访问) 01

本章目录
3.1 内存中字的存储
3.2 DS和[address]
3.3 字的传送
3.4 mov add sub指令
3.5 数据段
3.6 栈
3.7 CPU提供的栈机制
3.8 栈顶越界的问题
3.9 push pop指令
3.10 栈段 

计算机还认识加法，除了0 1 

第二章中我们主要从CPU如何执行指令的角度讲解了8086CPU的逻辑结构形成物理地址的方法、相关的寄存器以及一些指令
本章从访问内存的角度继续学习几个寄存器

### 3.1 内存中字的存储
结论：
任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元

### 3.2 DS和[address]
CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址
在8086CPU中，内存地址由段地址和偏移地址组成
8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址

例如：
我们要读取的10000H单元的内容可以用以下程序段进行：
mov bx, 1000H
mov ds, bx
mov al, [0]

这三条指令将10000H(1000:0) 中的数据读到al中
mov al, [0]
已知的mov指令可完成的两种传送功能：
1. 将数据直接送入寄存器  mov ax, 2 
2. 将一个寄存器中的内容送入另一个寄存器中  mov bx, ax 
除此之外，mov指令还可以将一个内存单元中的内容送入一个寄存器
(ax bx 存放16个位的，al是8位的)

从那个内存单元送到那个寄存器中呢？
mov指令的格式：
	mov 寄存器名， 内存单元地址
"[...]" 表示一个内存单元，"[...]"中的0表示内存单元的偏移地址，
那么内存单元的段地址是多少呢？

执行指令时，8086CPU自动取DS中的数据为内存单元的段地址

如何用mov指令从10000H中读取数据？
	10000H表示为10000H中读取数据？
	将段地址1000H放入DS
	用mov al, [0] 完成传送 (mov指令中的[]说明操作对象是一个内存单元，[]中的0说明这个内存单元的偏移地址是0， 它的段地址默认在DS中)

能不能把1000H送入DS？
不能，
传送指令 mov ax, 1
相似的方式 mov ds, 1000H ?
8086CPU不支持将数据直接放入段寄存器的操作，DS是一个段寄存器 (硬件设计的问题)

数据 -> 通用寄存器 -> 段寄存器
(没有直达的物理电路)

问题：
写几条指令，将al中的数据送入内存单元10000H？
分析问题本质；如何将数据从寄存器送入内存单元？
结论：
    mov bx, 1000H 
	mov ds, bx 
	mov [0], al 
	间接 
	
### 3.3 字的传送
因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位的数据，也就是一次性传送一个字 
比如：
mov bx, 1000H
mov ds, bx 
mov ax, [0]   1000:0处的字型数据送入ax
mov [0], cx   cx中的16位数据送到1000：0处

问题3.3：
内存的情况下图，写出下面指令执行后寄存器ax bx cx 的值
mov ax, 1000H
mov ds, ax 
mov ax, [0]
mov bx, [2]
mov cx, [1]
add bx, [1]
add cx, [2]

10000H 23
10001H 11 
10002H 22
10003H 66 
内存情况示意图 

问题3.4：
内存中的情况如下图，写出下面指令执行后寄存器ax bx cx中的值
mov ax, 1000H
mov ds, ax
mov ax, 11316
mov [0], ax
mov bx, [0]
sub bx, [2]
mov [2], bx

10000H 23
10001H 11 
10002H 22
10003H 11 
内存情况示意图 

上机测试。

## 寄存器(内存访问) 02
上机测试：
-e 1000:0 23 11 22 66 
-d 1000:0 查看 
-r 查看 
-d 1386:100 查看都是00 没有数据 就可以覆盖的

-a 1386:100 
mov ax, ....上面的哪些指令
若调试 就退出 说明不兼容的 换个内存
-t 单步调试

上面我忽视了 字(2个字节) 字型(8位) 的区别。

------------------------、
## 寄存器(内存访问) 03
mov指令的几种形式：
	mov 寄存器， 数据     mov ax, 6 
	mov 寄存器， 寄存器   mov bx, ax 
	mov 寄存器， 内存单元 mov ax, [0]
	mov 内存单元， 寄存器 mov [0], ax 
	mov 段寄存器，寄存器  mov ds, ax 

add sub指令同mov一样的，都有两个操作对象。
用多了就熟悉了。 查手册即可。
add 寄存器，数据     add ax, 8
add 寄存器,寄存器	 add ax, bx 
add 寄存器,内存单元  add ax, [0]
add 内存单元，寄存器 add [0], ax 

sub 寄存器，数据 	 sub x, 9
sub 寄存器，寄存器   sub ax, bx 
sub 寄存器，内存单元 sub ax, [0]
sub 内存单元，寄存器 sub [0], ax 

### 数据段 
从这开始有些笔记不做了，只要一些关键的
比如我们用 123B0H~123B9H 这段空间来存放数据：
段地址：123BH 
长度：10字节 

123B0H ： 123B是段地址，0是偏移量 
一字是两个字节，16位
双字是4个字节，32位

吴宁老师 
jmp 是具有一个操作对象的指令。

## 寄存器(内存访问) 04
### 3.6 栈 

### 3.7 CPU提供的栈机制 
	现今的CPU中都有栈的设计
	8086CPU提供相关的指令来以栈的方式访问内存空间
	这意味着，我们在基于8086CPU编程的时候，可以将一段内存当作栈来使用。

	8086CPU提供入栈和出栈指令：最基本的 PUSH POP 
	push ax; 将寄存器ax中的数据送入栈中
	pop ax; 从栈顶取出数据送入ax 
	8086CPU的入栈和出栈操作都是以字位单位进行的。
	指令序列演示。8086CPU的栈操作。
	注意：字型数据用两个单元存放，高地址单位放高8位，低地址单元放低8位。
	两个疑问：
	1. CPU如何知道一段内存空间被当作栈使用？
		CPU如何知道当前要执行的指令所在的位置？
		寄存器CS和IP中存放着当前指令的段地址和偏移地址。
		8086CPU中，有两个寄存器：
			段寄存器SS 存放 栈顶 的段地址
			寄存器SP   存放 栈顶 的偏移地址 
		任意时候，SS:SP指向栈顶元素

	2. 执行push pop，如何知道哪个单元是栈顶单元？
		push指令的执行过程：（图形看PPT）
			push ax 
				1. SP = SP - 2
				2. 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。
				
		栈空，SS:SP指向占用空间 最高地址单元的下一个单元。见PPT
		内存是没有删除的机制，只要覆盖。替代了删除。

## 寄存器(内存访问) 05
	pop ax 
		1. 将SS:SP指向的内存单元处的数据送入ax中
		2. SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶 
		
		硬盘格式化，其实是指针发生了改变，想要格式化硬盘，用专业的工具覆盖数据，就很难恢复了。
		溢出攻击-栈顶越界  洗空攻击 替身攻击

	### 3.8 栈顶越界的问题 
	比如说在CPU中有记录栈顶上线和下限的寄存器，我们可以通过填写这些寄存器来指定栈空间的范围，
	然后，CPU在执行push指令的时候靠检测栈顶上限寄存器，在执行pop指令的时候靠检测栈顶下线寄存器保证不会越界。
	实际情况：8086CPU中没有这样的寄存器。

	8086CPU的工作机理，只考虑当前的情况：
		当前栈在何处
		当前要执行的指令是那一条 
	push和pop指令是可以在 寄存器和内存之间传送数据的。

	栈与内存：
	栈空间当然也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间。

	push 寄存器  将一个寄存器中的数据入栈
	pop 寄存器   用一个寄存器接收出栈的数据 
	push ax ;
	pop bx;

	段寄存器 都是以 s结尾的。ds es 
	通用寄存器 都是 x eax 结尾的 

	push pop指令的格式(3):
		push内存单元：将一个内存单元处的字入栈 -栈操作都是以字为单位的
		pop内存单元：出栈，用一个内存字单元接收出栈的数据
		push[0]
		pop[2]

		指令执行时，CPU要知道内存单元的地址，可以在push pop 指令中给出内存单元的偏移地址，
		段地址在指令执行时，CPU从ds中取得。

## 寄存器(内存访问) 06
	### 3.9 pus pop 
	数据都是害羞的，只能通过通用寄存器跟段寄存器发生关系 
	mov ax, 1000H 把数据给通用寄存器 然后再通过通用寄存器给段寄存器
	mov ss, ax  设置栈的段地址，SS=1000H 不能直接向的段寄存器SS送入数据，所以用ax中转
	mov sp, 0010H; 设置栈顶的偏移地址，因为栈为空，所以SP=0010H。
				上面三条指令设置栈顶地址，编程中要自己注意栈的大小。
	push ax 
	push bx 
	push ds 

	经过思考。答案不是唯一的，没有标准答案。
	题目：
	初始栈不太会？有个什么栈的寄存器
	mov ax, 001AH
	mov bx, 001BH 
	push ax 
	push bx 
	mov ax 0 
	mov bx 0
	pop ax 
	pop bx  
	参考答案：
	mov ax, 1000H 
	mov ss, ax 
	mov sp, 0010H 初始化栈顶 
	mov ax, 001AH 
	mov bx, 001BH 
	push ax 
	push bx 
	sub ax, ax	将ax清零，也可以用mov ax, 0
				sub ax, ax 的机器码为两个字节 
				mov ax, 0 的机器码为3个字节
	sub bx, bx 
	pop bx 
	pop ax 顺序不要反了 

	系统特别喜欢用 xor ax, ax 置0操作 用C++测试哈 

	题目：要在10000H写入字型数据2266H，代码：
	mov ax, 10000H 
	mov ds, ax 
	mov ax, 2266H 
	mov [0], ax 
	不能使用mov指令呢？
	写汇编不要想什么 数据区 代码区 还是什么鬼！！！ 通通就是一个指令数据而已，意义是我们赋予给它的。
	mov ax, 1000H  
	mov ss, ax 
	mov sp, 2   忘记了这里 一个字 
	-----------下面已知 
	mov ax, 2266H 
	push ax  

	不要把自己学死了，一些玩具都学的很全。

	push pop 实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令
	访问的内存单元的地址不是在指令中给出的，而是由SS:SP给出的。
	同时，push pop指令还要 改变SP中的内容。

	push pop指令同mov指令不同：前者两步 mov一步操作。
	push: 先改变SP 后向SS:SP处传送 
	pop: 先读取SS:SP处的数据，后改变SP。

	注意： push pop 等栈操作指令，修改的只是SP-偏移地址。也就是说，栈顶的变化范围最大为 0-FFFFH 
	16位的CPU。FFFFH
	这就是8086CPU提供的栈操作机制。

	栈的总结：看PPT把。

## 寄存器(内存访问) 06
	### 3.10 栈段 
	对于8086PC机，在编程时，我们可以根据需要，将一组内存单元定义为一个段。
	我们可以将长度为N(N <= 64K) 的一组地址连续、起始地址为16的倍数的内存单元，当作栈来使用，
	从而定义了一个栈段 。

	CPU不会管什么栈，只知道内存和指向内存的指针。
	如果我们将10000H-1FFFFH 这段空间当作栈段，初始状态是空的，此时，SS=1000H  SP? 
	分析不想写了，思考把。？？

	一个栈段最大可以设为多少？为什么？
	2^16次方，64KB 

	栈的出处？临时存放东西的，main函数调用其他函数，想出来的。也就是临时存放。
	栈 为了函数而存在的，面对过程而存在的。

	我们可以自己安排，一个段存放数据，将它定义为 数据段还是代码段还是栈段 
	我们这样安排后，若要CPU按照我们的安排来访问这些段，就要：
	对于(数据段)，将它的段地址放在DS中，用mov add sub等访问内存单元的指令时，CPU就将我们定义的数据段
	中的内容当作数据段来访问。
	对于(代码段)，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的命令
	对于(栈段)，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，比如
	执行push pop等 就将我们定义的栈段当作栈空间来用。

	如何让CPU按我们的安排行事。要非常清楚CPU的工作机理。才能控制CPU。游刃有余。
	研究CPU原理，卧槽，让我不要去学习 window mfc 只是都封装成一个个类，本身API就够复杂了，还变成一个一个的类。
	要学习windows 就学习windows API编程。

	代码题：？？蒙蔽 
	将 10000H - 1001FH 安排为代码段，并在里面存储代码：
	mov ax, 1000H 
	mov ss, ax 
	mov sp, 0020H  初始化栈顶 
	mov ax, cs 
	mov ds, ax   设置数据段段地址 
	mov ax, [0]
	add ax, [2]
	mov bx, [4]
	add bx, [6]
	push ax 
	push bx 
	pop ax 
	pop bx 

	一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么都不是。
	关键在于CPU中寄存器的设置，即：CS IP SS SP DS 的指向。
	以前内存很宝贵的。所以混用，重复使用。利用空间。

	没有通过监测点，不要向下学习。！！！



--------第四章了 开始写代码了--------------------------------------
## 4.1
	1-3章 必须理解透。 玩逆向的话
	一个源程序从写出到执行的过程
	可执行文件：
		程序(从源程序中的汇编指令翻译过来的机器码) 和 数据(源程序中定义的数据) 
		相关的描述信息 (比如：程序有多大 要占用多少内存空间等)

	OS中，执行可执行文件中的程序。
	OS依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化(
	比如：设置CS:IP指向第一条要执行的指令)，然后由CPU执行程序。
	编写 -- 编译链接 -- 执行 

	源程序：
	assume cs:codesg 			汇编指令 
	codesg segment 

	start:	move ax, 0123H		伪指令 
			move bx, 0456H
			add ax, bx 
			add ax, ax 

			mov ax, 4c00h
			int 21h 
	codesg ends
	end 

	伪指令：没有对应的机器码的指令，最终不被CPU所执行。
	谁来执行伪指令呢？
		伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。

	定义一个段：是栈段还是数据段
	segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。
	一个段必须由一个名称来标识，使用格式为：
		段名 segment 
		段名 ends 
	一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用的。
	一个有意义的汇编程序中至少有一个段，这个段用来存放代码。

	End 
	是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。
	程序写完了，记得加上end，否则编译器不知道程序何处结束。伪指令。
	注意区分：伪指令和汇编指令(push)。
	end结束，ends是段的结束 segment
	assume 假设，假如。它假设某一段寄存器和程序中的某一个用 segment..ends 定义的段相关联
	通过assument说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。

	汇编源程序：
		伪指令 -- 编译器处理
		汇编指令-- 编译为机器码 
	程序：源程序中最终由计算机执行、处理的指令或数据。

	我们可以将源程序文件中的所有内容称为源程序，将源程序中最终由计算机执行处理的指令或数据，称为程序。
	程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中。
	PE 可执行文件。黑客编程重要。PE结构。

## 4.2 源程序 
	标号：一个标号指代了一个地址。别名。
	codesg: 放在setgment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。
	任务：编程运算 2^3 
		abc segment 定义一个段  
		mov ax, 2   实现处理任务
		add ax, ax 
		add ax, ax 
		abc ends    任务结束 
					段与段寄存器关联 
	
	可执行程序是如何被执行的呢？OS 
	DOS中的程序运行：
		DOS是一个单任务OS。
		一个程序P2在可执行文件中，则必须有一个正在运行的程序P1。由P1来 吧P2从可执行文件中加载进内存中，
		将CPU的控制权交给P2，P2才能运行。P2开始运行后，P1暂停运行。
		而当P2运行完毕后，应该将CPU控制权还给P1，此后，P1继续运行。
		返回的过程称为 程序返回。

		应该在程序的末尾添加返回的程序段。
			mov ax, 4c00H 
			int 21H  (int中断 第21号中断 dos系统的发明-中断)
			这两条指令所实现的功能就是程序返回。

	段结束 、 程序结束 、 程序返回 区别。省略PPT中。
	语法错误和逻辑错误。

	4.4 编译源程序 
	MASM。课本5。0 小甲鱼6.11 
	nodepad++ 
	环境都无法搭建好阿。

	关于编译和链接。
	编译和链接作用是什么呢？
	链接作用：当源程序很大时，分成多个编译每个源程序称为目标文件后，再用链接程序将它们链接到一起，生成一个可执行文件
	程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件链接到一起，生成一个可执行文件。

	最终结果是 获取可执行文件。
	用汇编语言编程：用到：
		编译器 编译器masm 连接器link 调试工具debug 

## 4.3 
	

## 22 可执行文件中的程序装入内存并运行的原理
	OS是一个复杂的系统，通用的OS，都会提供一个称为shell的程序，用户使用这个程序来
	操作计算机系统工作。
	DOS中的cmd 在DOS中被称为命令解释器 就是DOS系统的shell

	我们在DOS中直接执行1.exe时，是正在运行的command将1.exe的程序加载入内存。
	commadn设置CPU的CS:IP指向程序的第一条指令，即程序的入口，从而使程序得以运行。
	程序运行结束后，返回到command中，CPU继续运行comadn.

	编程->1.asm->编译->1.obj->连接->1.exe->加载->内存中的程序->运行
	edit    	 masm 	      link 		   command 			CPU 	

	为了观察程序的运行过程，我们可以使用debug.
	debug可以将程序加载入内存，设置CS:IP指向程序的入口，但debug并不放弃对CPU的控制，
	这样，我们就可以使用DEBUG的相关命令来单步执行程序，查看每条指令的执行结果。



# 第五章 23
	5.1 [bx]
	5.2 Loop指令
	5.3 在DEBUG中跟踪使用loop指令实现的循环程序
	... 

	看不下去了，没有实操的环境 
	想想办法如何搞环境 是虚拟机 还是及电脑过来？
	



