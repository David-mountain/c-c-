没有通过检测的禁止向下学习！！！正反馈阿这是，突然忘记了这个点。！！！！！！！！

 ## 基础知识02

 ### 1.3 汇编语言的组成
 3类组成：
 1. 汇编指令(机器码的助记符) -核心
 2. 伪指令 (由编译器执行)
 3. 其他符号 (由编译器识别)

<<编码的奥义>>- CPU如何构成的

### 1.4 存储器
cpu是计算机的核心。它控制整个计算机的运作并进行运算，要想让一个CPU工作，就必须向它提供指令和数据。
指令和数据在存储器中存放，也就是平时说的内存。
指令：告诉它怎么做
数据：告诉它哪些是被做的

一台PC机中内存的作用仅次于CPU
磁盘不同于内存，磁盘上的数据和程序，如果不读到内存中，就无法被CPU利用

### 1.5 指令和数据
在内存和磁盘上，指令和数据没有任何区别，都是二进制信息

### 1.6 存储单元
存储器不一定是内存阿，还有显存阿之类的！
存储器被划分成若干个存储单元，每个存储单元从0开始顺序编号
例：
一个存储器有128个存储单元，编号从0-127

计量单位
1kb = 1024b  2^10 
1mb = 1024kb 
1gb = 1024mb 
1tb = 1024gb 

磁盘的容量单位同内存的一样

### 1.7 CPU对存储器的读写
CPU要想进行数据的读写，必须和外部器件，进行三类信息的交换：
	存储单元的地址        -地址信息
	器件的选择，读或写命令 -控制信息
	读或写的数据          -数据信息

那么CPU是通过什么将地址、数据和控制信息传到存储芯片中的呢？
电子计算机能处理、传输的信息都是电信号，电信号当然用导线传送

在计算机中专门有连接CPU和其他芯片的导线，通常称为总线

物理上：一根根导线的集合
逻辑上划分：
	地址总线
	数据总线
	控制总线


## 基础知识03 

8086CPU 基础架构
### 1.8 地址总线
CPU是通过地址总线来指定存储单元的
地址总线上能传送多少个不同的信息
CPU就可以对多少个存储单元进行寻址

想达到完全的64位：
64位的CPU + 64位的OS + 64位的软件 

一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N。
这样的CPU最多可以寻找2的N次方个内存单元

内存单元是以一个字节为一个单元的

### 1.9 数据总线
CPU与内存或其他器件之间的数据传送是通过数据总线来进行的
数据总线的宽度决定了CPU和外界的数据传送速度

8088CPU数据总线一次可以传8位
8086CPU数据总线一次可以传16位

### 1.10 控制总线 
CPU对外部器件的控制是通过控制总线来进行的
在这里控制总线是个总称，控制总线是一些不同控制线的集合

有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制
所以，控制总线的宽度决定了CPU对外部器件的控制能力

## 04基础知识 
小结知识
1. 汇编指令是机器指令的助记符，同机器指令一一对应
2. 每一种CPU都有自己的汇编指令集
3. CPU可以直接使用的信息在存储器中存放
4. 在存储器中指令和数据没有任何区别，都是二进制信息 
5. 存储单元从零开始顺序编号
6. 一个存储单元可以存储8个bit 8个二进制数
7. 1B = 8b 1kb = 1024b
8. 每一个CPU芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线，一个CPU可以引出三种总线的宽度标志了这个CPU的不同方面的性能：
	地址总线的宽度-寻址能力 
	数据总线的宽度-CPU与其他器件进行数据传输时的一次数据传送量 
	控制总线的宽度-CPU对系统中其他器件的控制


用汇编指导写出更加好的高级语言的程序。

## 1.11 内存地址空间 
一个CPU的地址线宽度是10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成这个CPU的内存地址空间。
首先介绍两部分基础知识：主板和接口卡 

## 1.12 主板
在每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件
这些器件通过总线(地址 数据 控制总线)相连

## 1.13 接口卡
计算机系统中，所有可用程序控制其工作的设备，必须受到CPU的控制
CPU对外部设备不能直接控制，如显示器，音响，打印机等。直接控制这些设备工作的是 插在扩展插槽上的接口卡 

例： CPU控制显卡 显卡 控制显示器 

## 1.14 各类存储器芯片 
从读写属性上看分为两类：
	随机存储器RAM 和 只读存储器ROM 
从功能和连接上分类：
	随机存储器RAM 
	装有BIOS的ROM
	接口卡上的RAM 

PC机中各类存储器的逻辑连接情况

装有BIOS的ROM：
	基本输入输出系统
	BIOS是由主板和各类接口卡厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM 

## 1.15 内存地址空间
上面的存储器在物理上是独立的器件
但是它们有两点上相同：
	1. 都和CPU的总线相连
	2. CPU对他们进行读或写的时候都通过控制线发出内存读写命令

截图-第二幅。
假设：上图中的内存空间地址段 分配如下：
	地址0~7FFFH的32KB空间为主随机存储器的地址空间
	地址8000H~9FFFH的8KB空间为显存地址的空间
	地址A000H~FFFFH的24KB空间为各个ROM存储器的地址空间

不同的计算机系统的内存地址空间分配情况是不同的

8086PC机的内存空间分配(比较经典的CPU)：
00000
...
... (主存储器地址空间)RAM
...
9FFFF
A0000
...	(显存地址空间)
...
BFFFF
C0000
... (各类ROM地址空间)
...
FFFFF

最终运行程序的是CPU，我们用汇编编程的时候，必须从CPU角度考虑问题
我们学习这门课程的核心思维！！！

视频一个帖子问题代码：
{
	int i=5, j=5, q, p;
	p = (i++) + (i++) + (i++);
	q = (++j) + (++j) + (++j);
	printf("%d, %d , %d, %d \n", p, q, i, j);
	q为什么不是6+7+8=21 ？而是22呢？
	小甲鱼说不同编译器编译出来是不同的？
	我想到了比特说的，有歧义的表达式问题
	编译器搞的鬼，7+7+8 它这个编译器是先执行两次++操作，然后再相加 通过反编译看出来的 ！！！
}

对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，他的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。

-----------------第二章---------------
## 寄存器(CPU工作原理) 01
本章主要说CPU的内部通信 

本章目录概述
cpu概述
寄存器概述
	通用寄存器 
	数据在寄存器中的存放区情况
	为了兼容8086上一代CPU的寄存器是8位的，每个寄存器可以分为两个独立的8位寄存器使用 例：AX可以分AH(8~15) AL(LOW)(0-7),可以合可以拆开使用

## 寄存器(CPU工作原理) 02
2.2 字在寄存器中的存储 
关于数制的讨论 
几条汇编指令(汇编不区分大小写)
没有通过监测点请不要向下学习-王爽汇编

https://www.bilibili.com/video/BV1Rs411c7HG/?p=8&spm_id_from=pageDriver&vd_source=3a90c28136589066688d4183d633571f

## 寄存器(CPU工作原理) 03
2.4 物理地址
CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。
我们将这个唯一的地址称为物理地址。

2.5 17位结构的CPU
概括的讲，16位结构描述了一个CPU具有以下几个方面特征：
1. 运算器一次最多可以处理16位的数据
2. 通用寄存器的最大宽度是16位
3. 寄存器和运算器之间的通路是16位的

2.6 8086CPU给出物理地址的方法
8086有20位地址总线，可传送20位地址，寻址能力为1M (2^20 = 1Mb)
8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64K  (2^16 = 64KB)

问题：那么，8086CPU如何用内部16位的数据转换为20位的地址呢？
8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。

截图--8086CPU 相关部件的逻辑结构

8086CPU读写内存时，发生了这么一些事：
1. CPU中的相关部件提供两个16位的地址，一个称为段地址，一个称为偏移地址
2. 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件
3. 地址加法器将两个16位地址合成一个20位的地址
... 

地址加法器合成物理地址的方法：
	物理地址 = 段地址 * 16 + 偏移地址

例如：8086CPU访问地址为123C8H的内存单元

段地址*16 有一个更为常用的说法，就是数据左移4位，(二进制位)

我们通过观察移位次数和各种形式数据的关系：
1. 一个数据的二进制形式左移1位，相当于数据乘以2 
2. N位 2^N 
3. 地址加法器如何完成段地址 * 16的运算？

举例了：
两张只能写三位数的纸条，写下2826数字？
200 这张纸条*10 + 下面纸条的和 = 2826
826

## 寄存器(CPU工作原理) 04
2.8 段的概念
错误认识：
	内存被划分成一个一个的段，每一个段有一个段地址。
其实：
	内存并没有分段，段的划分来自于CPU，由于8086CPU用(段地址*16 + 偏移地址 = 物理地址)的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。

两点需要注意：
1. 段地址*16 必然是16的倍数，所以一个段的起始地址也一定是16的倍数
2. 偏移地址为16位，16位地址的存址能力为64K，所以一个段的长度最大为64K. 2^16b = 64kb 

内存单元地址小结：
CPU访问内存单元时，必须向内存提供内存单元的物理地址
8086CPU在内部用段地址和偏移地址移位相加的方法形成最终的物理地址

1. 观察下面的地址，有什么启发？
物理地址   段地址   偏移地址
21F60H    2000H     1F60H
		  2100H 	0F60H
		  ...		...

结论：CPU可以用不同的段地址和偏移地址形成同一个物理地址
条条大路通罗马。
2. 如果给定一个段地址，仅通过变化偏移地址来进行寻址，最多可以定位多少内存单元？
结论：偏移地址16位，变化范围为0-FFFFH，仅用偏移地址来寻址最多可寻64K个内存单元。
比如：给定段地址1000H，用偏移地址寻址，CPU的寻址范围为：10000H-1FFFFH.

在8086PC机中，存储单元的地址用两个元素来描述。即段地址和偏移地址。

数据在21F60H内存单元中。对于8086PC机的两种描述：
1. 数据存在内存2000：1F60单元中
2. 数据存在内存的2000段中的1F60单元中

可根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段

<<疯狂的程序员>> 程序员成长 励志类


## 寄存器(CPU工作原理) 05
### 2.9 段寄存器 段寄存器就是提供段地址的 8086CPU有4个段寄存器：
CS(提供代码地址) 
DS(提供数据地址) 
SS(提供堆栈地址)
ES(什么都有的地址，前面都放不下，放这个)
当8080CPU要访问内存时，由这四个段寄存器提供内存单元的段地址

### 2.10 CS和IP
CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址
CS为代码段寄存器
IP为指令指针寄存器(偏移地址的寄存器)

8086PC读取和执行指令的部件 图 动画演示！！！
工作过程的简要概述：
1. 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器 
2. IP = IP + 所读取指令的长度，从而指向下一条指令
3. 执行指令。转到步骤一，重复这个过程

在8086CPU加电启动或复位后，(即CPU刚开始工作时)，CS和IP被设置为CS=FFFFH，IP=0000H
即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行
FFFF0H单元中的指令是8086PC机开机后执行的第一条指令

在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行
如果说，内存中的一段信息曾被CPU执行过的花，那么，它所在的内存单元必然被CS:IP指向过

### 2.11 修改CS、IP的指令
在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的操控
CPU从何处执行指令是CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令

我们如何改变CS、IP的值呢、

如何修改AX中的值呢？
mov指令
如： mov ax, 123 
mov指令可以改变8086CPU大部分寄存器的值，被称为传送指令
能够通过mov指令改变CS、IP的值吗？

mov指令不能用于设置CS、IP的值，8086CPU没有提供这样的指令

8086CPU为CS、IP提供了另外的指令来改变它们的值：转义指令；

同时修改CS、IP的内容：
jmp 段地址：偏移地址
	jmp 2AE3:3
	jmp 3:0B16
功能：用指令中给出的段地址修改CS，偏移地址修改IP。

仅修改IP的内容：
jmp某一合法寄存器
	jmp ax (类似 mov IP, ax)
	jmp bx 
功能：用寄存器中的值修改IP

问题分析：CPU运行的流程  图片
内存中存放的机器码和对应汇编指令情况：
(初始：CS=2000H，IP=000H)
图片
图片的结果：
1. mov ax, 6622
2. jmp 1000:3
3. mov ax, 0000
4. mov bx, ax
5. jmp bx        ？？
6. mov ax, 0123H 
7. 转到第(3)步执行

### 2、12 代码段
对于8086PC机 在编程时，可以根据需要，将一组内存单元定义为一个段
可以将长度为N(N<=64kb)的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元，这段内存是用来存放代码的，从而定义了一个代码段
(段地址都是16的倍数，因为要*16的+偏移地址)

例如：
mov ax, 0000       (B8 00 00)
add ax, 0123       (05 23 01)
mov bx, ax         (8B D8)
jmp bx              (FF E3)

这段长度为10字节的字节的指令，存在从123B0H~123B9H的一组内存单元中，我们就可以认为，123B0H~123B9H这段内存单元是用来存放代码的，是一个代码段，它的段地址为123BH，长度为10字节。

如何使得代码段中的指令被执行呢？	
将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动的将我们定义的代码段中的指令当作指令来执行

CPU只认被CS:IP指向的内存单元中的内容为指令。
无论数据还是指令，计算机都是二进制的数
所以要将CS:IP指向所定义的代码段中的第一条指令的首地址

小结：
1. 段地址在8086CPU的寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址。
2. CS存放指令的段地址，IP存放指令的偏移地址

8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。

3. 8086CPU的工作过程：
	1. 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器
	2. IP指向下一条指令
	3. 执行指令。转到步骤1，重复这个过程
4. 8086CPU提供转移指令修改CS、IP的内容 

检测点2.3 
下面的3条指令执行后，CPU几次修改IP？都是在什么时候？最后IP的值是多少？
mov ax, bx
sub ax, ax 
jmp ax
答案：？
第一次：读取mov ax,bx之后 

第二次：读取sub ax,ax之后 

第三次：读取jmp ax之后 

第四次：执行jmp ax修改IP 

最后IP的值为0000H，因为最后ax中的值为0000H，所以IP中的值也为0000H  


## 实验一 寄存器 06
查看CPU和内存，用机器指令和汇编指令编程
程序是调试出来的。

具体看PPT内容。
几个指令。

## 寄存器 07 
讲作业 
也是实验性质的 后期来把 换个电脑实验  

# 第三章
## 寄存器(内存访问) 01

本章目录
3.1 内存中字的存储
3.2 DS和[address]
3.3 字的传送
3.4 mov add sub指令
3.5 数据段
3.6 栈
3.7 CPU提供的栈机制
3.8 栈顶越界的问题
3.9 push pop指令
3.10 栈段 

计算机还认识加法，除了0 1 

第二章中我们主要从CPU如何执行指令的角度讲解了8086CPU的逻辑结构形成物理地址的方法、相关的寄存器以及一些指令
本章从访问内存的角度继续学习几个寄存器

### 3.1 内存中字的存储
结论：
任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元

### 3.2 DS和[address]
CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址
在8086CPU中，内存地址由段地址和偏移地址组成
8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址

例如：
我们要读取的10000H单元的内容可以用以下程序段进行：
mov bx, 1000H
mov ds, bx
mov al, [0]

这三条指令将10000H(1000:0) 中的数据读到al中
mov al, [0]
已知的mov指令可完成的两种传送功能：
1. 将数据直接送入寄存器  mov ax, 2 
2. 将一个寄存器中的内容送入另一个寄存器中  mov bx, ax 
除此之外，mov指令还可以将一个内存单元中的内容送入一个寄存器
(ax bx 存放16个位的，al是8位的)

从那个内存单元送到那个寄存器中呢？
mov指令的格式：
	mov 寄存器名， 内存单元地址
"[...]" 表示一个内存单元，"[...]"中的0表示内存单元的偏移地址，
那么内存单元的段地址是多少呢？

执行指令时，8086CPU自动取DS中的数据为内存单元的段地址

如何用mov指令从10000H中读取数据？
	10000H表示为10000H中读取数据？
	将段地址1000H放入DS
	用mov al, [0] 完成传送 (mov指令中的[]说明操作对象是一个内存单元，[]中的0说明这个内存单元的偏移地址是0， 它的段地址默认在DS中)

能不能把1000H送入DS？
不能，
传送指令 mov ax, 1
相似的方式 mov ds, 1000H ?
8086CPU不支持将数据直接放入段寄存器的操作，DS是一个段寄存器 (硬件设计的问题)

数据 -> 通用寄存器 -> 段寄存器
(没有直达的物理电路)

问题：
写几条指令，将al中的数据送入内存单元10000H？
分析问题本质；如何将数据从寄存器送入内存单元？
结论：
    mov bx, 1000H 
	mov ds, bx 
	mov [0], al 
	间接 
	
### 3.3 字的传送
因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位的数据，也就是一次性传送一个字 
比如：
mov bx, 1000H
mov ds, bx 
mov ax, [0]   1000:0处的字型数据送入ax
mov [0], cx   cx中的16位数据送到1000：0处

问题3.3：
内存的情况下图，写出下面指令执行后寄存器ax bx cx 的值
mov ax, 1000H
mov ds, ax 
mov ax, [0]
mov bx, [2]
mov cx, [1]
add bx, [1]
add cx, [2]

10000H 23
10001H 11 
10002H 22
10003H 66 
内存情况示意图 

问题3.4：
内存中的情况如下图，写出下面指令执行后寄存器ax bx cx中的值
mov ax, 1000H
mov ds, ax
mov ax, 11316
mov [0], ax
mov bx, [0]
sub bx, [2]
mov [2], bx

10000H 23
10001H 11 
10002H 22
10003H 11 
内存情况示意图 

上机测试。

## 寄存器(内存访问) 02
上机测试：
-e 1000:0 23 11 22 66 
-d 1000:0 查看 
-r 查看 
-d 1386:100 查看都是00 没有数据 就可以覆盖的

-a 1386:100 
mov ax, ....上面的哪些指令
若调试 就退出 说明不兼容的 换个内存
-t 单步调试

上面我忽视了 字(2个字节) 字型(8位) 的区别。




