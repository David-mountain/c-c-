MAC地址、IP地址、Netmask、端口分层模型
-----MAC地址------------------
6个字节，48位
网卡：又称网络适配器或网络接口卡NIC,但是现在更多的人愿意使用更为简单的名称网卡。
通过网卡能够使不同的计算机之间连接，从而完成数据通信等功能。
MAC地址：用于表示网络设备，类似于身份证号，且理论上全球唯一。标识网卡的id。
        一般用来标识主机的id，id是一个物理地址。不会变的。不像虚拟地址。

网络设置--更改适配器(适配器就是网卡阿)--显示的都是网卡--右边--状态 

连接特定的 DNS 后缀: 
描述: Realtek USB FE Family Controller
物理地址: ‎00-E0-4C-36-00-AB    !!!!!标识唯一的网卡id 6个字节 48位 
已启用 DHCP: 是
IPv4 地址: 192.168.1.125
IPv4 子网掩码: 255.255.255.0
获得租约的时间: 2023年5月21日 9:40:34
租约过期的时间: 2023年5月25日 14:35:13
IPv4 默认网关: 192.168.1.1
IPv4 DHCP 服务器: 192.168.1.1
IPv4 DNS 服务器: 192.168.1.1
IPv4 WINS 服务器: 
已启用 NetBIOS over Tcpip: 是
IPv6 地址: 240e:3b2:3cb4:8540:856b:3aa0:9c66:3eb8
临时 IPv6 地址: 240e:3b2:3cb4:8540:15e5:dabd:a585:ad1d
临时 IPv6 地址: 240e:3b2:3cb4:8540:e482:d5ea:4899:572d
连接-本地 IPv6 地址: fe80::d6b2:45d2:c134:7e1c%12
IPv6 默认网关: fe80::1%12
IPv6 DNS 服务器: fe80::1%12, fe80::1%12

-----IP地址------------------
IP地址是标识主机的id，这个id是虚拟，会改变。
ipv6 128 16个字节 
ipv4 4个字节 32位 2^32最多个
公网多用ipv6了，局域网使用者少可能会用ipv4
一个IP将其分为子网id和主机id
子网id和主机id需要和子网掩码一起来看，

IPv4 地址: 192.168.1.125
IPv4 子网掩码: 255.255.255.0
ip中被连续的1覆盖的位就是子网id
ip中被连续的0覆盖的位就是主机id 

视频举例：
ip: 10 1 1 2
0000 1010  0000 0001  0000 0001  0000 0010
子网掩码：netmask
255 255 255 0  (要么是连续的1 要么是连续的0 255 255 0 255就是不对的)
1111 1111  1111 1111  1111 1111  0000 0000
255(2^9-1 10进制) -> 1111 1111  (2进制)

子网id: 10.1.1
主机id: 2 

网段地址：10.1.1.0
广播地址：10.1.1.255 
这两个地址是不能设置的。
主机id分配的范围： 10.1.1.1 - 10.1.1.254 可以设置。 即2^8-2 = 254 
其实就是最后一个字节给了用于id设置，然后其中的0 255不能设置。

192.168.1.23/24(255.255.255)
/24代表前面24个1.
子网id是：192.168.1
主机id: 2
网段地址： 192.168.1.0 
主机id分配的范围：同上。

ip中被连续的1覆盖的位就是子网id
ip中被连续的0覆盖的位就是主机id 

固定自己的IP地址？？

说法：上面我一大堆 就是以太网卡的 
IP：以太网卡的IP地址。

ping 这是一个命令，用来测试两台主机的网络连通性。
视频中没有ping通，有防火墙吗？
这里又讲到了网关，什么是网关？我上面一大堆网卡状态中有：
IPv4 默认网关: 192.168.1.1
网关其实也是一个网卡，给它设置了一个IP，这个IP可以随机，
关闭防火墙，再ping 

ping 127.0.0.1 
ping不通，收不到我发出的广播

通常称127.0.0.1 是回环地址。
功能：主要是测试本机的网络配置，能ping通127.0.0.1 说明本地的网卡和IP协议安装没有问题。
注意：127.0.0.1-127.255.255.254 中的任何地址都将回环到本地 主机中
不属于任何一个有类别地址类，它代表设备的本地虚拟接口
直接手动配置static。

IP地址分类：A B C D E 省略。

windows如何设置IP：进入某网卡，然后属性，如果使用的是IPV4，双击 进入即可。
网关其实也是一块网卡，如果你要访问外网的时候，那么你要经过这块网卡，
这块网卡的IP你要告诉它，如果不访问外网的话，这其实可以不用。

-------端口---------------
为什么不用进程号标识，而用端口标识呢？
每次启动进程号在变，就找不到了，而端口号是固定的，你看有些软件都是固定的端口号就是这个原因。
所以用端口号来标识这个应用，这个进程。
0-65535,端口冲突了，你的应用是无法启动的。
1024-65535
写网络，都是人为绑定一个端口。
一个程序可以有多个端口，但是一个端口不能标识多个程序。
知名端口：1-1023  由互联网数字分配机构IANA根据用户需要进行统一分配
例如：FTP-21 HTTP-80 
动态端口：1024-65535 应用程序通常使用的范围
注意：端口号类似于进程号，同一时刻只能标识一个进程。
可以重复使用。

-------OSI七层模型-----------------
OSI 7层: 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层  (应表会传 网数物)
TCP/IP 4层： 应用层          传输层 网络层     网络接口层     (应传网网)

数据链路层 负责收发数据的 通过MAC地址判断是否要收发地址         即是否是给我的数据包
网络层：通过IP判断数据包是否达到这台主机的 给网络两台主机提供路径选择  即是否给我这台主机的
传输层：用到端口，用来区分数据给到哪一个应用程序                即给哪个应用程序的
会话层：建立连接的
表示层：解码，解压缩阿，把一些0101转成应用程序可以识别的数据，解码
应用层：拿到这些数据 

应用层 应用程序之间     FTP Telnet  TFTP NFS
传输层 进程到进程之间   TCP   UDP
网络层 主机到主机之间   ICMP IP  IGMP
链路层 设备到设备之间   ARP 硬件接口 RARP

ARP(地址解析协议 通过IP找MAC地址)
RARP(反向地址解析协议，通过MAC找IP)

发数据是 从上往下 发包 
收数据是 从下往上 收包 

三次握手，四次挥手？具体细节深入。

我们应用层都是在应用层，如果是黑客需要深入了解协议。

UDP报头： 8个字节
UDP首部： 16位源端口号 16位目的端口号 16位UDP长度 16位UDP校验和  
数据：偶数个字节不足补充0

TCP报头：20个字节
16位源端口号 16位目的端口号
序列号32位
确认号32位
头部长度4位(1个单位代表4个字节，因为放不下 20/4=5) 保留6位 
URG ACK(确认) PSH(推送) RST(无效的) SYN(请求连接) FIN(关闭连接)
窗口尺寸16位 (缓冲区的大小，不能一直发阿，我来不及收就丢了)
TCP校验和16位 
紧急指针16位
选项32位

数据 

IP报头：20个字节
版本4位 首部长度4位 服务类型8位 总长度16位
标识16位 标志3位 片偏移13位
生存时间TTL8位 协议类型8位 头部校验和16位
源IP地址32位 
目的IP地址32位

选项32位
数据 

没网ping不通百度。要联网。

MAC头部：14个字节
目的地址6 源地址6 类型2 数据46-1500 CRC4
                类型0800-2        IP数据报 46-1500 
                类型0806-2   ARP请求、应答-28   PAD-18 (不足46，不要补齐46)
                类型8035-2   PARP请求、应答-28   PAD 18 

举个例子：
组个包，从上往下。画图。
飞秋用的UDP，局域网用的都是UDP，如果跨网关，跨路由器都是用的TCP
UDP效率高，但是不安全。TCP是比较安全的。
看截图，走那个协议每层中。
网络层，如果是数据包走 IP协议。
链路层要加一个MAC头。

接收，网络层会判断是不是我们这个IP，传输层判断哪个端口，是 会把数据丢到端口对应的缓冲区，
然后应用层的对应软件会去取数据。

协议栈会帮我们做很多事情。

之前链路层，有个MAC地址，要对方的，我怎么知道呢？发送ARP请求。
ARP地址解析协议，通过IP找MAC地址。

路由器 两种口，两块网卡，有一个叫网关 网卡，有一个是出外网的卡，外网网卡
有很多LAN口，可以连接到电脑上 
然后，A计算机要给B计算机发飞秋消息，前提是要知道MAC地址，
有一个缓存表，它是怎么得到的呢？
没有这个MAC，就会去请求MAC地址，发一个ARP，向所有广播，谁是小明，把你的作业给我
所有人都会收到，只有小明回了，即这个IP应答了。
不是这个局域网的还能拿到这个MAC地址吗？要不到，目的IP不是这个局域网的
就会把这个数据包扔给网关，网关怎么处理它不管，
网关也是一块网卡，一般设置为最大或者最小的那个 .1 / .255
所有，组包的时候，链路层，协议头目的IP填写网关的地址即可

ARP头部：28个字节
不管什么协议，前面的以太网头部不能少，14个字节
ARP 28个字节 
组包演示

以太网首部：
dest MAC 6 
src MAC 6
帧类型 2 (1 代表 以太网)

28字节ARP请求、应答：
硬件类型 2
协议类型 2  (0x0800 代表通过IP找MAC)
空 1
空 1
OP 2  (1ARP请求  2ARP应答  3RARP请求  4RARP应答)
发送端以太网地址 6   (以太网地址其实就是MAC地址)
发送端IP地址 4
目的以太网地址 6 (因为这里是请求，只需要填写00:00:00:00:00:00 别人返回给我的)
目的IP地址 4

应答还是这样子结构，只是内容发生了改变而已。

要先广播，14个字节的mac头，目的IP只能填写，ff:ff:ff:ff:ff:ff，任何网卡收到这个的，必须无条件接收
每一个人都收到，目的地址如何填写呢？网关只能网关收到，目的IP只能目的IP收到
28字节的arp报文。不会出局域网

分4层去组包，不是7层。

------网络设计模式-------------
B/S borwser/server 网页，QQ斗地主网页版 都需要服务器计算 客户端安全 
        开发周期短 B/S只能走HTTP协议，因为走浏览器了嘛
C/S client/server  英雄联盟 大型游戏都是本地自己计算，性能较好，但是客户端容易篡改数据 开发周期长 
        使用协议相对自由，可以在标准协议的基础上根据需求裁剪及定制

视频中主要学C/S 服务器是和核心，高并发的服务器 同时几百万个请求

一个程序最多开多少个线程？看情况 小型的可以开线程 但是淘宝这样早就崩了 如果这样设计

物数网传会表应。7层。

链路层 -- 网卡到网卡 即设备到设备    ARP RARP 
网络层 -- IP到IP   即主机到主机   ICMP(就是我们发的ping包)    IP 
传输层 -- 端口到端口  即进程到进程 TCP UDP 
应用层 --               FTP 

协议都有自己的格式，可以了解哈。

核心是TCP。

作业是 拆包 组包。 


------TCP和socket------------------
视频中之前系统编程 进程间通信：
无名管道 命名管道 mmap 文件 信号 消息队列 共享内存 
这些都只能用于 本机的进程间通信

不同的主机间进程通讯方法：socket 
socket 插座 成对出现 插头插座
我的电脑有，你的电脑也要有，否则无法通信。
把socket看成是一个 伪文件
有一个读缓冲区，有一个写缓冲区。
创建然后返回一个文件描述符，你要发送数据就往这个缓冲区放数据。
B同样道理，创建出socket，然后拿到描述符可以往缓冲区里读或写。
全双工的。
可以创建多个socket，也是可以的，一般一个就够了。
必须成对出现。
TCP通信的socket UDP通信的socket 

预备知识：
网络字节序：大小端。万一你电脑是小端，它电脑是大端，传的数据解析时候有问题了，怎搞？
切记：0x12345678 78是低位 
网络上走的数据都是大端。
主机A 不管你大端小端，发送数据必须是大端，这叫主机的字节序。
主机B 收数据时候，将大端数据转成本机的主机字节序。
我们将大端数据也叫网络字节序。
调个函数即可转。
即：发送数据，转大端的网络字节序
收数据，转主机字节序。 
以字节为单位转的哈，记住。
英文的，不需要转，是一个一个字节独立的。
它不是以整个为单位转的，是某一个范围判断是否大于字节1才转的。

转换函数：
#include <arpa/inet/h>
unit32_t htonl(unit32_t hostlong);
uint16_t htons(unit16_t hostshort)
unit32_t ntohl(unit32_t netlong);
uint16_t ntohs(unit16_t netshort)

h to nl h2nl(long) 主机 -> 网络字节序 转成大端的 long 用来转IP的
h to nl h2ns(s) 主机 -> 网络字节序 转成大端的 short 用来转端口的
ntohl ntohs 同理。

测试：转换函数。
#include <arpa/inet/h>
int main ()
{
        char buf[4] = {192,168,1,2};
        int num = *(num *)buf;
        int sum = htonl(num);
        // char *p = &sum;
        unsigned char *p = &sum;  写网络服务都用无符号最好

        printf("%d %d %d %d \n", *p, *(p+1), *(p+2), *(p+3))

        unsigned short a = 0x0102;
        unsigned short b = htons(a); 

        printf("%x \n", b);



        unsigned char buf[4] = {1,1,168,192};
        int num = *(int *)buf;
        int sum = ntohl(num);
        unsigned char *p = (unsigned char *)&sum;
        printf("%d %d %d %d \n", *p, *(p+1), *(p+2), *(p+3));
}

------点分十进制串---------------
"192.169.1.2" 把这种叫做点分十进制串
如何转成4个字节的大端？
#include <arpa/inet.h> 
int inet_pton(int af, const char *src, void *dst);
const char * inet_ntop(int af, const void *src, char *dst, socklen_t size);
支持IPV4 V6。

int inet_pton(int af, const char *src, void *dst);
p2n pton p是点分十进制串
 inet_pton 将点分十进制串 转成32位网络大端的数据
AF_INET IPV4 
AF_INET IPV6 
af: 
src 点分十进制串的首地址 
dst: 32位网络数据的地址
成功返回1 

const char * inet_ntop(
        int af,                 AF_INET
        const void *src,        32位大端网络数据的地址
        char *dst,              点分十进制串的首地址
        socklen_t size          存储点分制数组的大小 最多就是255.255.255.255 15+\0=16位 16个字节 
        );
将32位大端的网络数据转成点分十进制串 
返回值是 存储点分制数组首地址

int main ()
{
        unsigned char buf[4] = {192.168.1.4}; 发出数据
        unsigned int num = 0;
        inet_pton(AF_INET, buf, &num);
        unsigned char *p = (unsigned char *)&sum;
        printf("%d %d %d %d \n", *p, *(p+1), *(p+2), *(p+3));  192 168 1 4 已是大端了 

        char ip[16] = "";  收到数据
        printf("%s \n",  inet_ntop(AF_INET, &num, ip, 16));   "192.168.1.4"
}

-------ipv4套接字结构体-----------------
网络通信解决三大问题：协议 IP 端口 放到一个结构体中。
sockaddr 数据结构：
struct sockaddr 很多网络编程函数诞生于IPV4协议，那时候都使用的是sockaddr结构体，为了向前兼容，
在sockaddr退化成了(void *)的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，
地址族确定，然后函数内部再强制类型转换成所需的地址类型。

这个只能用于IPV4套接字
struct sockaddr_in
{
        sa_famaily_t sin-family;  family协议 AF_INET
        in_port_t    sin_port;    port端口 
        struct in_addr sin_addr;  addr ip地址 
}
struct in_addr 
{
        unit32_t s_addr;
}

struct sockaddr_in addr;
struct sockaddr_in6 addr2;
sendipv4("hehe", struct sockaddr_in);
sendipv6("hehe", struct sockaddr_in6);
咋办？
int char 
send("hehe", void *); 接口统一 要取地址转哈 struct sockaddr *
但是不是void* 有另一个通用套接字结构代替
struct sockaddr 
{
        ..famaly.. 
        ..sa_data[14]
}

----------TCP客户端代码-----------------------
socket模型创建流程图： 省略 截图 1 2 
TCP: 传输控制协议，出错重传，每次发送数据对方都会回ACK，可靠

客户端： 
打电话的模型：
建立连接 使用连接 关闭连接 
网络通信必须创建套接字。
socket()
connect()
write()
read()
close()

创建套接字 
socket(int domain, int type, int protocol)
domain: AF_INET 
type: SOCK_STREAM 用于TCP      有TCP UDP 原始(都要自己组包)
protocol: 0
成功返回文件描述符，失败-1

连接服务器 
connect(
        int sockfd,     socket套接字
        const struct sockaddr *addr, ipv4套接字结构体的地址
        socklen_t addrlen  ipv4套接字结构体的长度 
        );
视频中有个工具，netassist.exe 网络调试助手 做服务端
视频中自己写客户端。

创建套接字 
        int sock_fd;
        sock_fd = socket(AF_INET, SOCK_STREAM, 0);
连接服务器 
        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(8080);
        inet_pton(AF_INET, "192.168.21.29", &addr.sin_addr.s_addr)
        connect(sock_fd, (struct sockaddr *)&addr, sizeof(addr));
读写数据 
        char buf[1024] = "";
        while (1)
        {
                int n = read(STDIN_FILENO, buf, sizeof(buf));
                write(sock_fd, buf, n); // 发送数据给服务器 
                n = read(sock_fd, buf, sizeof(buf));
                write(STDOUT_FILENO, buf, n);
        }
关闭 
        close(sock_fd);

--------tcp服务器通信流程--------------------
socket() 创建套接字 
bind()  给套接字绑定固定的ip和port 客户端是随机绑定的，因为客户端不用服务别人，非要绑定也是可以的
listen() 1. 将套接字由主动变被动，只能等别人连接你。
         2. 创建一个连接队列，已完成连接队列 
            未完成连接队列 (当你完成三次握手，就会上升至已完成连接队列)
        listen(int sockfd, int backlog)
        sockfd: 套接字 
        backlog：已完成连接队列和未完成连接队列 数之和的最大值 128 
accept() 提取连接，从已完成连接队列提取连接 
         提取连接得到的是一个新的已连接套接字，接下来用这个已连接套接字和客户端通信 
         不会用原来的那个套接字通信了 思考为什么每次都创建新的套接字？如果请求套接字多了，服务端无法区分谁是谁
         监听套接字直负责监听，不会和原来的这个套接字通信了。
         如果没有新的连接了，accept会阻塞。一直等着有连接。
        accept(
                int socket, 套接字
                struct sockaddr *restrict address, 获取的是客户端的IP和端口信息 IPV4 
                socklen_t *restrict address_len   IPV4套接字结构体的大小的地址 定义一个变量接收，然后& &20这是不对的
                );
                返回新的已连接套接字的文件描述符，用它通信即可
read()
write()
read()
close()

TCP服务器通信步骤：
创建套接字 socket 
绑定  bind 
监听  listen 
提取  accept 
读写  
关闭  close 

-----09复习-------------
应用层协议：
FTP 文件传输协议 
HTTP 超文本传输协议
NFS  网络文件系统 

飞秋走UDP的

不同主机间的进程通信：socket 
socket: 读缓冲区 写缓冲区 
socket成对实现的 
字节序：大端小端，网络多是大端，大型服务器是大端，小型计算机多是小端
htonl 主机字节序转网络字节序
htons 
ntohl 
ntohs 

ip转换：
#include <arpa/inet.h> 
int inet_pton(int af, const char *src, void *dst);
将点分十进制 转成32位网络大端的数据 
参数：
af: AF_INET IPV4  
    AF_INET6 IPV6 
src: 点分十进制串的首地址
dst: 32位网络数据的地址 
成功返回1 

#include <arpa/inet.h> 
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
将32位大端的网络数据转成点分十进制串 
参数： 
        af: AF_INET
        src: 32位大端的网络数 地址
        dst: 存储点分十进制串 地址 
        size：存储点分串数组的大小 
        返回值：存储点分制串数组首地址 

网络通信解决三大问题：协议 IP 端口 

arp -a 查看max地址 

ipv4 v6套接字结构体 
通用套接字结构体(通通要转成这个结构体)
struct sockaddr 
{
        sa_famaily_t sa_famaily;
        char sa_data[14];
} 

TCP:
建立连接 使用连接 关闭连接 

创建套接字API：
#include <sys/socket.h> 
int socket(int domain, int type, int protocol);
创建套接字 
domain： AF_INET
type: SOCK_STREAM 流式套接字 用于TCP通信 
protocol: 0
成功返回文件描述符，失败返回-1 

连接服务器 
#include <sys/socket.h> 
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
sockfd: socket套接字 
addr: ipv4套接字结构体的地址 
addrlen: ipv4套接字结构体的长度 

截图看看。
listen:
int listen(int sockfd, int backlog);
sockfd: 套接字
backlog: 已完成连接队列和未完成连接队列 数之和的最大值，128 

accept:
int accept(int accept, struct sockaddr *restrict address, socklen_t *restrict address_len);
如果连接队列没有新的连接，accept会阻塞
功能：从已完成连接队列提取新的连接

tcp服务端通信步骤：
创建套接字 socket 
绑定 bind 
监听 listen 
提取 accept 
读写 
关闭 

client code:
{
        // 创建套接字 
        int sock_fd;
        sock_fd = socket(AF_INET, SOCK_STREAM, 0);
        // 连接服务器 
        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(8080);
        inet_pton(AF_INET, "192.168.21.29", &addr.sin_addr.s_addr);
        connect(sock_fd, (struct sockaddr *)&addr, sizeof(addr));
        // 读写数据 
        char buf[1024] = "";
        while (1)
        {
                int n = read(STDIN_FILENO, buf, sizeof(buf));
                write(sock_fd, buf, n);
                n = read(sock_fd, buf, sizeof(buf));
                write(STDOUT_FILENO, buf, n):
                printf("\n");
        }
        //关闭 
        close(sock_fd);
}

server code: ubuntu 
int main () 
{
        // 创建套接字 
        int lfd = socket(AF_INET, SOCK_STREAM, 0);
        // 绑定 
        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(8000);
        // addr.sin_addr.s_addr = INADDR_ANY; // 0 绑定的是通配地址 把所有的IP都绑定上 
        inet_pton(AF_INET. "192.168.21.37", addr.sin_addr.s_addr); // 单独给某个IP绑定
        int ret bind(lfd, (struct sockaddr *)&addr, sizeof(addr));
        if (ret < 0)
        {
                perror("");
                exit(0);
        }
        // 监听  
        listen(lfd, 128);
        // 提取 
        struct sockaddr_in cliaddr;
        socklen_t len = sizeof(cliaddr);
        int cfd = accept(lfd, (struct sockaddr *)&cliaddr, &len);
        char ip[16] = "";
        printf("new client ip=%s, port=%d \n", inet_ntop(AF_INET, &cliaddr.sin_addr.s_addr, ip, 16), 
        ntohs(cliaddr.sin_port));
        // 读写 
        char buf[1024] = "";
        while (1)
        {
                write(cfd, "hello", 5);
                read(cfd, buf, sizeof(buf));
                printf("%s \n", buf);
        }
        // 关闭 
        close(lfd); 无法监听新的连接了
        close(cfd); 无法通信了 
}

封装。举一个例子：包裹函数。
int Bind (int fd, const struct sockaddr *sa, socklen_t salen)
{
        int n;
        if ((n = bind(fd, sa, salen)) < 0)
                perr_exit("bind error");

        return n;
}

client: 读缓冲区 
server: 
服务端不断发送，上一次发送的512个还没有接收完，又发送了1024个，这个时候
客户端读取时无法区分，谁是上一次的，谁是这一次的。这种现象在网络中叫黏包。
你怎么去解决呢？
1. 约定好，一次发送固定的字节数 但是太死了，没有达到其他填0 
2. 数据的结尾加一个标记\n 
3. 加个头 这次多少字节的数据
截图，黏包读取函数。

--------三次握手-----------------
三次握手，建立连接的过程。
四次挥手，断开连接的过程。
电话面试的时候，如果你连这个都不知道，就不用来面试了。

确认序列号的含义：
1. 确认收到对方的报文 
2. 期望下一次对方的序列号为我的确认序列号

确认序列号等于：
对方发送过来的序列号 + 标志位长度SYN(1) + 数据长度 

面试题：发了SYN没有回ACK，会有什么问题？
就是第三次握手的时候，我没有回ACK了。
如果你给服务端发了ACK，就会进入到未完成连接队列，
如果一直不回ACK，就一直占用着未完成连接队列，如果多发几个ACK，就会占满。
占满之后，如果再来新的连接，其他连接就无法进入了。
这也是一个工具手段，SYN工具，导致没有新的连接的问题。
现在服务器聪明了，多长时间还没有回，就把你踢掉。

建立连接为什么要3次呢？2次不可以吗？

------四次挥手---------------------
发生在TCP断开连接的时候。
client server 谁先挂都可以。三次握手只能是client先。

-------滑动窗口-------------
<mss 1460> 最大报文长度 
下次的携带数据不要超过这个长度。三次握手的前两次。

MTC：最大传输单元，和网卡有关系 
最大一帧可以收的数据的长度是1500。

滑动窗口： 
太快了，来不及收的问题。
TCP报头：窗口尺寸16位 作用：缓冲区的大小 
A的缓冲区大小告诉B，不要一直发。

每次从缓冲区读走一个，就会回一个ACK，
那没有读，发送方怎么知道满了，三次握手时候有窗口尺寸，即缓冲区的大小，

滑动窗口，截图。
读走2个，然后就空出2个。

--------多进程实现并发服务器流程-------------------
之前只能处理1个客户端。
创建进程 fork 

6min 有点麻 
这节课有点麻 

--------代码实现多进程服务器-------------
int main ()
{
        创建套接字，绑定
        int lfd = tcp4bind(8000, NULL); 自己封装的 NULL所有IP绑定上
        监听 
        Listen(lfd, 128);
        提取 
        回射
        struct sockaddr_in cliaddr;
        socklen_t len = sizeof(cliaddr);
        while (1)
        {
                char ip[16] = "";
                提取
                int cfd = accept(lfd, (sockaddr *)&cliaddr, &len);  cfd新的套接字
                printf("new client ip=%s port=%d \n", inet_ntop(AF_INET, &cliaddr.sin_addr.s_addr, ip, 16),
                        ntohs(cliaddr.sin_port));
                fork创建子进程 
                pid_t pid;
                pid = fork();
                if (pid < 0)
                {
                        error("");
                        exit(0);
                }
                else if(pid == 0) 子进程 
                {
                        关闭lfd 
                        close(lfd);
                        char buf[1024] = "";
                        read(cfd, buf, sizeof(buf));
                        if (n < 0)
                        {
                                perror("");
                                close(cfd);
                                break;
                        }
                        else if (n == 0) 对方关闭了
                        {
                                prinf("client close \n");
                                close(cfd);
                                // break;
                                exit(0);
                        }
                        else 
                        {
                                printf("%s \n", buf);
                                write(cfd, buf, n);
                        }
                }
                else 父进程 
                {
                        close(cfd);
                        回收 

                }
        }
        关闭 
}

------回收子进程的资源  跳---------------


如果是两次握手呢？
A发了一个SYN包，然后各种原因导致了延时，迟迟没到B，
这个时候A以为丢包了，就会重发一个SYN包。B收到就返一个ACK。
但是现在之前的那个SYN包到了B这，这时候又会返回一个ACK，
就多创建了一个连接。
而三次握手。客户端A已经知道刚刚连接了，现在就不会回了。就不回第三次，建立就不成功了。

谁都可以先发起关闭的。
谁主动谁就要等。2MSL。







