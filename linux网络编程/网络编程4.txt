-----复习----------------
select: 跨平台 
    没有1024文件描述符的限制
缺点：每次监听都需要将监听的信息从应用层拷贝到内核 
    返回变化的文件描述符的个数，具体哪个文件描述符变化需要遍历
    大量并发，少量活跃，效率低

epoll:
    优点是上面的缺点
    没有1024文件描述符的限制 
    下次监听不需要将需要监听的文件描述符从应用层拷贝到内核
    返回的是已经变化的文件描述符，不需要遍历 
    大量并发，少量活跃，效率高 
epoll工作原理 

因为设置为水平触发，只要缓冲区有数据epoll_wait就会被触发，epoll_wait是一个系统调用，尽量少调用
所以尽量使用边沿触发，边沿触发数据来一次触发一次，这个时候要求一次性将数据读完，所以while循环读
读到最后read默认带阻塞，能让read阻塞，因为不能再去 监听，
设置cfd为非阻塞，read读到最后一次返回值为-1，判断errno的值为EAGAIN,代表数据读干净

工作中 边沿触发 + 非阻塞 = 高速模式。

---------epoll反应堆-----------------
本节课的学习目标设立。我觉得这个挺好的。
1. 了解epoll反应堆设计思想  后面会说一个库，但是掌握怎么实现还是重要
2. 了解线程池思想以及能看懂线程池实现源码
3. 掌握TCP和UDP的优缺点和使用场景
4. 说出UDP服务器通信流程
5. 说出UDP客户端通信流程 
6. 独立实现UDP服务端代码 
7. 独立实现UDP客户端代码 
8. 熟练掌握本地套接字进行本地进程通信 

！！！视频中老师说出了一个重要的编程观点：代码即使是很复杂的，也是需要自己看的，尤其是工作之后，
而不是有老师将给你听，那样效率低了，自己的学习能力也得不到锻炼的，需要逼迫自己去看。
工作中，需要看别人的代码，好的代码也要学习。看代码是很重要的。

epoll反应堆： 
    文件描述符 事件 回调函数 封装在一起 
    结构体来封装，
事件驱动结构体：
typedef struct xx_event 
{
    int fd;
    int events;
    void (*call_back)(int fd, int events, void *arg);
    void *arg;
    char buf[1024];
    int buflen;
    int epfd;
} xevent;
xevent myevents[_EVENT_SIZE + 1];

也是c写的。看demo源码。

17min 跳。

-------线程池概念----------------
把消耗 时间慢的 用子线程去处理 处理完了就销毁
这个时候不是说每来一个任务，用一个线程去处理
而是一个客户端有请求的时候，就创建线程销毁线程
相当于现在不断地创建销毁 效率就低了








