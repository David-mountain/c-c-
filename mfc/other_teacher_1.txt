https://www.bilibili.com/video/BV1LK4y1v7o1/?p=5&spm_id_from=pageDriver&vd_source=3a90c28136589066688d4183d633571f

任何东西，规模起来了，也是一个难度。
封装的过程，迭代的过程
函数指针运用 定义一个函数指针
一个结构体写法：陌生
struct tagMESSAGEMAP
{
 UNIT uMsg,
 FXN pFun;
};
tagMESSAGEMAP MessageMaps[] = {
 WM_CREATE,  OnCreate,
 WM_CHAR,      OnChar
 把所有结构体成员 都写在一起了
}

体会封装的通用性-》好用性
这玩意就是设计模式的运用
通用代码和业务逻辑的分离
miniMFC
winMain的5个步骤，1-4窗口相关 5消息循环
注册窗口 创建窗口 显示窗口 更新窗口
体会面向过程 到面向对象的转变过程 
很多参数传过来，一般是定义一个结构体

变成了两大步：
1. 实例化窗口
2. 消息循环
然后把这两大步又封装到一个类中 CAapp 
成员函数 InitInstance -实例化窗口
Run - 消息循环

主窗口只有一个 子窗口可以多个
然后又放到了构造中，只需要new哈就可以了
问：main中不写代码，打印hello world?
不能用类，用纯c
#include <stdio.h>
int ff ()
{
 printf("hello world\n"); 
 return 0;
}
int x = ff();

void main ()
{}
利用了给全局变量赋值，不能直接调用ff()

CApp 大管家 窗口创建等 调用等
CMYWnd 窗口类
静态函数-假全局函数
VS 常看类视图 整体类结构把握

继续整理封装
业务和技术分开，类库
和业务相关的放在CPP中，和业务无关的放在.h中
以后就可以使用头文件导入即可
遇到一个难点：要某部分放到.cpp中 因为业务相关
但是不好拿过去 static 业务回调函数几个 
然后定义成宏 宏调用 
宏定义好麻烦 续航符 空格很难找原因 只有选中能发现
即：把宏定义放在的.cpp中，.h中只是一个调用，以后修改
就直接修改.cpp即可

MFC核心：就是消息映射，就是上面这部分
前因后果不说，直接上来就说源码宏，你听不明白的
看书也看不明白

-----------------看看真正的MFC----------
看源码
我们的WinMain需要藏起来
MFC调试学法不对 入口转义了
真正的入口是CApp inia run 两个































